
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Ayuda electr¢nica de DIV Games Studio 2.0 (Castellano)
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

# Los saltos de l¡nea simples son ignorados,
# los saltos de dos o m s l¡neas se interpretan
# como saltos de p rrafo.

# Los comentarios s¢lo pueden comenzar con un
# car cter '#' en la primera columna de una l¡nea.

# Lista de comandos disponibles

# Texto en negrita:
#   {texto a resaltar}

# Definici¢n de un t‚rmino: (la l¡nea anterior debe estar en blanco)
#   {.N,t¡tulo}
#   texto ...

# Referencia a un t‚rmino:
#   {#N,texto}

# Imagen: (N:c¢digo dentro de figuras.div (fpg), C:centrado 0, 1 o 2)
#   {+N,C}

# Final de la imagen (se debe indicar para todas las im genes)
#   {-}

# Car cter '{' o '}':
#   {{} o {}}

# Linea separatoria:
#   {/}

# Salto de l¡nea simple:
#   ú  (shift+3)

# Texto de lenguaje.div:
#   {@N}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Enlace informativo de que una referencia todav¡a no se ha definido
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.0,Enlace del hipertexto inv lido}

Error: No hay ninguna p gina de ayuda asociada a este enlace.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Ayuda sobre como usar el sistema de ayuda
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1,C¢mo usar el sistema de ayuda}{+5,1}{-}

Las p ginas de ayuda se manejan con el rat¢n, aunque tambi‚n se pueden utilizar
los siguientes controles del teclado.

{Cursores}    - Desplazar el texto l¡nea a l¡nea.ú
{Re/Av.P g.}  - Retroceso y avance de p gina.ú
{ESC}         - Quitar la ventana de ayuda.ú
{Borrar}      - Volver a la p gina anterior.ú

Estos controles se podr n utilizar £nicamente cuando la ventana de ayuda est‚
seleccionada (para seleccionar una ventana basta con pulsar con el rat¢n sobre
la misma).

En la parte inferior derecha aparece un bot¢n que sirve para {modificar el
tama¤o de la ventana de ayuda}; para ello se debe mantener el rat¢n pulsado
mientras se desplaza este verticalmente.

Los textos que aparecen en {#1,color blanco} son {referencias a otras
p ginas de ayuda} (el cursor del rat¢n se mostrar  como una peque¤a mano al
situarse sobre ellas). Para visualizar la p gina de ayuda referenciada bastar 
con pulsar sobre estos textos.

Los {ejemplos} son programas o partes de programas que aparecen en la ayuda
para demostrar la forma de utilizar alguna de las capacidades
del lenguaje de programaci¢n. Todos ellos comienzan con una l¡nea en color
blanco, como se muestra a continuaci¢n.

{#9999,Programa ejemplo:}
PROGRAM ejemplo;

BEGIN
    // ...
END
{-}

Para extraer el ejemplo de la ventana de ayuda basta con pulsar sobre dicha
l¡nea. Estos programas pueden ser ejecutados con la tecla {F10} y para
finalizar su ejecuci¢n se deben pulsar las teclas {ALT}+{X}.

{/}

En la parte superior de la ventana de ayuda aparecen una serie de botones
que permiten, respectivamente, visualizar las p ginas anteriores ({<<} y {>>}),
mostrar algunos de los ¡ndices m s importantes ({Indice}, {Glosario} y {Funciones}),
enviar la p gina actual a la impresora ({Imprimir}), y obtener ayuda sobre
como usar este hipertexto ({?}, que acceder  a esta misma p gina).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Indice general
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.3,Indice general}{+2,1}{-}

{#2000,Introducci¢n a DIV Games Studio 2.0}ú

{Ayuda sobre el lenguaje de programaci¢n}

  {#4,Glosario de t‚rminos}ú
  {#1000,Sintaxis de un programa}ú
  {#1017,Relaci¢n de sentencias}ú
  {#1032,Lista de funciones}ú

  {#1202,Constantes predefinidas}ú
  {#1200,Datos globales predefinidos}ú
  {#1201,Datos locales predefinidos}ú

  {#1035,Expresiones aritm‚ticas}ú
  {#1037,Condiciones l¢gicas}ú

  {#1176,C¢digos del teclado}ú

  {#2001,Novedades del lenguaje}

{Ayuda sobre los comandos de teclado}

  {#1291,Comandos en el entorno gr fico}ú
  {#1292,Comandos comunes en los juegos}ú
  {#1293,Comandos en el trazador de programas}ú
  {#1294,Comandos en el editor de programas}ú
  {#1295,Comandos en el editor gr fico}ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Glosario de t‚rminos
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.4,Glosario de t‚rminos}{+3,1}{-}

{#1046,!=}ú
{#1045,!}ú
{#1047,"}ú
{#1049,%=}ú
{#1048,%}ú
{#1051,&&}ú
{#1052,&=}ú
{#1050,&}ú
{#1047,'}ú
{#1053,(}ú
{#1053,)}ú
{#1002,*/}ú
{#1055,*=}ú
{#1054,*}ú
{#1057,++}ú
{#1058,+=}ú
{#1056,+}ú
{#1059,,}ú
{#1061,--}ú
{#1062,-=}ú
{#1063,->}ú
{#1060,-}ú
{#1064,..}ú
{#1063,.}ú
{#1002,/*}ú
{#1002,//}ú
{#1066,/=}ú
{#1065,/}ú
{#1067,:}ú
{#1068,;}ú
{#1071,<<=}ú
{#1070,<<}ú
{#1072,<=}ú
{#1046,<>}ú
{#1069,<}ú
{#1072,=<}ú
{#1074,==}ú
{#1075,=>}ú
{#1073,=}ú
{#1075,>=}ú
{#1078,>>=}ú
{#1077,>>}ú
{#1076,>}ú
{#1079,[}ú
{#1079,]}ú
{#1081,^=}ú
{#1082,^^}ú
{#1079,^}ú
{#1084,|=}ú
{#1083,||}ú
{#1083,|}ú
{#1176,_a, _b, _c, ...}
{#1400,_case_sensitive}ú
{#1400,_extended_conditions}ú
{#1400,_free_sintax}ú
{#0231,_hidden}ú
{#1400,_ignore_errors}ú
{#1400,_max_process}ú
{#1400,_no_check}ú
{#1400,_no_id_check}ú
{#1400,_no_null_check}ú
{#1400,_no_optimization}ú
{#1400,_no_range_check}ú
{#1400,_no_strfix}ú
{#0231,_normal}ú
{#1400,_simple_conditions}ú
{#0231,_subdir}ú
{#0231,_system}ú
{#0231,_volid}ú
{#0100,abs()}ú
{#0246,acos()}ú
{#0101,advance()}ú
{#0250,all_drawing}ú
{#1162,all_sound}ú
{#1161,all_text}ú
{#1051,and}ú
{#1129,angle}ú
{#1409,argc}ú
{#1409,argv[]}ú
{#1109,ascii}ú
{#0245,asin()}ú
{#0247,atan()}ú
{#0248,atan2()}ú
{#1086,begin}ú
{#1120,bigbro}ú
{#1026,break}ú
{#1404,byte}ú
{#1175,c_0 ... c_9}ú
{#1169,c_m7}ú
{#1412,c_m8}ú
{#1167,c_screen}ú
{#1168,c_scroll}ú
{#0254,calculate()}ú
{#1087,case}ú
{#0256,change_channel()}ú
{#0102,change_sound()}ú
{#1416,channel[]}ú
{#0184,char()}ú
{#0235,chdir()}ú
{#0103,clear_screen()}ú
{#1030,clone}ú
{#1134,cnumber}ú
{#0104,collision()}ú
{#1400,compiler_options}ú
{#1171,complete_dump}ú
{#1174,complete_restore}ú
{#0262,compress_file()}ú
{#1004,const}ú
{#1027,continue}ú
{#0105,convert_palette()}ú
{#0243,cos()}ú
{#1122,ctype}ú
{#1031,debug}ú
{#0261,decode_file()}ú
{#1088,default}ú
{#0106,define_region()}ú
{#0250,delete_draw()}ú
{#0107,delete_text()}ú
{#1413,dirinfo (struct)}ú
{#0238,disk_free()}ú
{#0249,draw()}ú
{#1418,draw_z}ú
{#1114,dump_type}ú
{#1089,dup}ú
{#1090,else}ú
{#0259,encode()}ú
{#0260,encode_file()}ú
{#0108,end_fli()}ú
{#1091,end}ú
{#0109,exit()}ú
{#0110,fade()}ú
{#0111,fade_off()}ú
{#0112,fade_on()}ú
{#1107,fading}ú
{#1152,false}ú
{#1104,fast_mixer}ú
{#1117,father}ú
{#0224,fclose()}ú
{#0113,fget_angle()}ú
{#0114,fget_dist()}ú
{#1414,fileinfo (struct)}ú
{#0229,filelength()}ú
{#1131,file}ú
{#0264,find_color()}ú
{#1127,flags}ú
{#0230,flush()}ú
{#0223,fopen()}ú
{#0266,force_pal()}ú
{#1025,for}ú
{#1426,fps}ú
{#0115,frame_fli()}ú
{#1029,frame}ú
{#0225,fread()}ú
{#0258,free()}ú
{#1043,from}ú
{#0227,fseek()}ú
{#0228,ftell()}ú
{#1408,function}ú
{#0226,fwrite()}ú
{#1164,g_height}ú
{#1163,g_wide}ú
{#1165,g_x_center}ú
{#1166,g_y_center}ú
{#0116,get_angle()}ú
{#0231,get_dirinfo()}ú
{#0117,get_dist()}ú
{#0118,get_distx()}ú
{#0119,get_disty()}ú
{#0232,get_fileinfo()}ú
{#0120,get_id()}ú
{#0121,get_joy_button()}ú
{#0122,get_joy_position()}ú
{#0123,get_pixel()}ú
{#0124,get_point()}ú
{#0195,get_point_m8()}ú
{#0125,get_real_point()}ú
{#0193,get_sector_height()}ú
{#0198,get_sector_texture()}ú
{#0220,get_song_line()}ú
{#0219,get_song_pos()}ú
{#0200,get_wall_texture()}ú
{#0233,getdrive()}ú
{#1006,global}ú
{#0191,go_to_flag()}ú
{#0126,graphic_info()}ú
{#1126,graph}ú
{#1133,height}ú
{#1092,id}ú
{#1020,if}ú
{#0240,ignore_error()}ú
{#1014,import}ú
{#1402,int}ú
{#0127,is_playing_cd()}ú
{#0222,is_playing_song()}ú
{#0221,is_playing_sound()}ú
{#0255,itoa()}ú
{#1103,joy (struct)}ú
{#1111,joy_filter}ú
{#1112,joy_status}ú
{#0128,key()}ú
{#0129,let_me_alone()}ú
{#0130,load()}ú
{#0131,load_fnt()}ú
{#0132,load_fpg()}ú
{#0174,load_map()}ú
{#0133,load_pal()}ú
{#0134,load_pcm()}ú
{#0174,load_pcx()}ú
{#0265,load_screen()}ú
{#0214,load_song()}ú
{#0134,load_wav()}ú
{#0189,load_wld()}ú
{#1007,local}ú
{#1024,loop}ú
{#0210,lower()}ú
{#1150,m320x200 ... m1024x768}ú
{#1102,m7 (struct)}ú
{#1411,m8 (struct)}ú
{#1424,m8_nextsector}ú
{#1423,m8_sector}ú
{#1425,m8_step}ú
{#1422,m8_wall}ú
{#0257,malloc()}ú
{#0135,map_block_copy()}ú
{#0136,map_get_pixel()}ú
{#0137,map_put()}ú
{#0138,map_put_pixel()}ú
{#0139,map_xput()}ú
{#1178,max_int}ú
{#1115,max_process_time}ú
{#0239,memory_free()}ú
{#1177,min_int}ú
{#0236,mkdir()}ú
{#1048,mod}ú
{#1100,mouse (struct)}ú
{#0251,move_draw()}ú
{#0140,move_scroll()}ú
{#0141,move_text()}ú
{#0142,near_angle()}ú
{#1410,net (struct)}ú
{#0181,net_get_games()}ú
{#0180,net_join_game()}ú
{#0188,new_map()}ú
{#1172,no_restore}ú
{#1045,not}ú
{#1419,num_video_modes}ú
{#1085,offset}ú
{#1083,or}ú
{#0143,out_region()}ú
{#1170,partial_dump}ú
{#1173,partial_restore}ú
{#0185,path_find()}ú
{#0187,path_free()}ú
{#0186,path_line()}ú
{#1179,pi}ú
{#0144,play_cd()}ú
{#1405,pointer}ú
{#0145,pow()}ú
{#1121,priority}ú
{#1008,private}ú
{#1016,process}ú
{#1003,program}ú
{#0146,put()}ú
{#0147,put_pixel()}ú
{#0148,put_screen()}ú
{#0213,qsort()}ú
{#1104,quality_mixer}ú
{#1421,radius}ú
{#0149,rand()}ú
{#0150,rand_seed()}ú
{#0152,refresh_scroll()}ú
{#1130,region}ú
{#0237,remove()}ú
{#1023,repeat}ú
{#1116,reserved}ú
{#0153,reset_fli()}ú
{#0175,reset_sound()}ú
{#1135,resolution}ú
{#1113,restore_type}ú
{#1028,return}ú
{#0154,roll_palette()}ú
{#1160,s_freeze_tree}ú
{#1156,s_freeze}ú
{#1157,s_kill_tree}ú
{#1153,s_kill}ú
{#1159,s_sleep_tree}ú
{#1155,s_sleep}ú
{#1158,s_wakeup_tree}ú
{#1154,s_wakeup}ú
{#0155,save()}ú
{#0241,save_map()}ú
{#0241,save_pcx()}ú
{#1110,scan_code}ú
{#0212,screen_copy()}ú
{#1101,scroll (struct)}ú
{#0227,seek_cur}ú
{#0227,seek_end}ú
{#0227,seek_set}ú
{#0179,set_color()}ú
{#0201,set_env_color()}ú
{#0196,set_fog()}ú
{#0156,set_fps()}ú
{#0157,set_mode()}ú
{#0194,set_point_m8()}ú
{#0192,set_sector_height()}ú
{#0197,set_sector_texture()}ú
{#0218,set_song_pos()}ú
{#0178,set_volume()}ú
{#0199,set_wall_texture()}ú
{#0234,setdrive()}ú
{#1104,setup (struct)}ú
{#1093,setup_program}ú
{#1108,shift_status}ú
{#0158,signal()}ú
{#0242,sin()}ú
{#1094,sizeof()}ú
{#1128,size}ú
{#1119,smallbro}ú
{#0216,song()}ú
{#1118,son}ú
{#0159,sound()}ú
{#1104,sound_bits_16}ú
{#1104,sound_bits_8}ú
{#0160,sqrt()}ú
{#0161,start_fli()}ú
{#0162,start_mode7()}ú
{#0190,start_mode8()}ú
{#0163,start_scroll()}ú
{#1095,step}ú
{#0164,stop_cd()}ú
{#0165,stop_mode7()}ú
{#0182,stop_mode8()}ú
{#0166,stop_scroll()}ú
{#0217,stop_song()}ú
{#0167,stop_sound()}ú
{#0203,strcat()}ú
{#0206,strchr()}ú
{#0205,strcmp()}ú
{#0202,strcpy()}ú
{#0211,strdel()}ú
{#1406,string}ú
{#0204,strlen()}ú
{#0208,strset()}ú
{#0207,strstr()}ú
{#1012,struct}ú
{#1021,switch}ú
{#0168,system()}ú
{#0244,tan()}ú
{#1106,text_z}ú
{#1105,timer[]}ú
{#1096,to}ú
{#1151,true}ú
{#1042,type}ú
{#0263,uncompress_file()}ú
{#1420,unit_size}ú
{#0177,unload_fnt()}ú
{#0169,unload_fpg()}ú
{#0176,unload_map()}ú
{#0170,unload_pcm()}ú
{#0176,unload_pcx()}ú
{#0215,unload_song()}ú
{#0170,unload_wav()}ú
{#1097,until}ú
{#0209,upper()}ú
{#1415,video_modes (struct)}ú
{#1417,vsync}ú
{#1022,while}ú
{#1403,word}ú
{#0171,write()}ú
{#0253,write_in_map()}ú
{#0172,write_int()}ú
{#0183,xadvance()}ú
{#1132,xgraph}ú
{#1082,xor}ú
{#0173,xput()}ú
{#1123,x}ú
{#1124,y}ú
{#1125,z}ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Funciones
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.100,abs()}

{abs(}<expresi¢n>{)}

{Retorna:}

El {valor absoluto} de la expresi¢n.

{Descripci¢n:}

Calcula el valor absoluto de la expresi¢n pasada como par metro, es decir,
si el resultado de la expresi¢n es negativo lo cambiar  de signo,
si es positivo lo dejar  igual.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_abs;

GLOBAL
    INT valores[15];
    INT n;

BEGIN
    FROM n=0 TO 15;
        valores[n]=rand(-1000, 1000);
        write_int(0, 0, n*10,0, offset valores[n]);
    END
    write(0, 0, 192, 0, "Pulse [ESPACIO] para ejecutar la funci¢n abs()");
    LOOP
        IF (key(_space))
            FROM n=0 TO 15;

                valores[n] = abs(valores[n]); // Hallamos el valor absoluto

            END
        END
        FRAME;
    END
END
{-}

Este programa imprimir  en pantalla una lista de valores que pueden ser
positivos o negativos, cuando se pulse la barra espaciadora le aplicar 
la funci¢n {abs()} a todos estos valores, dej ndolos todos positivos.

{/}Ver: {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.101,advance()}

{advance(}<distancia>{)}

{Descripci¢n:}

Avanza el proceso en su  ngulo (el que indique la variable local {#1129,angle})
tantos puntos como indique la {expresi¢n} (distancia) pasada como par metro.

Para avanzar en un  ngulo distinto al contenido en esta variable se puede utilizar
la funci¢n {#183,xadvance()}.

La distancia puede ser tambi‚n un n£mero negativo, con lo cual el gr fico
del proceso avanzar  (sus coordenadas {#1123,x} e {#1124,y}) en la direcci¢n
contraria a su  ngulo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_advance;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=101;
    x=160;
    y=100;
    write(0, 0, 0, 0, "Use los cursores para cambiar la direcci¢n.");
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END

        advance(2); // Avanzamos dos puntos el proceso

        FRAME;
    END
END
{-}

Este ejemplo dibujar  un tri ngulo en pantalla que avanzar  en la direcci¢n
especificada en la variable local predefinida {#1129,angle} utilizando esta funci¢n.

Se recuerda que el  ngulo se especifica en mil‚simas de grado.

Se podr  modificar la variable {#1129,angle} usando las teclas de los cursores
(sumando y restando 10000, es decir, 10 grados).

{/}

Esta funci¢n equivale siempre a las dos siguientes sentencias:

  {x+=get_distx(angle,} <distancia>{);}ú
  {y+=get_disty(angle,} <distancia>{);}ú

Es decir, esta funci¢n £nicamente modifica las coordenadas del proceso.
Cabe la posibilidad de utilizar las dos sentencias anteriores cuando se
quiera que el proceso avance en un  ngulo diferente al que indica su variable
{#1129,angle}; esto resultar  £til cuando se quiera que el gr fico del proceso
avance en una direcci¢n sin rotarse.

Por ejemplo, para conseguir que un proceso avance 8 puntos en una direcci¢n (que se
podr¡a tener en una variable privada como {angle2}) pero rotado hacia
otra direcci¢n, (la indicada en {#1129,angle}), se utilizar¡an las sentencias:

  {x+=get_distx(angle2, 8);}ú
  {y+=get_disty(angle2, 8);}ú

{/}Ver: {#183,xadvance()} - {#1044,Uso de  ngulos en el lenguaje} - {#118,get_distx()} - {#119,get_disty()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.102,change_sound()}

{change_sound(}<canal>{,} <volumen>{,} <frecuencia>{)}

{Descripci¢n:}

Para utilizar esta funci¢n es imprescindible tener una tarjeta de sonido
instalada en el ordenador compatible 100% con las tarjetas de la familia
{Sound Blaster} (tm) o {Gravis Ultrasound} (tm).

Esta funci¢n tiene sentido utilizarla s¢lo tras la funci¢n {#159,sound()}
que es la utilizada para emitir sonidos.

{Change_sound()} modifica un sonido que est  sonando por uno de los {canales},
estableciendo nuevamente su {volumen} y su {frecuencia}.

El {canal} es el {c¢digo de canal} que devuelve la funci¢n {#159,sound()} cuando
es llamada; pueden sonar hasta 16 canales a la vez, con el mismo sonido o
con diferentes sonidos, por lo tanto, cada vez que se emite un sonido se
har , posiblemente, por un canal diferente.

Cada {canal} tiene establecidos en todo momento su nivel de volumen y de
frecuencia.

El {volumen} es un valor entre {0} (volumen m¡nimo) y {512} (volumen m ximo)
que determina la potencia con la que se escuchar  el sonido de dicho canal.

La {frecuencia} es un valor que afecta a la velocidad a la que se oye el
sonido por el canal, es decir, controla lo grave o agudo que se emite el sonido.
Este valor oscila entre {0} (grave) y {512} (agudo).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_change_sound;

PRIVATE
    frecuencia=256;     // Valor medio (0..512)
    volumen=256;        // Valor medio (0..512)

    id_sonido;
    canal;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    id_sonido = load_pcm("help\help.pcm", 1);
    canal = sound(id_sonido, volumen, frecuencia);

    write(0, 0, 0, 0, "Presione derecha o izquierda para cambiar la frecuencia.");
    write_int(0, 0, 10, 0, offset frecuencia);
    write(0, 0, 20, 0, "Presione arriba o abajo para cambiar el volumen.");
    write_int(0, 0, 30, 0, offset volumen);
    LOOP

        // Cambia el sonido
        change_sound(canal, volumen, frecuencia);

        IF (key(_right)) frecuencia++; END
        IF (key(_left)) frecuencia--; END
        IF (key(_up)) volumen++; END
        IF (key(_down)) volumen--; END
        FRAME;
    END

END
{-}

En el ejemplo se carga y se emite un sonido (contenido en el archivo
{help.pcm}). Dentro del bucle principal del programa se cambia
la frecuencia y el volumen de este sonido con la funci¢n {change_sound()};
para modificar estos valores se utilizan las teclas de los cursores.

{/}Ver: {#134,load_pcm/wav()} - {#159,sound()} - {#170,unload_pcm/wav()} - {#1104,STRUCT setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.103,clear_screen()}

{clear_screen()}

{Descripci¢n:}

Borra el fondo de la pantalla, es decir, los gr ficos que se hubieran puesto en ella con
las funciones {#146,put()}, {#173,xput()}, {#147,put_pixel()} y {#148,put_screen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_clear_screen;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 0, 0, 0, "Presione [ESPACIO] para que se borre la pantalla.");
    write(0, 0, 10, 0, "Presione [ENTER] para volver a visualizarla.");
    graph=100;
    x=160;
    y=100;
    LOOP
        IF (key (_space))

            clear_screen(); // Borra el gr fico de fondo de la pantalla

        END
        IF (key (_enter)) put_screen(0, 1); END
        FRAME;
    END
END
{-}

En el ejemplo se visualiza una pantalla de fondo con la funci¢n {#148,put_screen()}.
Al pulsar la barra espaciadora, se borra dicha pantalla.

Pulsando la tecla {Enter}, se vuelve a visualizar la pantalla de fondo.

Se puede observar c¢mo el gr fico del proceso (una bola que aparece en el
centro) no desaparece al utilizar la funci¢n {clear_screen()}, ya que
‚sta £nicamente borra el fondo de pantalla.

{/}Ver: {#146,put()} - {#173,xput()} - {#147,put_pixel()} - {#148,put_screen()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.104,collision()}

{collision(}<tipo de proceso>{)}

{Retorna:}

El {#1039,c¢digo identificador} de un proceso o {0}.

{Descripci¢n:}

sta es la funci¢n del lenguaje {para detectar choques} entre gr ficos.

Comprueba si el proceso actual (el que ejecut¢ esta funci¢n) colisiona con
uno del tipo indicado como par metro. Es decir, comprueba si los gr ficos
de ambos procesos est n, al menos, parcialmente superpuestos.

En caso de producirse una colisi¢n devolver  el {#1039,c¢digo identificador}
del proceso con el que est  chocando el proceso actual. En caso contrario la
funci¢n devolver  siempre {0}.

Si el proceso actual colisiona con varios procesos del tipo que se ha
especificado, la funci¢n {collision()} devolver  el resto de los
identificadores en las sucesivas llamadas que se realicen a la misma.

Para obtener, de esta forma, todos los {#1039,c¢digos identificadores} de los procesos
que colisionan con el actual no se debe utilizar la sentencia {#1029,FRAME}
entre dos llamadas consecutivas a la sentencia {collision()}. En el caso de
ejecutar un proceso una sentencia {#1029,FRAME}, esta funci¢n volver  a
retornar todos los {#1039,c¢digos identificadores} de procesos colisionantes
desde el primero.

Algo similar sucede si se ejecuta una llamada a la funci¢n especificando un
tipo de proceso diferente; si tras esto se vuelven a detectar las colisiones
con el tipo anterior, esta funci¢n tambi‚n volver  a retornar todos los
c¢digos desde el primero.

Cuando se quieren obtener los {#1039,c¢digos identificadores} de los procesos
de un tipo determinado aunque no se produzca ninguna colisi¢n con
ellos, se debe llamar a la funci¢n {#120,get_id()}.

Si lo que se pretende es comprobar la cercan¡a entre dos procesos sin que
necesariamente colisionen sus gr ficos, entonces se deber  emplear la
funci¢n {#117,get_dist()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_collision;

PRIVATE
    id2;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;
    proceso_m¢vil(80, 50, 101);
    LOOP
        delete_text(all_text);
        write(0, 160, 0, 1, "Use los cursores para mover el tri ngulo");

        id2 = collision(TYPE proceso_m¢vil); // Se detecta la colisi¢n

        IF (id2<>0)
            write(0, 160, 200, 7, "­ DETECTADA COLISION !");
        END
        FRAME;
    END
END

PROCESS proceso_m¢vil(x, y, graph);

BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
{-}

En este ejemplo se visualiza una pelota en el centro de la pantalla
como gr fico del programa principal.
Luego se crea un proceso de nombre {proceso_m¢vil} con el dibujo de un
tri ngulo controlable con las teclas de los cursores.

El programa principal llamar  a la funci¢n {collision()} para comprobar
si su gr fico (el c¡rculo) colisiona con el gr fico del proceso de tipo {proceso_m¢vil}
(el tri ngulo). El resultado de la funci¢n se guarda en la variable privada
{id2} del programa principal; este valor ser  {0} cuando no se produzca la
colisi¢n y el {#1039,c¢digo identificador} de {proceso_m¢vil} cuando s¡.

Los c¢digos identificadores de los procesos son siempre n£meros impares,
que en el lenguaje se eval£an como condiciones verdaderas (y los n£meros
pares se corresponden con condiciones que resultan falsas), luego en el programa
anterior se podr¡a haber cambiado la sentencia:

  {IF (id2<>0)} ... {END}

Por la siguiente:

  {IF (id2)} ... {END}

Para m s informaci¢n al respecto ver: {#1037,Definici¢n de una condici¢n.}

{/}

Cuando en el programa se est‚ visualizando el puntero del rat¢n (asignando
el c¢digo del gr fico correspondiente en la {#1100,estructura mouse}), es
posible ver si ‚ste choca con el proceso actual utilizando esta funci¢n,
por ejemplo, de la siguiente forma:

  {IF (collision(TYPE mouse))}ú
      // El proceso colisiona con el puntero del rat¢nú
  {END}ú

Al detectarse la colisi¢n con el puntero del rat¢n no se har  con la
totalidad del gr fico utilizado como puntero, sino £nicamente con el
{#1136,punto de control} principal (el n£mero 0) del mismo, denominado
usualmente como el "punto caliente" ({hotspot}) del rat¢n.

{/}

Esta funci¢n sirve para detectar colisiones entre gr ficos de pantalla
o de una ventana de scroll.

No es posible utilizar esta funci¢n para detectar colisiones con
procesos que no tengan gr fico (un c¢digo v lido asignado a su variable
{#1126,graph}) o entre gr ficos de una ventana de modo 7 o modo 8 (con su variable
{#1122,ctype} asignada al valor {#1169,c_m7} o {#1412,c_m8}).

Es, por tanto, {imprescindible} que tanto el proceso actual como el del tipo
que se especifica tengan definido un gr fico.

Para detectar colisiones entre gr ficos de una ventana de modo 7 o modo 8 se debe
utilizar la funci¢n {#117,get_dist()} para detectar de esta forma cu ndo
la distancia entre los dos procesos es menor a la que se estipule como
{distancia de choque}.

{/}Ver: {#120,get_id()} - {#117,get_dist()} - {#1042,Tipos de procesos} - {#1038,Formas de obtener el c¢digo identificador}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.105,convert_palette()}

{convert_palette(}<fichero>{,} <gr fico>{,} <OFFSET nueva_paleta>{)}

{Descripci¢n:}

Transforma el mapa de color del {<gr fico>} del {<fichero>} indicado.

El {<}{#1085,offset}{ nueva_paleta>} es la direcci¢n dentro de la memoria del ordenador
de una tabla de 256 valores donde se indicar  el nuevo orden de los colores del
gr fico.

{Nota:} Esta tabla debe ser de datos simples (de tipo {#1402,INT}, enteros
de 32 bit con signo).

Si la tabla con la nueva paleta fuera como se muestra a continuaci¢n:

  nueva_paleta[255]=0, 1, 2, 3, 4, ... , 254, 255;

el gr fico no sufrir¡a ninguna transformaci¢n. Si, por ejemplo, en la posici¢n
3 de la tabla anterior (nueva_paleta[3]) se pusiera un 16 (en lugar de un 3),
al llamar a esta funci¢n con el {#1085,offset} de dicha tabla, se sustituir¡a en el
gr fico el color 3 por el color 16.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

Si un proceso quisiera cambiar los colores de su propio gr fico, se deber¡a
construir igualmente una tabla con el nuevo orden de los colores y, despu‚s,
llamar a la funci¢n con los par metros:

  {convert_palette(file, graph, }<OFFSET nueva_paleta>{)}

A continuaci¢n se muestra un programa que cambia los colores de su gr fico
de esta forma utilizando sus variables locales predefinidas {#1131,file} y
{#1126,graph}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_convert_palette;

PRIVATE
    nueva_paleta[255];
    contador;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    FROM contador=1 TO 255;
        nueva_paleta[contador]=(contador+16) MOD 256;
    END

    graph=100;
    x=160;
    y=100;

    write (0, 160, 0, 1, "Pulse [ESPACIO] para cambiar los colores de la bola");
    LOOP
        IF (scan_code==_space)

            // Convertimos la paleta del gr fico n£mero 100 (bola)
            convert_palette(file, graph, offset nueva_paleta);

        END
        FRAME;
    END
END
{-}

En primer lugar, {se crea una tabla con el nuevo orden de los colores}
de la paleta. El color n£mero 0 (transparente) no se sustituir  por ninguno
(nueva_paleta[0] valdr  siempre 0) y el resto de los colores (del 1 al 255)
se sustituir n por el color que est  16 posiciones m s arriba en la paleta
(el 1 por el 17, el 2 por el 18, etc.). Los £ltimos 16 colores se sustituir n
por los 16 primeros (al realizar la operaci¢n {MOD 256} se truncan los valores,
es decir, 256 pasar  a 0, 257 a 1, etc.).

Despu‚s, dentro del bucle principal del programa se ejecutar  la funci¢n
{convert_palette()} de modo que cambie los colores del gr fico del programa
(una bola) cada vez que se pulse la barra espaciadora.

{/}Ver: {#133,load_pal()} - {#154,roll_palette()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.106,define_region()}

{define_region(}<n£mero de regi¢n>{,} <x>{,} <y>{,}<ancho> {,}<alto> {)}

{Descripci¢n:}

Define una nueva regi¢n de visualizaci¢n dentro de la pantalla (algo as¡
como una ventana). Las regiones son zonas rectangulares de la pantalla dentro
de las cuales se visualizar n unos determinados procesos, ventanas de scroll
o de modo 7.

El {n£mero de regi¢n} debe ser entre 1 y 31. Se pueden definir hasta 31 regiones
diferentes de pantalla que despu‚s podr n asignarse a diferentes procesos
(fijando su variable local {#1130,region} al nuevo n£mero) como su ventana de
visualizaci¢n, o bien utilizarse como marco para una ventana de scroll o
de modo 7 indic ndolo en el par metro correspondiente de las funciones
{#163,start_scroll()} o {#162,start_mode7()}.

La {regi¢n n£mero 0} no se debe redefinir, pues ser  siempre la pantalla
completa, una ventana en las coordenadas (0, 0) y del ancho y alto de la pantalla.
sta es la regi¢n en la que se visualizar n por defecto todos los procesos,
ya que su variable local {#1130,region} siempre vale 0 por defecto.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_define_region;

PRIVATE
    contador;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    define_region(1, 0, 0, 160, 200);   // Definimos la regi¢n 1
    define_region(2, 160, 0, 160, 200); // Definimos la regi¢n 2

    write(0, 0, 0, 0, "Regi¢n 1");
    write(0, 320, 0, 2, "Regi¢n 2");

    FROM contador=1 TO 20;
        proceso_m¢vil(rand(0, 319), rand(0, 159), rand(-8, 8), rand(-8, 8), rand(1, 2));
    END
END

PROCESS proceso_m¢vil(x, y, incremento_x, incremento_y, region);

BEGIN
    graph=100;
    LOOP
        IF (x<0 OR x>320) incremento_x=-incremento_x; END
        IF (y<0 OR y>200) incremento_y=-incremento_y; END
        x+=incremento_x;
        y+=incremento_y;
        FRAME;
    END
END
{-}

Primero se definen dos regiones como divisiones laterales de la pantalla.
Luego, se crean con un bucle 20 procesos de tipo {proceso_m¢vil} en coordenadas
y desplazamiento aleatorios, en una de las dos regiones.

Se puede observar en su ejecuci¢n c¢mo cada proceso se ve £nicamente en
una de las dos mitades de la pantalla (s¢lo en su regi¢n).

{/}Ver: {#143,out_region()} - {#163,start_scroll()} - {#162,start_mode7()} - {#1130,Variable region}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.107,delete_text()}

{delete_text(}<identificador del texto>{)}

{Descripci¢n:}

Borra un texto definitivamente de la pantalla si se especifica como par metro
el {identificador del texto}, que es un c¢digo num‚rico que devuelven las
funciones {#171,write()} y {#172,write_int()} cuando se les pide que escriban un texto.

Si se especifica como par metro {#1161,all_text} se borrar n todos los textos
de pantalla.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_delete_text;

PRIVATE
    identificador_texto;

BEGIN
    write(0, 160, 10, 1, "Pulse [ENTER] para hacer aparecer el texto superior.");
    LOOP
        identificador_texto=write(0, 160, 0, 1, "Pulse [ESPACIO] para hacer desaparecer este texto.");
        WHILE (NOT key(_space))
            FRAME;
        END

        delete_text(identificador_texto); // Borramos el texto

        WHILE (NOT key(_enter))
            FRAME;
        END
    END
END
{-}

En el ejemplo anterior, se imprimen dos textos en pantalla. Cuando
se pulsa la barra espaciadora se borra uno de ellos con la funci¢n {delete_text()},
y cuando se pulsa la tecla Enter hacemos que vuelva a aparecer, imprimi‚ndolo otra vez
con la funci¢n {#171,write()}, la cual nos devuelve el identificador del texto.

{/}Ver: {#171,write()} - {#172,write_int()} - {#141,move_text()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.108,end_fli()}

{end_fli()}

{Descripci¢n:}

Finaliza una animaci¢n {FLI/FLC} visualizada en pantalla y libera la memoria
del ordenador que estaba ocupando.

Las animaciones {FLI/FLC} se inician con la funci¢n {#161,start_fli()}.

S¢lamente es posible tener una animaci¢n cargada en la memoria del
ordenador.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_end_fli;
BEGIN
    LOOP
        start_fli("help\help.fli", 0, 0);
        WHILE (frame_fli()<>0)
            FRAME;
        END

        end_fli(); // Descargamos la animacion de la memoria

    END
END
{-}

En primer lugar, en el ejemplo, se carga la animaci¢n con la funci¢n
{#161,start_fli()} y entonces se muestra la misma con {#115,frame_fli()}
hasta que acaba (cuando esta £ltima funci¢n devuelve un 0). En ese
momento se descarga de memoria utilizando {end_fli()}.

El programa contin£a repitiendo esta operaci¢n (de carga y descarga de la
animaci¢n {FLI/FLC}) indefinidamente.

No es necesario que la animaci¢n haya finalizado para poder descargarla
de memoria.

{/}Ver: {#161,start_fli()} - {#115,frame_fli()} - {#153,reset_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.109,exit()}

{exit(}<mensaje>{,} <c¢digo de retorno>{)}

{Descripci¢n:}

Termina el juego matando todos los procesos de forma inmediata y regresando
al sistema operativo (o al entorno DIV) con un {mensaje} y un {c¢digo num‚rico}
(el indicado en la expresi¢n del segundo par metro).

El mensaje es un texto entre comillas que aparecer  cuando finalice el juego
como mensaje de despedida para el jugador.

El {c¢digo de retorno} es v lido para el uso de programas externos a
DIV Games Studio (como ficheros de proceso por lotes BAT), para determinar
la acci¢n que se debe realizar tras ejecutarse el juego.

Cuando se utiliza la funci¢n {exit()} no es necesario haber descargado
previamente ning£n recurso, como ficheros, mapas, sonidos, etc., ya que
el sistema finaliza de forma autom tica todos los recursos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_exit;
BEGIN
    write(0, 160, 0, 1, "Pulsa [ESPACIO] para acabar el programa.");
    LOOP
        IF (key (_space))
            fade_off();

            exit("Gracias por usarme!", 0); // Salimos del programa

        END
        FRAME;
    END
END
{-}

En el ejemplo se imprime un mensaje y luego se espera a que se pulse la
barra espaciadora para salir del programa con la funci¢n {exit()}.

El uso de la funci¢n {#111,fade_off()} para apagar la pantalla no resulta
necesario.

{/}

Todos los programas terminar n su ejecuci¢n si se pulsa la combinaci¢n
de teclas {[ALT]+[X]} en cualquier momento; esto resulta similar a
forzar la ejecuci¢n de la funci¢n {exit()}, s¢lo que sin mensaje y con
el c¢digo de retorno 0.

{/}Ver: {#129,let_me_alone()} - {#111,fade_off()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.110,fade()}

{fade(}<% red>{,} <% green>{,} <% blue>{,} <velocidad>{)}

{Descripci¢n:}

Inicia un fundido de los colores de la paleta del juego hasta que se alcancen
los porcentajes de visualizaci¢n (desde 0% hasta 200%) de las componentes
{red} (rojo), {green} (verde) y {blue} (azul) que se indican como par metros.

El £ltimo par metro indica la velocidad a la que se va a realizar el fundido
de colores, normalmente se define un n£mero desde 1 (muy lentamente) hasta
10 (muy r pidamente).

Si se indica como velocidad un n£mero mayor o igual que 64, el fundido se
realizar  de forma instant nea.

El fundido se ir  realizando gradualmente en las sucesivas visualizaciones
del juego (en los siguientes fotogramas).

Si se ponen las tres componentes a 0 se har  un fundido a negro, si se ponen
a 200 se har  un fundido a blanco, y si se ponen a 100 se recuperar n los
colores originales de la paleta del juego.

Un valor inferior a 100 en una componente apagar  su color, mientras que un valor superior
a 100, saturar  el color.

Se recuerda que el fundido no se realiza al ejecutarse la funci¢n {fade()},
sino en las siguientes sentencias {#1029,FRAME}. Mientras se est  realizando
un fundido la variable global predefinida {#1107,fading} valdr  {cierto}
(un n£mero impar que en este caso ser  1) y cuando se termine el fundido
(se alcancen finalmente los valores de visualizaci¢n de color establecidos),
esta variable pasar  a valer {falso} (un numero par, el n£mero 0).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fade;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write (0, 0, 0, 0, "Pulsa [ESPACIO] para ir realizando los efectos.");
    LOOP
        IF (NOT fading AND key(_space))

            fade(rand(0, 200), rand(0, 200), rand(0, 200), 5);

        END
        FRAME;
    END
END
{-}

En el ejemplo se carga una pantalla como fondo y se imprime un mensaje;
despu‚s, cada vez que se pulse la barra espaciadora, si no se est 
realizando un fundido ({IF (NOT fading ...)}), se iniciar  uno con la
funci¢n {fade()} con las tres componentes de color elegidas al azar
entre 0% y 200% (con la funci¢n {#149,rand()}) y a velocidad 5.

{/}Ver: {#1107,fading} - {#111,fade_off()} - {#112,fade_on()} - {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.111,fade_off()}

{fade_off()}

{Descripci¢n:}

Realiza un fundido de los colores de la pantalla a negro. Se detiene el juego
tal y como est  hasta que la pantalla quede negra por completo. Realizar un
fundido a negro se denomina {apagar la pantalla}.

Para volver a encender la pantalla (deshacer el fundido a negro) se utiliza
la funci¢n {#112,fade_on()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fade_off;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write (0, 0, 0, 0, "Pulsa [ESPACIO] para apagar y encender la pantalla.");
    LOOP
        WHILE (NOT key(_space))
            FRAME;
        END

        fade_off(); // Apagamos la pantalla

        fade_on();
    END
END
{-}

En el ejemplo se pone una pantalla de fondo y despu‚s se espera
a que se pulse la barra espaciadora para apagar y encender la pantalla.

La funci¢n {#110,fade()} puede realizar esta misma funci¢n sin detener
el programa o a distintas velocidades, adem s de poder realizar otros
efectos de paleta m s avanzados.

{/}Ver: {#110,fade()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.112,fade_on()}

{fade_on()}

{Descripci¢n:}

Realiza un fundido de los colores de pantalla hasta su situaci¢n natural.
En las sucesivas visualizaciones del juego (al llegar la sentencia {#1029,FRAME})
los colores ir n recuperando su visibilidad hasta verse perfectamente.
A esta acci¢n se la denomina {encender la pantalla}.

Para apagar la pantalla (hacer un fundido a negro) se utiliza
la funci¢n {#111,fade_off()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fade_off;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write (0, 0, 0, 0, "Pulsa [ESPACIO] para apagar y encender la pantalla.");
    LOOP
        WHILE (NOT key(_space))
            FRAME;
        END
        fade_off();

        fade_on(); // Se enciende la pantalla

    END
END
{-}

En el primer ejemplo se pone una pantalla de fondo y despu‚s se espera a que
se pulse la barra espaciadora para apagar y encender la pantalla.

La funci¢n {#110,fade()} puede realizar esta misma funci¢n a distintas
velocidades, adem s de poder realizar otros efectos de paleta m s avanzados.

{/}

Todos los juegos realizan de forma autom tica un {fade_on()} al comienzo
de la ejecuci¢n.

{/}Ver: {#110,fade()} - {#111,fade_off()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.113,fget_angle()}

{fget_angle(}<x0>{,} <y0>{,} <x1>{,} <y1>{)}

{Retorna:}

El  ngulo entre dos puntos.

{Descripci¢n:}

Devuelve el  ngulo que hay desde el {punto 0} (x0, y0) hasta el {punto 1}
(x1, y1).

Se recuerda que el  ngulo se especifica en mil‚simas de grado. La funci¢n
devuelve siempre un valor entre{ -180000} y {180000} (un  ngulo entre -180 y
180 grados).

Como coordenadas de ambos puntos (x0, y0, x1, y1) se puede especificar
cualquier expresi¢n num‚rica v lida.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fget_angle;

PRIVATE
    coordenada_x0, coordenada_y0;
    coordenada_x1, coordenada_y1;
    resultado;
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    write(0, 0, 0, 0, "Coordenadas punto 1");
    write(0, 0, 10, 0, "X:");
    write_int(0, 20, 10, 0, offset coordenada_x0);
    write(0, 0, 20, 0, "Y:");
    write_int(0, 20, 20, 0, offset coordenada_y0);
    write(0, 0, 40, 0, "Coordenadas punto 2");
    write(0, 0, 50, 0, "X:");
    write_int(0, 20, 50, 0, offset coordenada_x1);
    write(0, 0, 60, 0, "Y:");
    write_int(0, 20, 60, 0, offset coordenada_y1);
    write(0, 0, 80, 0, "Angulo del punto 1 al punto 2:");
    write_int(0, 0, 90, 0, offset resultado);
    write(0, 0, 200, 6, "Pulsa [ESPACIO] para hallar otros dos puntos.");
    LOOP
        clear_screen();
        coordenada_x0=rand(0, 319);
        coordenada_y0=rand(0, 199);
        coordenada_x1=rand(0, 319);
        coordenada_y1=rand(0, 199);
        put(fichero1,200,coordenada_x0, coordenada_y0);
        put(fichero1,200,coordenada_x1, coordenada_y1);

        //Hallamos el  ngulo entre los dos puntos
        resultado = fget_angle(coordenada_x0, coordenada_y0, coordenada_x1, coordenada_y1);

        scan_code=0;
        WHILE (scan_code<>_space)
            FRAME;
        END
    END
END
{-}

En el ejemplo, despu‚s de poner los mensajes necesarios, se hallan las
coordenadas {x} e {y} de dos puntos hallados al azar y se guardan en las
variables destinadas para ello, calculando con la funci¢n {fget_angle()}
el  ngulo entre dichos puntos. Cada vez que se pulse la barra espaciadora
se repetir  el proceso.

La funci¢n {#116,get_angle()} se utiliza para obtener el { ngulo de un proceso
a otro}, en lugar de entre dos puntos.

La funci¢n {#114,fget_dist()} se utiliza para obtener la {distancia entre dos
puntos}, en lugar del  ngulo.

{/}Ver: {#1044,Uso de  ngulos en el lenguaje} - {#116,get_angle()} - {#114,fget_dist()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.114,fget_dist()}

{fget_dist(}<x0>{,} <y0>{,} <x1>{,} <y1>{)}

{Retorna:}

La distancia entre dos puntos.

{Descripci¢n:}

Devuelve la distancia que hay desde el {punto 0} (x0, y0) hasta el {punto 1}
(x1, y1).

Como coordenadas de ambos puntos (x0, y0, x1, y1) se puede especificar
cualquier expresi¢n num‚rica v lida.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fget_dist;

PRIVATE
    coordenada_x0, coordenada_y0;
    coordenada_x1, coordenada_y1;
    resultado;
    fichero1;

BEGIN

    fichero1=load_fpg("help\help.fpg");
    write(0, 0, 0, 0, "Coordenadas punto 1");
    write(0, 0, 10, 0, "X:");
    write_int(0, 20, 10, 0, offset coordenada_x0);
    write(0, 0, 20, 0, "Y:");
    write_int(0, 20, 20, 0, offset coordenada_y0);
    write(0, 0, 40, 0, "Coordenadas punto 2");
    write(0, 0, 50, 0, "X:");
    write_int(0, 20, 50, 0, offset coordenada_x1);
    write(0, 0, 60, 0, "Y:");
    write_int(0, 20, 60, 0, offset coordenada_y1);
    write(0, 0, 80, 0, "Distancia entre el punto 1 y el punto 2");
    write_int(0, 0, 90, 0, offset resultado);
    write(0, 0, 200, 6, "Pulsa [ESPACIO] para hallar otra distancia.");
    LOOP
        clear_screen();
        coordenada_x0=rand(0, 319);
        coordenada_y0=rand(0, 199);
        coordenada_x1=rand(0, 319);
        coordenada_y1=rand(0, 199);
        put(fichero1,200,coordenada_x0, coordenada_y0);
        put(fichero1,200,coordenada_x1, coordenada_y1);

        //Hallamos la distancia que hay entre los dos puntos
        resultado = fget_dist(coordenada_x0, coordenada_y0, coordenada_x1, coordenada_y1);

        scan_code=0;
        WHILE (scan_code<>_space)
            FRAME;
        END
    END
END
{-}

En el ejemplo, despu‚s de poner los mensajes necesarios se guardan las
coordenadas de dos puntos hallados aleatoriamente en las variables
definidas para tal efecto, obteniendo la distancia entre ellos con la
funci¢n {fget_dist()}. Cada vez que se pulse la barra espaciadora se
repetir  el proceso.

La funci¢n {#116,get_dist()} se utiliza para obtener la {distancia de un proceso
a otro}, en lugar de entre dos puntos.

La funci¢n {#114,fget_angle()} se utiliza para obtener el { ngulo entre dos
puntos}, en lugar de la distancia.

{/}

Esta funci¢n se puede utilizar para detectar choques entre procesos por
proximidad entre ellos, si bien suele utilizarse para ello la funci¢n
{#104,collision()} que detecta cuando dos procesos tienen sus gr ficos
superpuestos.

Por ejemplo, con los procesos visualizados dentro de una ventana de modo 7
(ver {#162,start_mode7()}) no se puede utilizar la funci¢n {#104,collision()}
debi‚ndose obtener la distancia entre los procesos (normalmente con
{#116,get_dist()}) para comprobar si chocan (si su distancia es menor que
una determinada).

{/}Ver: {#117,get_dist} - {#113,fget_angle} - {#104,collision()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.115,frame_fli()}

{frame_fli()}

{Retorna:}

{Cierto} si la animaci¢n contin£a y {falso} si ha terminado.

{Descripci¢n:}

Muestra la siguiente imagen de una animaci¢n {FLI/FLC} iniciada con la funci¢n
{#161,start_fli()}. Esta funci¢n devuelve {0} si termin¢ ya la animaci¢n.

Durante la ejecuci¢n del programa, £nicamente se podr  ejecutar una animaci¢n
{FLI/FLC} a la vez, es decir, no se podr n tener dos animaciones ejecut ndose
al mismo tiempo.

La imagen de la animaci¢n se ver  s¢lo en la siguiente imagen del juego
(cuando llegue la sentencia {#1029,FRAME}), por lo que si se realiza un
bucle, dentro del cual se llama a la funci¢n {frame_fli()} pero no a la
sentencia {#1029,FRAME}, no se visualizar  la animaci¢n en pantalla.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_frame_fli;
BEGIN
    start_fli("help\help.fli", 0, 0);
    LOOP

        frame_fli(); // Mostramos la siguiente imagen

        FRAME;
    END
END
{-}

En el ejemplo, se carga la animaci¢n {FLI/FLC} y luego se ejecuta indefinidamente
con la funci¢n {frame_fli()}.

{/}Ver: {#161,start_fli()} - {#153,reset_fli()} - {#108,end_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.116,get_angle()}

{get_angle(}<c¢digo identificador>{)}

{Retorna:}

El  ngulo hacia otro proceso.

{Descripci¢n:}

Devuelve el  ngulo desde el proceso actual (el que llam¢ a esta funci¢n) hasta
el proceso cuyo {#1039,c¢digo identificador} se le pasa como par metro.

Ver {#1038,formas de obtener el c¢digo identificador}, para m s informaci¢n.

Se recuerda que el  ngulo se especifica en mil‚simas de grado. La funci¢n
devuelve siempre un valor entre{ -180000} y {180000} (un  ngulo entre -180 y
180 grados).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_angle;

PRIVATE
     ngulo_resultante;
    identificador_proceso;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;

    identificador_proceso = proceso_m¢vil(80, 50, 101);

    write(0, 160, 200, 7, "Use los cursores para mover el tri ngulo.");
    write(0, 0, 0, 0, "Angulo desde la bola hacia el tri ngulo:");
    write_int(0, 0, 10, 0, offset  ngulo_resultante);
    LOOP

        // Hallamos el  ngulo entre los dos procesos
         ngulo_resultante = get_angle(identificador_proceso);

        FRAME;
    END
END

PROCESS proceso_m¢vil(x, y, graph);
BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
{-}

Al inicio se pone el fondo de pantalla y el programa principal define
su gr fico como una bola situada en el centro de la pantalla.

Desp£es, se crea un proceso del tipo {proceso_m¢vil} del cual se coge el
{#1039,c¢digo identificador}, que se puede controlar con
los cursores.

Dentro del bucle principal se calcula y muestra continuamente en pantalla
el  ngulo entre los dos procesos.

La funci¢n {#113,fget_angle()} se utiliza para obtener el { ngulo entre dos
puntos}, en lugar de entre dos procesos. Si el {#1039,c¢digo identificador}
del proceso se tiene, por ejemplo, en una variable denominada {id2}, entonces
la llamada a la funci¢n:

    {get_angle(id2)}

Ser¡a equivalente a:

    {fget_angle(x, y, id2.x, id2.y)}

Obtener el  ngulo desde las coordenadas (x, y) del proceso actual, hasta las
coordenadas (x, y) del proceso cuyo {#1039,c¢digo identificador} es {id2}.

La funci¢n {#117,get_dist()} se utiliza para obtener la {distancia hasta otro
proceso}, en lugar del  ngulo.

{/}Ver: {#1044,Uso de  ngulos en el lenguaje} - {#113,fget_angle()} - {#117,get_dist()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.117,get_dist()}

{get_dist(}<c¢digo identificador>{)}

{Retorna:}

La distancia hasta otro proceso.

{Descripci¢n:}

Devuelve la distancia desde el proceso actual (el que llam¢ a esta funci¢n) hasta
el proceso cuyo {#1039,c¢digo identificador} se le pasa como par metro.

Ver {#1038,formas de obtener el c¢digo identificador}, para m s informaci¢n.

Si el proceso ha definido su variable local {#1135,resolution} es importante
que el proceso hasta el que se quiere obtener la distancia la tenga definida
al mismo valor. Es decir, si ambos procesos manejan las coordenadas en
cent‚simas en lugar de unidades (con {#1135,resolution}=100), la distancia
entre ambos tambi‚n se obtendr  en cent‚simas, pero si el valor de dicha
variable difiere en ambos procesos, el resultado de la funci¢n {get_dist()}
carecer  de sentido.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_dist;

PRIVATE
    distancia_resultante;
    identificador_proceso;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;

    identificador_proceso = proceso_m¢vil(80, 50, 101);

    write(0, 160, 200, 7, "Use los cursores para mover el tri ngulo.");
    write(0, 0, 0, 0, "Distancia desde la bola hasta el tri ngulo:");
    write_int(0, 0, 10, 0, offset distancia_resultante);
    LOOP

        // Hallamos la distancia entre los dos procesos
        distancia_resultante = get_dist(identificador_proceso);

        FRAME;
    END
END

PROCESS proceso_m¢vil(x, y, graph)
BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
{-}

Al inicio se pone el fondo de pantalla y el programa principal define
su gr fico como una bola situada en el centro de la pantalla.

Desp£es se crea un proceso del tipo {proceso_m¢vil} del cual se coge el
{#1039,c¢digo identificador}, que se puede controlar con
los cursores.

Dentro del bucle principal se calcula y muestra continuamente en pantalla
la distancia entre los dos procesos.

La funci¢n {#114,fget_dist()} se utiliza para obtener la {distancia entre dos
puntos}, en lugar de entre dos procesos. Si el {#1039,c¢digo identificador}
del proceso se tiene, por ejemplo, en una variable denominada {id2}, entonces
la llamada a la funci¢n:

    {get_dist(id2)}

Ser¡a equivalente a:

    {fget_dist(x, y, id2.x, id2.y)}

Obtener la distancia desde las coordenadas (x, y) del proceso actual hasta las
coordenadas (x, y) del proceso cuyo {#1039,c¢digo identificador} es {id2}.

La funci¢n {#116,get_angle()} se utiliza para obtener el { ngulo hasta otro
proceso}, en lugar de la distancia.

{/}

Esta funci¢n se puede utilizar para detectar choques entre procesos por
proximidad entre ellos, aunque se suele utilizar para ello la funci¢n
{#104,collision()} que detecta cu ndo dos procesos tienen sus gr ficos
superpuestos.

Por ejemplo, con los procesos visualizados dentro de una ventana de modo 7
(ver {#162,start_mode7()}) no se puede utilizar la funci¢n {#104,collision()}
debi‚ndose obtener la distancia entre los procesos para comprobar si chocan
(si su distancia es menor que una determinada).

{/}Ver: {#114,fget_dist()} - {#116,get_angle()} - {#118,get_distx()} - {#119,get_disty()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.118,get_distx()}

{get_distx(}< ngulo>{,} <distancia>{)}

{Retorna:}

El desplazamiento horizontal del vector ( ngulo, distancia).

{Descripci¢n:}

Devuelve distancia horizontal (en el eje de la coordenada {x}) a partir del
 ngulo y {distancia} (sobre ese  ngulo) pasados como par metros. Es decir,
devuelve la distancia que recorre en horizontal el vector formado por el
 ngulo y {longitud} (distancia o m¢dulo del vector) indicados.

Se recuerda que el  ngulo se especifica en mil‚simas de grado y como
distancia se puede especificar cualquier expresi¢n num‚rica v lida.

La funci¢n utilizada para calcular la distancia vertical, en lugar de la
horizontal, es {#119,get_disty()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_distx;

GLOBAL
    distancia;
    distancia_horizontal;
    distancia_vertical;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 3);
    write(0, 160, 200, 7, "Utilice los cursores para mover el tri ngulo.");
    write(0, 0, 0, 0, "Distancia horizontal:");
    write_int(0, 0, 10, 0, offset distancia_horizontal);
    graph=101;
    LOOP
        IF (key(_up)) distancia+=2; END
        IF (key(_down)) distancia-=2; END
        IF (key(_right)) angle-=2000; END
        IF (key(_left)) angle+=2000; END

        // Calculamos la distancia horizontal
        distancia_horizontal = get_distx(angle, distancia);

        distancia_vertical = get_disty(angle, distancia);
        x=160+distancia_horizontal;
        y=100+distancia_vertical;
        FRAME;
    END
END
{-}

En el ejemplo se pone como fondo de la pantalla una gr fica circular,
sobre la que se manejar  con los cursores un tri ngulo, modificando
su distancia y  ngulo al centro de la gr fica.

El programa calcula la distancia horizontal y vertical para emplazar el
tri ngulo a partir de las coordenadas del centro de pantalla
(160, 100), mostr ndose en todo momento la distancia horizontal en la esquina
superior izquierda.

{/}

Si se quiere avanzar las coordenadas del proceso una {distancia} en un
 ngulo determinado, se pueden utilizar las siguientes sentencias:

  {x+=get_distx(}< ngulo>{,} <distancia>{);}ú
  {y+=get_disty(}< ngulo>{,} <distancia>{);}ú

Esto ser¡a equivalente a la siguiente sentencia (utilizando la funci¢n {#183,xadvance()}).

  {xadvance(}< ngulo>{,} <distancia>{);}

Si el  ngulo en el que se quiere mover el proceso es el que tiene en su
variable local {#1129,angle}, entonces esta misma operaci¢n se podr¡a
realizar con la funci¢n {#101,advance()} de la siguiente forma:

  {advance(}<distancia>{);}

{/}

La funci¢n {get_distx()} equivale a calcular el {coseno} del  ngulo y
multiplicarlo por la {distancia}.

{/}Ver: {#1044,Uso de  ngulos en el lenguaje} - {#119,get_disty()} - {#183,xadvance()} - {#101,advance()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.119,get_disty()}

{get_disty(}< ngulo>{,} <distancia>{)}

{Retorna:}

El desplazamiento vertical del vector ( ngulo, distancia).

{Descripci¢n:}

Devuelve distancia vertical (eje de la coordenada {y}) a partir del  ngulo y
{distancia} (sobre ese  ngulo) pasados como par metros. Es decir,
devuelve la distancia que recorre en vertical el vector formado por el
 ngulo y {longitud} (distancia) indicados.

Se recuerda que el  ngulo se especifica en mil‚simas de grado y como
distancia se puede especificar cualquier expresi¢n num‚rica v lida.

La funci¢n utilizada para calcular la distancia horizontal, en lugar de la
vertical, es {#119,get_distx()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_disty;

GLOBAL
    distancia;
    distancia_horizontal;
    distancia_vertical;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 3);
    write(0, 160, 200, 7, "Utilice los cursores para mover el tri ngulo.");
    write(0, 0, 0, 0, "Distancia vertical:");
    write_int(0, 0, 10, 0, offset distancia_vertical);
    graph=101;
    LOOP
        IF (key(_up)) distancia+=2; END
        IF (key(_down)) distancia-=2; END
        IF (key(_right)) angle-=2000; END
        IF (key(_left)) angle+=2000; END

        // Calculamos la distancia vertical
        distancia_vertical = get_disty(angle, distancia);

        distancia_horizontal = get_distx(angle, distancia);
        x=160+distancia_horizontal;
        y=100+distancia_vertical;
        FRAME;
    END
END
{-}

En el ejemplo se pone como fondo de la pantalla una gr fica circular,
sobre la que se manejar  con los cursores un tri ngulo, modificando
su distancia y  ngulo al centro de la gr fica.

El programa calcula la distancia horizontal y vertical para emplazar el
tri ngulo a partir de las coordenadas del centro de pantalla
(160, 100), mostr ndose en todo momento la distancia vertical en la esquina
superior izquierda.

{/}

Si se quiere avanzar las coordenadas del proceso una {distancia} en un
 ngulo determinado, se pueden utilizar las siguientes sentencias:

  {x+=get_distx(}< ngulo>{,} <distancia>{);}ú
  {y+=get_disty(}< ngulo>{,} <distancia>{);}ú

Esto ser¡a equivalente a la siguiente sentencia (utilizando la funci¢n {#183,xadvance()}).

  {xadvance(}< ngulo>{,} <distancia>{);}

Si el  ngulo en el que se quiere mover el proceso es el que tiene en su
variable local {#1129,angle}, entonces esta misma operaci¢n se podr¡a
realizar con la funci¢n {#101,advance()} de la siguiente forma:

  {advance(}<distancia>{);}

{/}

La funci¢n {get_disty()} equivale a calcular el {seno} del  ngulo y multiplicarlo
por la {distancia}, cambiando este resultado de signo, debido a que el
eje {Y} de pantalla avanza hacia abajo (de manera contraria a la funci¢n seno).

{/}Ver: {#1044,Uso de  ngulos en el lenguaje} - {#118,get_distx()} - {#183,xadvance()} - {#101,advance()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.120,get_id()}

{get_id(}<tipo de proceso>{)}

{Retorna:}

El {#1039,c¢digo identificador} de un proceso o {0}.

{Descripci¢n:}

Comprueba si hay procesos del tipo especificado activos. En caso afirmativo,
esta funci¢n devolver  el {#1039,c¢digo identificador} de uno de ellos y,
en el caso contrario, devolver  un 0.

Si existen varios procesos del tipo que se ha
especificado, la funci¢n {get_id()} devolver  el resto de los
identificadores en las sucesivas llamadas que se realicen a la misma.

Una vez se hayan devuelto todos los {#1039,c¢digos identificadores}, la funci¢n
devolver  0, hasta que se vuelva a ejecutar una sentencia {#1029,FRAME}, momento
a partir del cual esta funci¢n devolver , de nuevo, todos los c¢digos
identificadores de los procesos del tipo indicado.

Para obtener de esta forma todos los {#1039,c¢digos identificadores} de los
procesos no se debe utilizar la sentencia {#1029,FRAME}
entre dos llamadas consecutivas a la sentencia {get_id()}. En el caso de
ejecutar una sentencia {#1029,FRAME}, esta funci¢n volver  a
retornar todos los {#1039,c¢digos identificadores} de procesos desde el primero.

Algo similar sucede si se ejecuta una llamada a la funci¢n especificando un
tipo de proceso diferente; si tras esto se vuelven a pedir identificadores
del tipo de proceso anterior, esta funci¢n tambi‚n los volver  a retornar todos
desde el primero.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_id;

PRIVATE
    identificador_proceso;
    contador;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    FROM contador=1 TO 20;
        proceso_m¢vil(rand(0, 319), rand(0, 199), 101);
    END
    LOOP
        FROM contador=1 TO 20;

            // Cogemos los identificadores de los procesos
            identificador_proceso = get_id(TYPE proceso_m¢vil);

            identificador_proceso.angle+=rand(-5000, 5000);
        END
        FRAME;
    END
END

PROCESS proceso_m¢vil(x, y, graph);
BEGIN
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo, despu‚s de cargar el fichero de gr ficos y poner la pantalla
de fondo, se crean 20 procesos tipo {proceso_m¢vil} con sus posiciones
elegidas aleatoriamente y un tri ngulo como su gr fico.

Estos procesos £nicamente ejecutar n sentencias {#1029,FRAME} dentro de
un bucle, para visualizarse.

Desde el programa principal se van cogiendo los identificadores de los procesos
tipo {proceso_m¢vil} con la funci¢n {get_id()} (guard ndolos en la variable
{identificador_proceso}) y utiliz ndolos para modificarles el  ngulo (su
variable local {#1129,angle}).

Al disponer del {#1039,c¢digo identificador} de un proceso se pueden
consultar o modificar sus variables locales (como {#1129,angle} en este ejemplo)
o bien enviar se¤ales al proceso con la funci¢n {#158,signal()}.

{/}

La funci¢n {#104,collision()} sirve para obtener los {#1039,c¢digos identificadores}
de procesos de un tipo determinado que, adem s, colisionen (choquen) con el
proceso actual.

{/}Ver: {#1038,Formas de obtener el c¢digo identificador} - {#1042,Tipos de procesos} - {#1039,C¢digos identificadores}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.121,get_joy_button()}

{get_joy_button(}<n£mero de bot¢n>{)}

{Retorna:}

{Cierto} (1) si el bot¢n est  pulsado, {Falso} (0) si no lo est .

{Descripci¢n:}

Esta funci¢n requiere como par metro el n£mero de bot¢n del joystick
(de 0 a 3), y devuelve {cierto} (un valor num‚rico impar) si est  pulsado en
ese momento.

Si el bot¢n no est  pulsado, la funci¢n devuelve {falso}
(un valor num‚rico par).

Algunos joystick £nicamente tienen 2 botones; en este caso ser n los botones
n£mero 0 y 1. En ordenadores con dos joystick conectados, el segundo joystick
tendr  los botones n£mero 2 y 3.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_joy_button;

PRIVATE
    contador;
    botones[3];

BEGIN
    write(0, 160, 200, 7," Pulse los botones del joystick.");
    write(0, 0, 0, 0, "Botones (0..3):");
    write_int(0, 100, 0, 0, offset botones[0]);
    write_int(0, 120, 0, 0, offset botones[1]);
    write_int(0, 140, 0, 0, offset botones[2]);
    write_int(0, 160, 0, 0, offset botones[3]);
    LOOP
        FROM contador=0 TO 3;

            // Cogemos el valor del bot¢n del joystick
            botones[contador] = get_joy_button(contador);

        END
        FRAME;
    END
END
{-}

Se imprime un mensaje explicativo en la parte inferior y el estado
de los cuatro posibles botones en la parte superior; despu‚s, el programa
se queda dentro de un bucle actualizando continuamente el estado de los
cuatro botones con la funci¢n {get_joy_button()}.

{/}

Hay otras formas de utilizar el joystick. La m s sencilla es utilizar
la estructura {#1103,joy}, ya que en ‚sta hay cuatro registros que
indican continuamente el estado de los botones del joystick.

{/}Ver: {#122,get_joy_position()} - {#1103,Estructura joy}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.122,get_joy_position()}

{get_joy_position(}<n£mero de eje>{)}

{Retorna:}

La posici¢n del eje del joystick.

{Descripci¢n:}

Esta funci¢n devuelve la coordenada en la que se encuentra el eje indicado
(con un n£mero del {0} al {3}) del joystick anal¢gico.

Eje {0} - Eje {X} principal.ú
Eje {1} - Eje {Y} principal.ú
Eje {2} - Eje {X} secundario.ú
Eje {3} - Eje {Y} secundario.ú

La coordenada del joystick puede variar en funci¢n del tipo de joystick y del
ordenador en el que se ejecute, a£n as¡ es un n£mero que suele variar entre
{4} y {200}, aproximadamente.

Los ejes {principal} y {secundario} pueden estar integrados en un s¢lo joystick,
en algunos casos (mandos de vuelo con un {hat}, {pedales}, etc.). En ordenadores
que tengan dos joystick conectados, el eje principal ser  el joystick 1 y el
secundario el 2.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_joy_position;

PRIVATE
    eje_joystick[3];
    contador;

BEGIN
    write (0, 160, 200, 7, "Mueva el joystick");
    write (0, 0, 0, 0, "Coordenada X principal.");
    write_int(0, 0, 10, 0, offset eje_joystick[0]);
    write (0, 0, 40, 0, "Coordenada Y principal.");
    write_int(0, 0, 50, 0, offset eje_joystick[1]);
    write (0, 0, 80, 0, "Coordenada X secundaria.");
    write_int(0, 0, 90, 0, offset eje_joystick[2]);
    write (0, 0, 120, 0, "Coordenada Y secundaria.");
    write_int(0, 0, 130, 0, offset eje_joystick[3]);
    LOOP
        FROM contador=0 TO 3;

            // Cogemos el valor de los ejes del joystick
            eje_joystick[contador] = get_joy_position(contador);

        END
        FRAME;
    END
END
{-}

Primero se imprimen los mensajes y, despu‚s, el programa
se queda dentro de un bucle actualizando de forma continua el estado de los
cuatro ejes con la funci¢n {get_joy_button()} (que, en este caso, se
guardan en la tabla privada {eje_joystick}).

{/}

Hay otras formas de utilizar el joystick. La m s sencilla es utilizar
la estructura {#1103,joy} cuando no se requiera una lectura anal¢gica
del joystick (sus coordenadas), es decir, cuando baste con saber si el
joystick est  en el centro, a la derecha, abajo, etc.

{/}Ver: {#121,get_joy_button()} - {#1103,Estructura joy}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.123,get_pixel()}

{get_pixel(}<x>{,} <y>{)}

{Retorna:}

El color del punto (0..255).

{Descripci¢n:}

Devuelve el color que tiene el punto del {fondo de la pantalla}
que est  en las coordenadas indicadas como par metros.

El n£mero devuelto es el orden dentro de la paleta de colores activa en el
programa, entre 0 y 255, ya que las paletas tienen 256 colores.

El punto se toma £nicamente del dibujo de fondo de la pantalla, sin tener en
cuenta los gr ficos de los procesos, textos, regiones de scroll, etc., es
decir, s¢lo se leer n los colores puestos por las funciones {#146,put()},
{#173,xput()}, {#147,put_pixel()} y {#148,put_screen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_pixel;

PRIVATE
    color_punto;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 2);
    mouse.graph=200;
    write (0, 0, 190, 0, "Color del punto del fondo de pantalla:");
    write_int(0, 256, 190, 0, offset color_punto);
    LOOP

        // Cogemos el color del punto del fondo de la pantalla
        color_punto = get_pixel(mouse.x, mouse.y);

        FRAME;
    END
END
{-}

En el ejemplo, se pone el fondo de pantalla con la funci¢n {#148,put_screen},
como una serie de cuadr¡culas de distintos colores y se asigna una cruz como
puntero del rat¢n.

Despu‚s se mostrar  en la parte inferior de la pantalla el color que est 
en la posici¢n se¤alada con el rat¢n, leyendo ‚ste con la funci¢n {get_pixel()}
en cada iteraci¢n del bucle principal del programa.

{/}Ver: {#147,put_pixel()} - {#136,map_get_pixel()} - {#138,map_put_pixel()} - {#124,get_point()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.124,get_point()}

{get_point(}<fichero>{,} <gr fico>{,} <n£mero>{,} <OFFSET x>{,} <OFFSET y>{)}

{Retorna:}

La posici¢n del punto de control (en las variables cuyo {#1085,offset} se
indica como los dos £ltimos par metros).

{Descripci¢n:}

Esta funci¢n devuelve donde se situ¢ en un {gr fico} (del {fichero} indicado)
el punto de control cuyo {n£mero} se indica como tercer par metro.

Un {#1136,punto de control} es un punto que se puede definir en el
editor de gr ficos (herramienta de dibujo), en la opci¢n habilitada para
dicha funci¢n.

La funci¢n necesita la {direcci¢n} (que se obtiene con el operador {#1085,offset})
en la memoria del ordenador {de dos variables} en las que devolver  la posici¢n
{x} e {y} del punto de control.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_point;

GLOBAL
    fichero1;
    punto=1;
    x_punto;
    y_punto;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    put_screen(0, 4);
    graph=101;
    LOOP
        IF (fget_dist(x, y, x_punto, y_punto)<6)
            IF (punto++==50) punto=1; END
        END

        // Cogemos el punto de control
        get_point(fichero1, 4,punto, offset x_punto, offset y_punto);

        angle=fget_angle(x, y, x_punto, y_punto);
        advance(6);
        FRAME;
    END
END
{-}

En el ejemplo se pone como fondo un dibujo con un circuito que
recorre la pantalla; este dibujo (el gr fico {4} del fichero) tiene definidos
50 {#1136,puntos de control} (del 1 al 50) a lo largo del recorrido del circuito.

El proceso principal aparece como un tri ngulo que va recorriendo el circuito.

Esto se consigue teniendo en la variable {punto} el n£mero del punto de control
al que se debe dirigir el tri ngulo, en un principio el punto n£mero 1.

Las coordenadas de cada punto de control, obtenidas con la funci¢n {get_point()},
se guardan en las variables {x_punto} e {y_punto} y sirven para que el proceso
se dirija hacia esa posici¢n con las funciones {#113,fget_angle()}
(para obtener en la variable {angle} el  ngulo hacia el punto) y
{#101,advance()} (para avanzar 6 puntos en esa direcci¢n).

Cuando se est  cerca del punto de control, lo que se comprueba con la
funci¢n {#114,fget_dist()}, es si se incrementa el n£mero de punto, para
dirigir el tri ngulo hacia el siguiente (cuando se haya alcanzado el punto
n£mero 50, se volver  al 1).

{/}

Esta funci¢n devuelve las coordenadas exactas en las que fue colocado
ese punto de control dentro del gr fico, sin importar c¢mo est‚ dicho
gr fico ahora (escalado, rotado, etc.). Para poder obtener la posici¢n
de un punto de control en un gr fico escalado, rotado, etc. y relativa
a las coordenadas de pantalla (y no del gr fico original) se debe
emplear la funci¢n {#125,get_real_point()}.

Es decir, esta £ltima funci¢n devuelve d¢nde est  en un momento determinado
un punto de control, y {get_point()} devuelve d¢nde fue emplazado originalmente.

{/}Ver: {#1136,Puntos de control} - {#125,get_real_point()} - {#123,get_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.125,get_real_point()}

{get_real_point(}<n£mero>{,} <OFFSET x>{,} <OFFSET y>{)}

{Retorna:}

Las coordenadas actuales del punto de control (en las variables cuyo
{#1085,offset} se indica como los dos £ltimos par metros).

{Descripci¢n:}

Esta funci¢n devuelve donde est  en ese instante un punto de control
del gr fico del proceso actual en el sistema de coordenadas utilizado por
el propio proceso (ver variable local {#1122,ctype}), evaluando la ubicaci¢n
original del punto, las coordenadas actuales del proceso, su tama¤o,  ngulo,
etc.

Un {#1136,punto de control} es un punto que se puede definir en el
editor de gr ficos (herramienta de dibujo), en la opci¢n habilitada
para dicha funci¢n.

La funci¢n necesita la {direcci¢n} (que se obtiene con el operador {#1085,offset})
en la memoria del ordenador {de dos variables} en las que devolver  la posici¢n
{x} e {y} del punto de control.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_real_point;

PRIVATE
    punto;
    x_punto;
    y_punto;

BEGIN
    load_fpg("help\help.fpg");
    graph=4;
    x=160;
    y=100;
    LOOP
        FROM punto=1 TO 50;

            // Cogemos las coordenadas de donde est  ahora el punto de control
            get_real_point(punto, offset x_punto, offset y_punto);

            proceso_marcador(x_punto, y_punto, 200);
        END
        angle+=1000;
        FRAME;
    END
END

PROCESS proceso_marcador(x, y, graph);
BEGIN
    FRAME;
END
{-}

En el ejemplo se define c¢mo gr fico del proceso principal un circuito que
recorre la pantalla. Este gr fico tiene definidos 50 {#1136,puntos de control}
(del 1 al 50).

El programa se queda en un bucle dentro del cual va rotando este gr fico
(sum ndole un grado con la sentencia {angle+=1000;}) y creando 50 procesos
en forma de cruz, una en cada uno de los puntos de control del gr fico.

Se puede comprobar c¢mo la posici¢n relativa de los puntos de control no
var¡a aunque el gr fico del circuito rote.

{/}

Esta funci¢n se suele utilizar para tener localizados algunos puntos
importantes de un gr fico. Por ejemplo, si se ha definido un proceso cuyo
gr fico es un hombre con una pistola que pueda escalarse, rotarse o realizar
diversas animaciones, podr¡a definirse un punto de control en la punta
del ca¤¢n de la pistola para saber en cada momento de d¢nde deben salir
las balas en caso de que dispare.

Si el gr fico original estaba dentro de una regi¢n de scroll (ver
{#163,start_scroll()}) las coordenadas devueltas tambi‚n ser n relativas
a dicha regi¢n de scroll.

{/}

La funci¢n {#124,get_point()} devuelve d¢nde fue emplazado originalmente
un punto de control en el gr fico, en lugar de su posici¢n actual,
como {get_real_point()}.

{/}Ver: {#1136,Puntos de control} - {#124,get_point()} - {#123,get_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.126,graphic_info()}

{graphic_info(}<fichero>{,} <gr fico>{,} <informaci¢n>{)}

{Retorna:}

La informaci¢n solicitada sobre el gr fico.

{Descripci¢n:}

Devuelve la informaci¢n que se le solicita de un {gr fico} de un {fichero}.

Informaci¢n:

{g_wide} - La funci¢n devolver  el {ancho original} de dicho gr fico si se pone
g_wide como tercer par metro.

{g_height} - La funci¢n devolver  el {alto original} del gr fico.

{g_x_center} - La funci¢n devolver  la {coordenada x} del centro del gr fico.

{g_y_center} - La funci¢n devolver  la {coordenada y} del centro del gr fico.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_graphic_info;

PRIVATE
    fichero1;
    alto;
    ancho;
    x_centro;
    y_centro;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    put_screen(fichero1, 1);
    graph=100;
    x=160;
    y=100;

    // Cogemos la informaci¢n sobre el alto del gr fico
    alto = graphic_info(fichero1, 100, g_height);

    // Cogemos la informaci¢n sobre el ancho del gr fico
    ancho = graphic_info(fichero1, 100, g_wide);

    // Cogemos la informaci¢n sobre la coordenada x del centro del gr fico
    x_centro = graphic_info(fichero1, 100, g_x_center);

    // Cogemos la informaci¢n sobre la coordenada y del centro del gr fico
    y_centro = graphic_info(fichero1, 100, g_y_center);

    write(0, 0, 0, 0, "Altura del gr fico:");
    write_int(0, 0, 10, 0, offset alto);
    write(0, 0, 20, 0, "Ancho del gr fico:");
    write_int(0, 0, 30, 0, offset ancho);
    write(0, 0, 40, 0, "Centro horizontal del gr fico:");
    write_int(0, 0, 50, 0, offset x_centro);
    write(0, 0, 60, 0, "Centro vertical del gr fico:");
    write_int(0, 0, 70, 0, offset y_centro);
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo se solicita informaci¢n sobre el gr fico n£mero 100 del
fichero {help.fpg}, que es una bola de 32 puntos por 32 puntos y con el
centro en (16, 16).

Para obtener esta informaci¢n ser  necesario llamar 4 veces a la funci¢n
{graphic_info()}, ya que cada vez devuelve un s¢lo valor, en funci¢n
del tercer par metro de llamada (<informaci¢n>).

{/}Ver: {#1163,g_wide} - {#1164,g_height} - {#1165,g_x_center} - {#1166,g_y_center}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.127,is_playing_cd()}

{is_playing_cd()}

{Retorna:}

{Cierto} (1) si est  sonando el CD, o {falso} (0) si no est  sonando.

{Descripci¢n:}

Esta funci¢n sirve para poder determinar si el CD est  tocando una canci¢n.

Devuelve {Cierto} (un n£mero impar) si el CD est  tocando una canci¢n, en
caso contrario devuelve {Falso} (un n£mero par).

Su uso m s generalizado es para poder tocar una canci¢n indefinidamente
como se muestra en el siguiente ejemplo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_is_playing_cd;
BEGIN
    play_cd(1, 0);
    LOOP

        IF (NOT is_playing_cd()) // Comprueba si ya ha finalizado la canci¢n

            play_cd(1, 0);
        END
        FRAME;
    END
END
{-}

El ejemplo anterior (para el cual se necesita tener un {Compact disc} de
m£sica en el cargador de {CD-ROM}) utiliza la funci¢n {#144,play_cd()} para
hacer sonar la primera canci¢n del disco.

Despu‚s, en un bucle, se comprueba si dicha canci¢n ha terminado de sonar para
volver a lanzarla.

{/}

El volumen de reproducci¢n de cd-audio se puede controlar con la
estructura {#1104,setup} y la funci¢n {#178,set_volume()}.

{/}Ver: {#144,play_cd()} - {#164,stop_cd()} - {#178,set_volume()} - {#1104,Estructura setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.128,key()}

{key(}<c¢digo de tecla>{)}

{Retorna:}

{Cierto} (1) si la tecla est  pulsada y {falso} (0) si no lo est .

{Descripci¢n:}

Devuelve {cierto} (un n£mero impar) si la tecla, indicada como par metro,
est  pulsada en ese momento; en caso contrario devuelve {falso} (un n£mero
par).

Normalmente el par metro de entrada ser  el nombre de la tecla con el
s¡mbolo {_} (subrayado) delante; por ejemplo, para leer la tecla [{A}] se
debe llamar a la funci¢n como {key(_a)}.

Acceda a los {#1176,c¢digos de las teclas} para ver la lista completa de
c¢digos de teclado que pueden utilizarse como par metro de la funci¢n {key()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_key;
BEGIN
    LOOP
        delete_text(all_text);

        IF (key(_space)) // Comprobamos si est  pulsada la barra espaciadora

            write(0, 0, 0, 0, "Est  pulsando la tecla [ESPACIO].");
        ELSE
            write(0, 0, 0, 0, "No est  pulsando la tecla [ESPACIO].");
        END
        FRAME;
    END
END
{-}

En el ejemplo se imprime un mensaje u otro dependiendo de que la barra
espaciadora est‚ o no pulsada.

{/}

Hay tres variables globales predefinidas que tambi‚n pueden utilizarse
para el control del teclado; ‚stas son:

{#1110,scan_code} - C¢digo de la £ltima tecla que se ha pulsado; ‚ste
es un valor num‚rico que se corresponde directamente con las constantes
de {#1176,c¢digos de teclas} utilizadas como par metros de la funci¢n {key()}.

{#1109,ascii} - C¢digo ASCII de la £ltima tecla pulsada.

{#1108,shift_status} - variable que indica un n£mero en funci¢n de las
teclas especiales o de bloqueo (shift, alt, control, ...) que est‚n pulsadas
en dicho momento.

{/}Ver: {#1176,C¢digos de teclas} - {#1110,scan_code} - {#1109,ascii} - {#1108,shift_status}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.129,let_me_alone()}

{let_me_alone()}

{Descripci¢n:}

Env¡a una se¤al {#1153,s_kill} a todos los procesos, excepto el que ejecut¢
esta funci¢n, lo que eliminar  a todos los procesos menos el actual.

Esta funci¢n se utiliza, generalmente, desde el proceso principal, cuando
ha finalizado una partida, para eliminar todos los procesos (disparos,
enemigos, etc.) que quedar n activos, y recuperar el control del programa.

Una llamada a {let_me_alone()} se podr¡a sustituir siempre por una serie
de llamadas a la funci¢n {#158,signal()} con la se¤al {#1153,s_kill}, pero para
ello se deber¡an conocer los tipos de los procesos que se quieren
eliminar, o bien, sus {#1039,c¢digos identificadores}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_let_me_alone;
BEGIN
    load_fpg("help\help.fpg");
    proceso_nulo(160, 100, 100);
    write (0, 160, 0, 1, "Pulse [ESPACIO] para eliminar el proceso");
    WHILE (NOT key (_space))
        FRAME;
    END

    let_me_alone(); // Se elimina el resto de los procesos

    LOOP
        FRAME;
    END
END

PROCESS proceso_nulo(x, y, graph)
BEGIN
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo, despu‚s de crear un proceso de tipo {proceso_nulo}, se espera
a la pulsaci¢n de la barra espaciadora para utilizar la funci¢n {let_me_alone()}
la cual elimina todos los procesos que hubiera (menos el principal, que es el que
llam¢ a la funci¢n); en este caso se eliminar  el proceso de tipo {proceso_nulo}.

{/}

Para poder comprobar los procesos que hay activos en un programa en un
determinado momento se debe acceder al trazador (o debugger) pulsando
la tecla [{F12}].

{/}

La funci¢n {#109,exit()} sirve para terminar un programa de forma inmediata,
retornando al sistema.

{/}Ver: {#109,exit()} - {#158,signal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.130,load()}

{load(}<nombre de archivo>{,} <OFFSET dato>{)}

{Descripci¢n:}

Carga un bloque de datos de un archivo en el disco a la memoria del programa.

Para ello la funci¢n requiere el {nombre del archivo} y el desplazamiento
dentro de la memoria del ordenador de la variable, tabla o estructura
guardada en el disco (el desplazamiento del dato se puede obtener con
operador {#1085,OFFSET}).

Se debe especificar el desplazamiento del mismo dato que se especific¢ al
guardar el archivo con la funci¢n {#155,save()}.

Los nombres de archivo se pueden dar especificando una ruta de acceso, {que
debe ser la misma que la utilizada con la funci¢n} {#155,save()} para guardar
el archivo. No obstante {no es necesario} especificar una ruta.

Es importante que el archivo que se pretende cargar se haya creado
anteriormente, pues se producir  un error si se intenta cargar un archivo
que no existe (si bien ‚ste puede ser ignorado y continuar la ejecuci¢n del
programa).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load;

PRIVATE
    tabla[9];
    contador;

BEGIN
    write (0, 0, 0, 0, "Pulse [ENTER] para borrar los datos.");
    write (0, 0, 10, 0, "Pulse [ESPACIO] para cargar los datos del disco");
    write (0, 0, 30, 0, "Valores actuales de los datos:");
    FROM contador=0 TO 9;
        tabla[contador]=rand(0, 100);
        write_int(0, 0, 40+(contador*10), 0, offset tabla[contador]);
    END
    save("help\help.dat", offset tabla, sizeof(tabla));
    LOOP
        IF (key(_enter))
            FROM contador=0 TO 9;
                tabla[contador]=0;
            END
        END
        IF (key(_space))

            load("help\help.dat", offset tabla); // Se cargan los datos del disco

        END
        FRAME;
    END
END
{-}

Al inicio del ejemplo se crea una tabla de 10 posiciones (del 0 al 9)
con valores aleatorios. Esta tabla se graba en el disco con la funci¢n
{#155,save()}.

Cuando se pulsa la tecla ENTER se borran los valores de la tabla (se ponen
a 0 las 10 posiciones).

Cuando se pulsa la barra espaciadora se cargan los valores de la tabla
del disco con la funci¢n {load()}.

{/}Ver: {#155,save()} - {#1094,sizeof()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.131,load_fnt()}

{load_fnt(}<nombre de archivo>{)}

{Retorna:}

El {c¢digo de la fuente} cargada.

{Descripci¢n:}

Carga un archivo con una nueva fuente de car cteres (*.FNT) del disco
(un "font" con un nuevo juego de car cteres gr ficos).

La funci¢n devuelve el {c¢digo de fuente} que puede ser utilizado por
las funciones {#171,write()} y {#172,write_int()} para escribir un texto.

Se puede especificar la ruta de acceso al archivo con la fuente, no obstante,
si el archivo con la fuente de letra se ha generado en el directorio por
defecto (\FNT) no ser  necesario.

El archivo con la nueva fuente se tiene que haber creado con la paleta de
color del juego para que se visualice correctamente; en caso contrario
aparecer n los colores cambiados.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_fnt;

PRIVATE
    fuente1;

BEGIN

    fuente1=load_fnt("help\help.fnt"); // Se carga la fuente para el texto

    write(0, 160, 0, 1, "Texto escrito con la fuente del sistema.");
    write(fuente1, 160, 10, 1, "FUENTE DEL ARCHIVO EN DISCO");
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo se carga una fuente con la funci¢n {load_fnt()}, y despu‚s se
escriben dos textos con fuentes diferentes. El primero con la fuente del
sistema y el segundo, con la fuente cargada del archivo {help.fnt}.

{/}

Para descargar de la memoria del ordenador la fuente cargada (liberando
el espacio ocupado en memoria por ‚sta) se debe utilizar la funci¢n
{#177,unload_fnt()}, pasando como par metro el {c¢digo de fuente}.

{No es necesario} descargar la fuente con esta £ltima funci¢n a no ser
que se necesite el espacio ocupado para cargar m s gr ficos o fuentes, ya
que el sistema liberar  la fuente autom ticamente al finalizar el programa.

{/}Ver: {#177,unload_fnt()} - {#171,write()} - {#171,write_int()} - {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.132,load_fpg()}

{load_fpg(}<nombre de archivo>{)}

{Retorna:}

Retorna el {c¢digo del fichero} cargado.

{Descripci¢n:}

Carga un archivo con un fichero (*.FPG) del disco. Se entiende por un
fichero, una librer¡a (o colecci¢n) de gr ficos.

Un archivo FPG con una librer¡a de gr ficos puede contener desde ning£n
gr fico hasta 999 gr ficos. Cada uno ellos incluidos en la librer¡a
tendr  un c¢digo num‚rico, el {c¢digo de gr fico}, que es un n£mero entre
{1} y {999} que se utiliza para identificar el gr fico dentro del fichero.

Es posible cargar tantos ficheros de gr ficos como sea necesario, siempre que
quede memoria disponible (para cargar varios ficheros se debe llamar varias
veces a esta funci¢n).

La funci¢n devuelve el {c¢digo de fichero}, que puede ser utilizado por
m£ltiples funciones que requieren un gr fico, para lo cual se les debe
indicar el {c¢digo de fichero} en el que est  el gr fico y el {c¢digo de
gr fico} dentro del fichero.

Se puede especificar la ruta de acceso al archivo con el fichero de gr ficos,
no obstante, si el fichero est  en el directorio por defecto (\FPG) no ser 
necesario.

{/}

Cuando se han cargado diferentes ficheros se debe tener en cuenta que si
estos tienen paletas diferentes, se debe activar cada una de ellas previamente
con la funci¢n {#133,load_pal()}, indicando el nombre del fichero (FPG) como
par metro, antes de utilizar los gr ficos del mismo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_fpg;

PRIVATE
    fichero1;

BEGIN

    fichero1 = load_fpg("help\help.fpg"); // Se  carga el fichero de gr ficos

    put_screen(fichero1, 1); // Utilizamos el gr fico 1 del fichero
    write(0, 160, 0, 1, "Fichero de gr ficos cargado con ‚xito");
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo, se carga el fichero de gr ficos que se va usar en el programa
con la funci¢n {load_fpg()} y, despu‚s, se utiliza el gr fico n£mero 1 del
mismo para ponerlo como fondo en la pantalla (con la funci¢n {#148,put_screen()}).

{/}

La funci¢n {#169,unload_fpg()} permite liberar la memoria del ordenador utilizada
por el fichero de gr ficos cuando ya no se va a utilizar m s, y para ello
requiere tambi‚n el {codigo de fichero} para saber qu‚ fichero es el que se
quiere descargar de memoria.

{No es necesario descargar el fichero de memoria} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

{/}Ver: {#169,unload_fpg()} - {#174,load_map/pcx()} - {#133,load_pal()} - {#1131,file}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.133,load_pal()}

{load_pal(}<nombre de archivo>{)}

{Descripci¢n:}

Carga una paleta de color de disco (de un archivo PAL, FPG, MAP, PCX o FNT) con
la definici¢n de los {256 colores} que se visualizan en pantalla.

A partir de ese momento el juego se ver  con la correspondencia de colores
que indica dicha paleta.

Si en el momento de cargar la paleta el programa ten¡a asignada ya otra
diferente, entonces se realizar  un fundido de los colores de la pantalla
a negro para despu‚s ir introduciendo, en los siguientes fotogramas del
juego, la nueva paleta de color de forma gradual.

Se puede especificar la ruta de acceso al archivo con la paleta;
no obstante, si el fichero est  en el directorio por defecto (que dependiendo del
tipo de archivo ‚ste ser : \PAL, \FPG, \MAP, \PCX o \FNT) no ser  necesario.

El programa leer  la paleta autom ticamente del primero de estos tipos
de archivos que se carguen en el programa, aunque no se utilice la funci¢n
{load_pal()}. Luego, esta funci¢n se utiliza cuando el programa usa
varias paletas diferentes para cambiar de una a otra.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_pal;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 160, 0, 1, "Pulse [ESPACIO] para cargar una paleta diferente.");
    write(0, 160, 10, 1, "Pulse [ENTER] para cargar la paleta original.");
    LOOP
        IF (key(_space))

            load_pal("help\help.pal"); // Se carga una paleta de un fichero .pal

        END
        IF (key(_enter))

            load_pal("help\help.fpg");  // Se carga una paleta de un fichero .fpg

        END
        FRAME;
    END
END
{-}

En el ejemplo, al inicio se carga un fichero de gr ficos, se pone un fondo
de pantalla y se imprimen los mensajes necesarios.

En el bucle principal del programa se carga una paleta diferente (de {help.pal})
cuando se pulsa la barra espaciadora y la paleta original (de {help.fpg})
al pulsar la tecla ENTER.

{/}

Una paleta no se puede descargar de la memoria del ordenador, ya que ‚sta
no ocupa espacio en la memoria.

{/}Ver: {#174,load_map/pcx()} - {#132,load_fpg()} - {#131,load_fnt()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.134,load_pcm() / load_wav()}

{load_pcm(}<nombre de archivo>{,} <c¡clico>{)}

{load_wav(}<nombre de archivo>{,} <c¡clico>{)}

{Retorna:}

El {c¢digo del sonido} cargado.

{Descripci¢n:}

Carga un efecto de sonido de un archivo PCM o WAV del disco. Se debe indicar el
nombre del archivo con el efecto de sonido como primer par metro y en
<c¡clico>, como segundo par metro, {1} si es un sonido que se debe tocar
repiti‚ndose indefinidamente, o {0} si debe sonar s¢lo una vez (cuando se
solicite con la funci¢n {#159,sound()}).

La funci¢n devuelve el {c¢digo del sonido} que debe ser utilizado por
la funci¢n {#159,sound()} para hacer que suene por un canal dicho sonido.

Se puede especificar la ruta de acceso al archivo con el sonido, no obstante,
si el sonido est  en el directorio por defecto (\PCM o \WAV) no ser  necesario.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_pcm;

PRIVATE
    id_sonido;

BEGIN

    id_sonido = load_pcm("help\help.pcm", 0); // Carga un sonido del disco duro

    write(0, 160, 0, 1, "Presione [ESPACIO] para ejecutar el sonido.");
    LOOP
        IF (scan_code==_space)
            sound(id_sonido, 100, 256);
        END
        FRAME;
    END
END
{-}

En el ejemplo primeramente se carga un sonido con la funci¢n {load_pcm()}.
Luego, en el bucle principal, cada vez que se pulsa la barra espaciadora se
ejecuta dicho sonido con la funci¢n {#159,sound()}.

{/}

La funciones {#170,unload_pcm()} y {#170,unload_wav()} permiten liberar la memoria del ordenador utilizada
por el sonido cuando ya no se va a utilizar m s y, para ello,
requiere tambi‚n el {codigo del sonido} para saber qu‚ sonido es el que se
quiere descargar de memoria.

{No es necesario descargar el sonido de memoria} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

{/}Ver: {#170,unload_pcm/wav()} - {#159,sound()} - {#102,change_sound()} - {#1104,Estructura setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.135,map_block_copy()}

{map_block_copy(}<fichero>{,} <gr fico destino>{,} <x destino>{,} <y destino>{,}
                 <gr fico origen>{,} <x>{,} <y>{,} <ancho>{,} <alto>{)}

{Descripci¢n:}

La funci¢n {map_block_copy()} permite transferir un bloque rectangular
de un gr fico a otro.

El gr fico del cual se toma la regi¢n rectangular se
denomina <gr fico origen> y el {gr fico destino} es en el que se copiar 
dicho bloque, es decir, esta funci¢n permite copiar un trozo de un gr fico
(origen) a otro (destino). Los par metros son, por orden, los siguientes:

{<fichero>} - Ambos gr ficos deben provenir del mismo fichero de gr ficos.
Como primer par metro se debe especificar el {c¢digo del fichero} (ver
{#132,load_fpg()}). Los gr ficos cargados con las funciones {#174,load_map()}
o {#174,load_pcx()} (o creados con {#188,new_map()})
se utilizar n como si pertenecieran al primer fichero (el fichero con el
c¢digo 0).

{<gr fico destino>} - {c¢digo del gr fico} en el que se va a poner el bloque.

{<x destino>, <y destino>} - coordenadas ({x}, {y}) en las que se quiere poner
el bloque dentro del gr fico destino.

{<gr fico origen>} - {c¢digo del gr fico} del que se va a tomar el bloque.

{<x>, <y>} - coordenadas de {inicio} del bloque dentro del gr fico origen.

{<ancho>, <alto>} - {dimensiones} del bloque que se va a transferir.

Esta funci¢n modificar  el gr fico indicado, pero s¢lo la copia del mismo
que se ha cargado en la memoria del ordenador. El gr fico original, que
est  en el archivo {FPG}, {MAP} o {PCX} del disco, {permanecer  inalterado}.
Por ello si se quiere en un momento del juego recuperar el estado original
del gr fico se tiene que descargar de memoria (con {#169,unload_fpg()},
{#176,unload_map()} o {#176,unload_pcx()}) y despu‚s volverlo a cargar.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_map_block_copy;

PRIVATE
    x_destino, y_destino;
    x_origen, y_origen;
    ancho, alto;
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 320);
        y_destino=rand(0, 200);
        ancho=rand(1, 32);
        alto=rand(1, 32);
        x_origen=rand(0, 32-ancho);
        y_origen=rand(0, 32-alto);

        map_block_copy(fichero1, 1, x_destino, y_destino, 100, x_origen, y_origen, ancho, alto);

        FRAME;
        angle+=1000;
    END
END
{-}

En el ejemplo, despu‚s de cargar el fichero de gr ficos y poner uno (
el gr fico n£mero 1) el centro de pantalla va rotando cont¡nuamente.
En el bucle principal, se va copiando el gr fico de una bola (el gr fico
n£mero 100) dentro del gr fico destino (el n£mero 1) en unas coordenadas
elegidas aleatoriamente.

{/}

Cuando se ponga un gr fico en otro que se est‚ utilizando como fondo
para una regi¢n de scroll, ‚ste no aparecer  autom ticamente en pantalla
a no ser que se utilice la funci¢n {#152,refresh_scroll()}.

{/}Ver: {#139,map_xput()} - {#137,map_put()} - {#138,map_put_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.136,map_get_pixel()}

{map_get_pixel(}<fichero>{,} <gr fico>{,} <x>{,} <y>{)}

{Retorna:}

El color del punto (0..255).

{Descripci¢n:}

Permite obtener, como valor de retorno de la funci¢n, el color de un punto
determinado de un gr fico. Para ello requiere el <c¢digo del fichero> en el
que se encuentra el gr fico, el <c¢digo del gr fico> dentro del fichero y
las coordenadas ({x}, {y}) del punto del gr fico cuyo color se quiere obtener.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_map_get_pixel;

PRIVATE
    fichero1;
    figura;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    put_screen(0, 7);
    mouse.graph=200;
    write(0, 0, 0, 0, "FIGURA:");
    write_int(0, 42, 0, 0, offset figura);
    LOOP

        // Cogemos el color del punto del mapa del bits
        figura = map_get_pixel(fichero1, 8, mouse.x, mouse.y);

        FRAME;
    END
END
{-}

En el ejemplo se pone como fondo de pantalla una imagen con 6 figuras
geom‚tricas diferentes, todas ellas del mismo color, y el gr fico del
rat¢n se define como una peque¤a cruz.

La imagen de fondo se corresponde directamente con otro gr fico, el
n£mero 8 del fichero, el cual tiene las mismas figuras aunque cada una
de un color diferente (la primera de color 1, la segunda de color 2, etc.).

En el bucle principal se tomar  un color de este segundo gr fico con la
funci¢n {map_get_pixel()}, de las coordenadas que indique el cursor del
rat¢n.

En la esquina superior izquierda de la pantalla el valor obtenido con
la funci¢n, que es un n£mero del 1 al 6 que indica el n£mero de figura.

{/}

Esta funci¢n se suele utilizar para la detecci¢n de zonas dentro de gr ficos.
Esta t‚cnica se denomina {mapas de durezas} y consiste en utilizar dos
gr ficos diferentes, uno con el dibujo en s¡ y otro con las zonas a detectar
pintadas de diferentes colores.

Por ejemplo, en un juego de naves se podr¡an pintar en este {mapa de durezas}
las zonas que le quitan energ¡a a la nave cuando pasa por ellas con un color
(por ejemplo, el color 32); despu‚s se obtendr¡a el color del {mapa de durezas}
sobre el que est  la nave, y si es 32, se le restar¡a energ¡a.

Es decir, habr¡a dos dibujos diferentes: uno en colores, que es el dibujo
de fondo por el que se mueve la nave en el juego (el visible), y otro,
el {mapa de durezas} que se utilizar¡a £nicamente para obtener colores
de ‚l con la funci¢n {map_get_pixel()} y, de esta forma, identificar la
zona del dibujo original sobre el que est  la nave.

{/}Ver: {#123,get_pixel()} - {#138,map_put_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.137,map_put()}

{map_put(}<fichero>{,} <gr fico destino>{,} <gr fico origen>{,} <x>{,} <y>{)}

{Descripci¢n:}

Pone un gr fico en otro. El gr fico que se va a copiar se denomina
<gr fico origen> y el {gr fico destino} es en el que se copiar  el origen,
es decir, esta funci¢n permite copiar un gr fico (origen) a otro (destino).

Ambos gr ficos deben estar en el mismo fichero. Los par metros son, por
orden, los siguientes:

{<fichero>} - {c¢digo del fichero} con la librer¡a de gr ficos que contiene
a ambos. Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{<gr fico destino>} - {c¢digo del gr fico} en el que se va a poner el otro.

{<gr fico origen>} - {c¢digo del gr fico} que va a ser copiado en el destino.

{<x>, <y>} - {coordenadas dentro del gr fico destino} donde se desea poner el
gr fico origen. En estas coordenadas es donde se situar  el centro (o
{#1136,punto de control} n£mero 0) del gr fico origen.

Esta funci¢n modificar  el gr fico indicado, pero s¢lo la copia del mismo
que se ha cargado en la memoria del ordenador. El gr fico original, que
est  en el archivo {FPG}, {MAP} o {PCX} del disco, {permanecer  inalterado}.
Por ello si se quiere en un momento del juego recuperar el estado original
del gr fico se tiene que descargar de memoria (con {#169,unload_fpg()},
{#176,unload_map()} o {#176,unload_pcx()}) y despu‚s volverlo a cargar.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_map_put;

PRIVATE
    x_destino;
    y_destino;
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 320);
        y_destino=rand(0, 200);

        map_put(fichero1, 1, 100, x_destino, y_destino);

        angle+=1000;
        FRAME;
    END
END
{-}

En el ejemplo se pone el gr fico n£mero 1 en el centro de la pantalla.

En cada paso del bucle principal se gira este gr fico y se
pone, con la funci¢n {map_put()}, un gr fico n£mero 100 (una bola) dentro
del gr fico 1 (el gr fico central).

{/}

La funci¢n {#139,map_xput()} es una versi¢n un poco m s compleja de la
funci¢n {map_put()}, pero con muchas m s posibilidades, pues permite, adem s,
poner gr ficos rotados, escalados, espejados y transparentes.

Para poner una parte de un gr fico en otro (en lugar de poner el gr fico
completo) se debe utilizar la funci¢n {#135,map_block_copy()}.

{/}

{Nota:} Cuando se utilice la funci¢n {map_put()} (o cualquier otra similar)
para modificar un gr fico que se est  utilizando como fondo de una ventana
de {scroll}, puede que el gr fico puesto no aparezca de forma inmediata en
pantalla; para solventar este problema se debe utilizar la funci¢n
{#152,refresh_scroll()}.

{/}Ver: {#139,map_xput()} - {#138,map_put_pixel()} - {#152,refresh_scroll()} - {#135,map_block_copy()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.138,map_put_pixel()}

{map_put_pixel(}<fichero>{,} <gr fico>{,} <x>{,} <y>{,} <color>{)}

{Descripci¢n:}

Permite modificar el color de un punto determinado de un gr fico.
Para ello requiere el <c¢digo del fichero> en el
que se encuentra el gr fico, el <c¢digo del gr fico> dentro del fichero y
las coordenadas ({x}, {y}) del punto cuyo <color> se quiere establecer.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

Esta funci¢n modificar  el gr fico indicado, pero s¢lo la copia del mismo
que se ha cargado en la memoria del ordenador. El gr fico original, que
est  en el archivo {FPG}, {MAP} o {PCX} del disco, {permanecer  inalterado}.
Por ello si se quiere en un momento del juego recuperar el estado original
del gr fico se tiene que descargar de memoria (con {#169,unload_fpg()},
{#176,unload_map()} o {#176,unload_pcx()}) y despu‚s volverlo a cargar.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_map_put_pixel;
PRIVATE
    fichero1;
    coord_x;
    coord_y;
    color;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    graph=5;
    x=160;
    y=100;
    size=180;
    LOOP
        coord_x=rand(0, 199);
        coord_y=rand(0, 199);
        color=rand(0, 15);

        // Se ponen puntos en el gr fico n£mero 5 del fichero1
        map_put_pixel(fichero1, 5, coord_x, coord_y, color);

        angle+=2000;
        FRAME;
    END
END
{-}

En el ejemplo, se pone el gr fico n£mero 5 en el centro de la pantalla
rotando cont¡nuamente; este gr fico es un fondo completamente negro,
por ello inicialmente no se ver  nada en pantalla.

Pero despu‚s, en cada paso del bucle se ponen en ‚l puntos de un color
elegido al azar entre el 0 y el 15 (grises) en unas coordenadas
tambi‚n elegidas al azar.

Estos puntos se ponen usando la funci¢n {map_put_pixel()}.

Se puede observar c¢mo parece que hay cada vez m s puntos girando en
pantalla cuando, en realidad, lo £nico que gira es el gr fico n£mero 5.

{/}

Para poner un gr fico completo en otro, y no s¢lo en un punto, se pueden
utilizar las funciones {#137,map_put()} o {#139,map_xput()}, y para poner
s¢lo una parte de un gr fico en otro se puede utilizar la funci¢n
{#135,map_block_copy()}.

{/}

{Nota:} Cuando se utilice la funci¢n {map_put_pixel()} para poner un punto
en un gr fico que se est  utilizando como fondo de una ventana
de {scroll}, puede que el punto puesto no aparezca de forma inmediata en
pantalla; para solventar este problema se debe utilizar la funci¢n
{#152,refresh_scroll()}.

{/}Ver: {#137,map_put()} - {#139,map_xput()} - {#152,refresh_scroll()} - {#135,map_block_copy()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.139,map_xput()}

{map_xput(}<fichero>{,} <gr fico destino>{,} <gr fico origen>{,} <x>{,} <y>{,}
           <angle>{,} <size>{,} <flags>{)}

{Descripci¢n:}

Versi¢n extendida de la funci¢n {#137,map_put()}.

Pone un gr fico en otro. El gr fico que se va a copiar se denomina
<gr fico origen> y el {gr fico destino} es en el que se copiar  el origen,
es decir, esta funci¢n permite copiar un gr fico (origen) a otro (destino).

Ambos gr ficos deben estar en el mismo fichero. Los par metros son, por
orden, los siguientes:

{<fichero>} - {c¢digo del fichero} con la librer¡a de gr ficos que contiene
a ambos. Los gr ficos cargados con la funciones {#174,load_map()}
o {#174,load_pcx()} (o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{<gr fico destino>} - {c¢digo del gr fico} en el que se va a poner el otro.

{<gr fico origen>} - {c¢digo del gr fico} que va a ser copiado en el destino.

{<x>, <y>} - coordenadas dentro del gr fico destino donde se desea poner el
gr fico origen. En estas coordenadas es donde se copiar  el gr fico origen
a partir de su esquina superior izquierda.

{<angle>} -  ngulo (en mil‚simas de grados) en el que se copiar  el gr fico origen,
el  ngulo normal es {0}.

{<size>} - tama¤o (en porcentaje) en el que se copiar  el gr fico original, el
tama¤o normal es {100}.

{<flags>} - Indica los espejados y transparencias con los que se copiar  el gr fico
original en el destino; los valores son:

 {0}-Gr fico normal.ú
 {1}-Espejado horizontal.ú
 {2}-Espejado vertical.ú
 {3}-Espejado horizontal y vertical (180ø).ú
 {4}-Gr fico transparente.ú
 {5}-Transparente y espejado horizontal.ú
 {6}-Transparente y espejado vertical.ú
 {7}-Transparente, espejado horizontal y vertical.ú

Esta funci¢n modificar  el gr fico indicado, pero s¢lo la copia del mismo
que se ha cargado en la memoria del ordenador. El gr fico original, que
est  en el archivo {FPG}, {MAP} o {PCX} del disco, {permanecer  inalterado}.
Por ello, si se quiere en un momento del juego recuperar el estado original
del gr fico se tiene que descargar de memoria (con {#169,unload_fpg()},
{#176,unload_map()} o {#176,unload_pcx()}) y despu‚s volverlo a cargar.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_map_xput;
PRIVATE
    x_destino;
    y_destino;
    fichero1;
     ngulo1;
    tama¤o1;
    banderas1;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 319);
        y_destino=rand(0, 199);
         ngulo1=rand(-pi, pi);
        tama¤o1=rand(10, 200);
        banderas1=rand(0, 7);

        map_xput(fichero1, 1, 101, x_destino, y_destino,  ngulo1, tama¤o1, banderas1);

        angle+=2000;
        FRAME;
    END
END
{-}

En el ejemplo, se pone el gr fico 1 en el centro de la pantalla rotando
cont¡nuamente (este gr fico es un fondo decorativo en grises).

En cada paso del bucle se pondr  dentro de ‚l otro gr fico con forma
de tri ngulo (con el n£mero 100). Este gr fico se pondr  con coordenadas,
 ngulo, tama¤o y banderas (ver variable {#1127,flags}) elegidas
de forma aleatoria.

Se puede observar c¢mo en el gr fico de fondo van apareciendo cont¡nuamente
tri ngulos de color marr¢n con diferentes efectos aplicados.

{/}

La funci¢n {map_xput()} es una versi¢n un poco m s compleja de la
funci¢n {#137,map_put()}, siendo ‚sta m s f cil de utilizar cuando no se
requiera poner gr ficos rotados, escalados, espejados y transparentes.

Para poner una parte de un gr fico en otro (en lugar de poner el gr fico
completo) se debe utilizar la funci¢n {#135,map_block_copy()}.

{/}

{Nota:} Cuando se utilice la funci¢n {map_xput()} (o cualquier otra similar)
para modificar un gr fico que se est  utilizando como fondo de una ventana
de {scroll}, puede que el gr fico puesto no aparezca de forma inmediata en
pantalla; para solventar este problema se debe utilizar la funci¢n
{#152,refresh_scroll()}.

{/}Ver: {#137,map_put()} - {#138,map_put_pixel()} - {#152,refresh_scroll()} - {#135,map_block_copy()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.140,move_scroll()}

{move_scroll(}<n£mero de scroll>{)}

{Descripci¢n:}

Fuerza a mover un scroll autom tico de forma inmediata. Esta es una funci¢n
algo avanzada y por ello puede resultar dif¡cil de comprender su prop¢sito.

La funci¢n requiere como par metro el <n£mero de scroll> de 0 a 9 que se
indic¢ en la funci¢n {#163,start_scroll()} como primer par metro cuando
se inici¢ el scroll.

Esta funci¢n se utiliza cuando una regi¢n de scroll se controla
autom ticamente, por haber definido el campo {camera} de la
{#1101,estructura scroll} correspondiente con el identificador de un
proceso.

El prop¢sito es forzar a que se actualicen los valores ({x0}, {y0}, {x1} y {y1})
de dicha estructura; si no se utiliza esta funci¢n estos valores no se
actualizar n hasta la pr¢xima imagen del juego.

Es decir, cuando un scroll se controla de forma autom tica y otro proceso
necesita conocer antes de la pr¢xima imagen el valor de las coordenadas
de dicho scroll (normalmente para colocarse ‚l en una posici¢n acorde al
movimiento del fondo) se debe hacer esto:

{1} - Se inicia el scroll con {#163,start_scroll()}.

{2} - Se crea el proceso que se utilizar  como c mara y se pone su
{#1039,c¢digo identificador} en el campo {camera} de la {#1101,estructura
scroll}.

{3} - A este proceso se le debe poner una prioridad muy alta, para que
se ejecute antes que el resto de los procesos (poniendo en su variable
local {#1121,priority} un valor entero positivo como, por ejemplo, 100).

{4} - Justo antes de la sentencia {#1029,FRAME} del bucle del proceso usado
como c mara se llamar  a la funci¢n {move_scroll()}.

De esta forma se garantizar  que este proceso se ejecute el primero y, justo
al finalizar, actualice los valores ({x0}, {y0}, {x1} y {y1}) de la
{#1101,estructura scroll}, de forma que el resto de los procesos puedan
utilizar estas variables ya actualizadas.

El uso m s generalizado de esta funci¢n es cuando en una ventana de scroll
se quieren tener m s de dos planos de fondo y, para ello, se crean una serie
de procesos que simulen un tercer o cuarto plano, situando sus coordenadas
en funci¢n de la posici¢n exacta del scroll en cada imagen. A continuaci¢n
se muestra un programa que lo hace.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_move_scroll;

PRIVATE
    fichero1;
    contador;

BEGIN
    set_fps(100, 0);
    fichero1=load_fpg("help\help.fpg");
    start_scroll(0, fichero1, 103, 102, 0, 15);
    scroll.camera=id;
    priority=100;
    FROM contador=-2000 TO 2000 step 100;
        proceso_m¢vil(contador);
    END
    write(0, 160, 0, 1, "Utilice cursor derecha e izquierda para moverse");
    graph=101;
    ctype=c_scroll;
    LOOP
        if (key(_right))
            x+=2;
            flags=0;
        END
        if (key(_left))
            x-=2;
            flags=1;
        END

        move_scroll(0); // Actualiza la estructura scroll[]

        FRAME;
    END
END

PROCESS proceso_m¢vil(x_scroll)
BEGIN
    ctype=c_scroll;
    z=100;
    graph=104;
    LOOP
        x=x_scroll-scroll.x0;
        FRAME;
    END
END
{-}

Este ejemplo inicia un scroll a pantalla completa con dos planos y despu‚s
mueve un tri ngulo hacia la derecha e izquierda con los cursores; este
proceso ser  la c mara del scroll, centr ndose la visi¢n en el mismo de
forma autom tica (al poner {scroll.camera=}{#1092,id}{;}).

Pero, adem s, crea un total de 40 procesos (de -2000 hasta 2000, cada 100 puntos)
con el dibujo de una banda vertical de colores que se mover n como si fueran
un tercer plano de scroll (procesos de tipo {proceso_m¢vil}).

Para ello, es importante que su {z} sea superior al resto de los procesos
({z=100;}) y que la prioridad del proceso que controla la c mara sea mayor
({priority=100;}) y este £ltimo utilice la funci¢n {move_scroll()} antes
de cada imagen ({FRAME;}).

Los procesos que simula el tercer plano ({proceso_m¢vil}), sit£an su
coordenada {x} en funci¢n de la {x del scroll} y su posici¢n original.

La diferencia es que si no se hubiera utilizado {move_scroll()}, al
utilizar los procesos la variable {scroll.x0} sin actualizar, se mover¡an
con un cierto retraso que restar¡a verosimilitud al juego.

{/}Ver: {#163,start_scroll()} - {#1101,Estructura scroll} - {#1121,priority} - {#1125,z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.141,move_text()}

{move_text(}<identificador del texto>{,} <x>{,} <y>{)}

{Descripci¢n:}

Mueve un texto a otras coordenadas de pantalla. Se especifica como par metro
el {identificador del texto} que es un c¢digo num‚rico que devuelve las
funciones {#171,write()} y {#172,write_int()} cuando se les pide que escriban
un texto, y las coordenadas ({x}, {y}) de pantalla a las que se debe mover el
texto.

El {c¢digo de centrado} especificado en el {#171,write()} o {#172,write_int()}
se mantendr  cuando se utilice esta funci¢n.

Las coordenadas especificadas son siempre relativas a la pantalla y pueden
estar dentro o fuera de la misma. Para modificar la {coordenada z de los
textos} (el plano de profundidad en el que aparecen) se debe utilizar la
variable global {#1106,text_z}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_move_text;

PRIVATE
    id_texto1;
    id_texto2;
    coord_x;
    coord_y;
     ngulo1;

BEGIN
    id_texto1=write(0, 160, 100, 4, "TEXTO EN MOVIMIENTO");
    id_texto2=write(0, 160, 100, 4, "MUEVA EL RATON");
    LOOP
        coord_x=160+get_distx( ngulo1, 100);
        coord_y=100+get_disty( ngulo1, 90);

        // Movemos los textos
        move_text(id_texto1, coord_x, coord_y);
        move_text(id_texto2, mouse.x, mouse.y);

         ngulo1+=1000;
        FRAME;
    END
END
{-}

En el ejemplo se imprimen dos texto con la funci¢n {#171,write()} en
el centro de la pantalla. Esta funci¢n nos devuelve los identificadores
de dichos textos, que se guardan en las variables {id_texto1} e {id_texto2}.

En cada paso de bucle, se mueve el primer el texto por una trayectoria
circular que se consigue incrementando un  ngulo ({ ngulo1}) y utilizando
las funciones {#118,get_distx()} y {#119,get_disty()}. El segundo texto
se situar  en las coordenadas del puntero del rat¢n.

Ambos textos se mueven en cada imagen mediante la funci¢n {move_text()}.

{/}

Para borrar un texto definitivamente tambi‚n se requiere el {identificador
del texto}, y se debe utilizar para ello la funci¢n {#107,delete_text()}.

{/}Ver: {#171,write()} - {#172,write_int()} - {#107,delete_text()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.142,near_angle()}

{near_angle(}< ngulo>{,} < ngulo final>{,} <incremento>{)}

{Retorna:}

Un nuevo  ngulo m s pr¢ximo al  ngulo final.

{Descripci¢n:}

Acerca un  ngulo a otro en el incremento dado. La funci¢n devuelve el nuevo
 ngulo.

Se utiliza cuando se quiere que un  ngulo (< ngulo>) var¡e gradualmente
hasta convertirse en otro (< ngulo final>); para ello, la funci¢n necesita
el  ngulo original, el { ngulo final} y el {incremento} angular que se
le va a ir sumando o restando al  ngulo original.

Se recuerda que todos los  ngulos se especifican en mil‚simas de grado. El
{incremento} angular no es m s que un  ngulo peque¤o, como pudiera ser un
grado ({1000}) o cinco ({5000}).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_near_angle;

PRIVATE
     ngulo2;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    mouse.graph=200;
    graph=101;
    write(0, 160, 200, 7, "Mueva el cursor del rat¢n");
    LOOP
         ngulo2=fget_angle(x, y, mouse.x, mouse.y);

        // Acerca el  ngulo actual al final en 10 grados como m ximo
        angle = near_angle(angle,  ngulo2, 10000);

        advance(6);
        FRAME;
    END
END
{-}

En el ejemplo se define el cursor del rat¢n como una peque¤a cruz que el
usuario puede mover.

El programa principal define su gr fico como un tri ngulo ({graph=101;})
que, en cada iteraci¢n del bucle, obtiene el  ngulo hacia el cursor del
rat¢n con la funci¢n {#113,fget_angle()}; despu‚s modifica su  ngulo
para que se acerque un m ximo de 10 grados (10000) hacia el  ngulo del
cursor, utilizando la funci¢n {near_angle()} y, por £ltimo, avanza 6 puntos
en esa direcci¢n utilizando la funci¢n {#101,advance()}.

Se puede observar c¢mo el tri ngulo persigue cont¡nuamente al cursor del
rat¢n sin realizar ning£n giro brusco (de m s de 10 grados).

{/}Ver: {#1044,Uso de  ngulos en el lenguaje} - {#1129,angle} - {#116,get_angle()} - {#113,fget_angle()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.143,out_region()}

{out_region(}<c¢digo identificador>{,} <n£mero de regi¢n>{)}

{Retorna:}

{Cierto} si el proceso est  fuera de la regi¢n o {Falso} en caso contrario.

{Descripci¢n:}

Esta funci¢n determina si un proceso est  fuera de una regi¢n de pantalla,
para ello la funci¢n requiere el {#1039,c¢digo identificador} del proceso
y un n£mero de regi¢n.

Las regiones de pantalla se pueden definir con la funci¢n {#106,define_region()}
y son, simplemente, zonas rectangulares de pantalla.

La regi¢n n£mero {0} no se puede definir ya que ser  siempre la pantalla completa,
por lo tanto, si se especifica un {0} como segundo par metro esta funci¢n determina
si un proceso est  fuera de la pantalla (si no se ve).

En el caso de que el gr fico del proceso est‚ fuera de la regi¢n especificada
la funci¢n devuelve {Cierto} (un n£mero impar); en cambio si el gr fico se ve,
aunque sea parcialmente, en dicha regi¢n, la funci¢n devuelve {Falso} (cualquier
n£mero par).

El proceso cuyo {#1039,c¢digo identificador} se indica debe tener definido
correctamente su gr fico (normalmente en su variable {#1026,graph}) pues,
de lo contrario, el sistema advertir  un error ya que si el proceso
no tiene un gr fico, no se pueden calcular las dimensiones del mismo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_out_region;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    y=100;
    x=160;
    graph=101;
    LOOP
        advance(8);

        IF (out_region(id, 0)) // Se comprueba si se sale de pantalla

            x=160;
            y=100;
            angle=rand(-pi, pi);
        END
        FRAME;
    END
END
{-}

En el ejemplo se pone un gr fico de fondo y el programa principal
crea un gr fico en el centro de la pantalla con un  ngulo aleatorio
y en forma de tri ngulo.

En cada paso del bucle el tri ngulo avanza y se comprueba si ha salido
de la pantalla (region 0) con la funci¢n {out_region()}. Si ha salido
de pantalla se pone otra vez en el centro con otro  ngulo elegido
nuevamente al azar.

{/}Ver: {#106,define_region()} - {#1130,region} - {#1039,Codigos identificadores}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.144,play_cd()}

{play_cd(}<n£mero de pista>{,} <modo>{)}

{Descripci¢n:}

Comienza a tocar una pista de cd-audio. Se debe indicar el n£mero de pista (de
1 al n£mero de canciones que tenga el cd) y el modo es como sigue:

{Modo:}

 {0} - Tocar la canci¢n y pararse despu‚s.ú
 {1} - Tocar esa canci¢n y despu‚s las siguientes.ú

{#9999,Programa ejemplo:}
PROGRAM ejemplo_play_cd;
BEGIN
    write(0, 160, 0, 1, "Pulse [ESPACIO] para poner el CD en marcha.");
    LOOP
        IF (scan_code==_space)

            play_cd(1, 1); // Se pone la 1¦ canci¢n y despu‚s las dem s.

        END
        FRAME;
    END
END
{-}

El ejemplo anterior (para el cual se necesita tener un {Compact disc} de
m£sica en el cargador de {CD-ROM}) se pone un mensaje informativo y en cada
iteraci¢n del bucle se comprueba si se puls¢ la barra espaciadora para poner
la primera canci¢n con la funci¢n {play_cd()}

{/}

Para conseguir que una canci¢n suene indefinidamente, se debe implementar
un bucle utilizando la funci¢n {#127,is_playing_cd()} para determinar cu ndo
ha acabado la canci¢n.

El volumen de reproducci¢n del cd-audio se puede controlar con la
estructura {#1104,setup} y la funci¢n {#178,set_volume()}.

{/}Ver: {#127,is_playing_cd()} - {#164,stop_cd()} - {#178,set_volume()} - {#1104,Estructura setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.145,pow()}

{pow(}<expresi¢n>{,} <expresi¢n>{)}

{Retorna:}

La primera expresi¢n {elevada} a la segunda.

{Descripci¢n:}

Calcula el resultado de elevar la primera expresi¢n a la segunda.

Por ejemplo, {pow(3, 2)} devolver  {9}, que es {3} elevado al cuadrado,
es decir, {3ı}, o {3*3}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_pow;
GLOBAL
    valores[15];
    n;
BEGIN
    FROM n=0 TO 15;
        valores[n]=rand(-100, 100);
        write_int(0, 0, n*10, 0, offset valores[n]);
    END
    write(0, 0, 192, 0, "Pulse [ESPACIO] para elevar estos n£meros al cuadrado");
    LOOP
        IF (scan_code==_space)
            FROM n=0 TO 15;

                valores[n] = pow(valores[n], 2); // Se eleva al cuadrado.

            END
        END
        FRAME;
    END
END
{-}

Este programa imprimir  en pantalla una lista de n£meros aleatoriamente
escogidos entre -100 y 100. Cuando se pulse la barra espaciadora se elevar n
dichos n£mero al cuadrado.

Se debe tener en cuenta que en el lenguaje {s¢lo se pueden manejar n£meros
enteros dentro del rango} ({#1177,min_int} ... {#1178,max_int}) por lo que,
cuando el resultado de la funci¢n deba exceder dicho rango, {se
mostrar n resultados incorrectos}. En este caso, el sistema no advertir  de
ning£n error, por lo que se deben extremar las precauciones.

{/}Ver: {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.146,put()}

{put(}<fichero>{,} <gr fico>{,} <x>{,} <y>{)}

{Descripci¢n:}

Pone un gr fico en el fondo de la pantalla. La funci¢n requiere el {c¢digo de
fichero} en el que est  el gr fico, el {c¢digo del gr fico} dentro del mismo
fichero y las coordenadas ({x}, {y}) en las que se desea poner el gr fico.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

Si no se especific¢ el centro del gr fico (estableciendo su {#1136,punto de control}
n£mero 0 desde la herramienta de dibujo), las coordenadas se referir n a la
posici¢n de pantalla en la que se situar  {el centro} del gr fico.

Los gr ficos impresos de esta forma en el fondo de la pantalla estar n en la
visualizaci¢n del juego {por debajo de todos los procesos, regiones de scroll,
textos, etc.}

Si se desea que un gr fico est‚ por encima de otros se debe {crear
como un nuevo proceso} y fijar su variable {#1125,z} con la prioridad de impresi¢n
del mismo.

Para borrar el fondo de la pantalla se debe utilizar la funci¢n {#103,clear_screen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_put;

PRIVATE
    fichero1;
    coord_x;
    coord_y;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    LOOP
        coord_x=rand(0, 319);
        coord_y=rand(0, 199);

        put(fichero1, 100, coord_x, coord_y); // Se pone el gr fico 100.

        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero con los gr ficos y en cada iteraci¢n
de bucle se pone el gr fico n£mero 100 (una bola) con la funci¢n {put()} en
coordenadas aleatorias (elegidas al azar con la funci¢n {#149,rand()}).

{/}

Si el gr fico que se quiere poner es simplemente una pantalla de fondo,
resulta m s sencillo utilizar la funci¢n {#148,put_screen()}, ya que ‚sta
no requiere las coordenadas de pantalla pues centrar  el gr fico en la
misma de forma autom tica.

{/}

La funci¢n {#173,xput()} es una versi¢n un poco m s compleja de la
funci¢n {put()} pero con muchas m s posibilidades, ya que permite, adem s,
poner gr ficos rotados, escalados, espejados y transparentes.

Para poner un gr fico en otro (en lugar del fondo de la pantalla)
se deben utilizar las funciones {#137,map_put()} o {#139,map_xput()}.

{/}Ver: {#148,put_screen()} - {#173,xput()} - {#137,map_put()} - {#139,map_xput()} - {#147,put_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.147,put_pixel()}

{put_pixel(}<x>{,} <y>{,} <color>{)}

{Descripci¢n:}

Establece el {color} del punto situado en las coordenadas ({x}, {y})
del fondo de la pantalla. Es decir, pone un punto del color indicado en las
coordenadas indicadas.

Los puntos impresos con esta funci¢n en el fondo de la pantalla estar n en la
visualizaci¢n del juego {por debajo de todos los procesos, regiones de scroll,
textos, etc.}

Si se desea visualizar un punto que est‚ por encima de otros gr ficos se debe
crear un nuevo proceso y asignarle como gr fico el dibujo de un punto (en su
variable {#1126,graph}) y fijar su variable {z} con la prioridad de
impresi¢n del mismo.

Para borrar el fondo de la pantalla se debe utilizar la funci¢n {#103,clear_screen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_put_pixel;

PRIVATE
    x_punto;
    y_punto;
    color;

BEGIN
    LOOP
        x_punto=rand(0, 319);
        y_punto=rand(0, 199);
        color=rand(0, 15);

        // Se ponen puntos en el fondo de la pantalla aleatoriamente
        put_pixel(x_punto, y_punto, color);

        FRAME;
    END
END
{-}

En el ejemplo, en cada paso del bucle se ponen puntos con la funci¢n
{put_pixel()} con coordenadas y color elegidos al azar con la funci¢n
{#149,rand()}.

{/}

Para leer el color que tiene un determinado punto del fondo de la pantalla
se debe utilizar la funci¢n {#123,get_pixel()}, que devolver  un n£mero entre
0 y 255 correspondiente al orden del color dentro de la paleta.

Para poner un gr fico en pantalla, en lugar de un simple punto se debe
utilizar la funci¢n {#146,put()}.

Tambi‚n es posible establecer el color de un punto en un determinado gr fico
en lugar del fondo de la pantalla, lo que se puede hacer con {#138,map_put_pixel()}.

{/}Ver: {#123,get_pixel()} - {#146,put()} - {#138,map_put_pixel()} - {#136,map_get_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.148,put_screen()}

{put_screen(}<fichero>{,} <gr fico>{)}

{Descripci¢n:}

Establece el fondo de la pantalla. La funci¢n requiere el {c¢digo de
fichero} en el que est  el gr fico, y el propio {c¢digo del gr fico}
que se desea imprimir en el fondo de la pantalla dentro del fichero.

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

La funci¢n no requiere ninguna coordenada como par metro, pues si el gr fico
es de un tama¤o (en puntos) diferente al de la pantalla simplemente se
imprimir  centrado en la misma.

Para borrar el fondo de la pantalla se debe utilizar la funci¢n {#103,clear_screen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_put_screen;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");

    put_screen(fichero1, 1); // Se pone el gr fico 1 como fondo.

    LOOP
        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero de gr ficos y se pone un gr fico
de fondo (que est  metido en el fichero con el c¢digo de gr fico n£mero 1)
con la funci¢n {put_screen()}.

{/}

Si se quiere imprimir un gr fico en una parte concreta de la pantalla o un
gr fico {que no aparezca centrado}, se puede utilizar para ello la funci¢n
{#146,put()}. La funci¢n {#173,xput()} permite, adem s, imprimir gr ficos
rotados, escalados, espejados y/o transparentes en cualquier regi¢n de
pantalla.

{/}Ver: {#146,put()} - {#173,xput()} - {#147,put_pixel()} - {#103,clear_screen()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.149,rand()}

{rand(}<valor m¡nimo>{,} <valor m ximo>{)}

{Retorna:}

Un valor num‚rico aleatorio.

{Descripci¢n:}

Devuelve un n£mero aleatorio (escogido al azar) entre el {valor m¡nimo} y
el {valor m ximo}, ambos incluidos.

Esta funci¢n se suele utilizar para establecer todos los par metros que se
quiere que var¡en en un juego de una partida a otra; por ejemplo, se pueden
inicializar las coordenadas de un enemigo con n£meros aleatorios, para que
en cada partida pueda aparecer en una posici¢n diferente.

Otra utilidad de esta funci¢n es cuando se quiere que una acci¢n no suceda
siempre, sino que tenga una cierta probabilidad de suceder; esto se suele
implementar con una sentencia del tipo:

  {IF (rand(0, 100)<25)}ú
     { // Acci¢n ...}ú
  {END}ú

En este caso la {acci¢n} se realizar¡a con un promedio del 25 por ciento de las
veces que se ejecutara la sentencia {#1020,IF}, ya que, al obtener un n£mero
al azar entre 0 y 100, ‚ste s¢lo ser¡a un n£mero menor que 25, aproximadamente
una cuarta parte de las ocasiones.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_rand;

PRIVATE
    tabla[15];
    contador;

BEGIN
    write (0, 0, 192, 0, "Pulse [ESPACIO] para hallar valores aleatorios.");
    FROM contador=0 TO 15;
        write_int(0, 0, contador*10, 0, offset tabla[contador]);
    END
    LOOP
        IF (scan_code==_space)
            FROM contador=0 TO 15;

                // Se eligen valores aleatorios entre -100 y 100
                tabla[contador] = rand(-100, 100);

            END
        END
        FRAME;
    END
END
{-}

En el ejemplo se crea una tabla con 16 datos (del 0 al 15). En cada
iteraci¢n del bucle principal se comprueba si se ha pulsado la barra
espaciadora, en cuyo caso se rellenan los 16 datos de la tabla con
valores aleatorios entre -100 y 100, elegidos con la funci¢n {rand()}.

{/}

Por defecto, en cada ejecuci¢n del programa los valores que devuelva la
funci¢n {rand()} ser n completamente diferentes. Si se quiere que la
serie de n£meros sea siempre una misma, se puede utilizar para ello la
funci¢n {#150,rand_seed()} especificando un n£mero, tras el cual la
serie de n£meros que devuelva la funci¢n {rand()} estar  siempre
predeterminada.

{/}Ver: {#150,rand_seed()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.150,rand_seed()}

{rand_seed(}<valor num‚rico>{)}

{Descripci¢n:}

Esta funci¢n establece una semilla para el generador de n£meros aleatorios
(los n£meros que genera la funci¢n {#149,rand()}).

Si se establece una semilla, que puede ser cualquier n£mero entero dentro del
rango ({#1177,min_int} ... {#1178,max_int}), todos los n£meros que genere
la funci¢n {#149,rand()} ser n los mismos en cada ejecuci¢n del programa.
Es decir, tras establecerse una semilla de origen, la funci¢n {#149,rand()} devolver 
una serie de n£meros predeterminada para dicha semilla.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_rand_seed;

PRIVATE
    tabla[15];
    contador;

BEGIN
    write (0, 0, 184, 0, "Pulse [ENTER] para introducir 1234 como semilla.");
    write (0, 0, 192, 0, "Pulse [ESPACIO] para hallar valores aleatorios.");
    FROM contador=0 TO 15;
        write_int(0, 0, contador*10, 0, offset tabla[contador]);
    END
    LOOP
        IF (scan_code==_space)
            FROM contador=0 TO 15;
                tabla[contador] = rand(-100, 100);
            END
        END
        IF (scan_code==_enter)

            rand_seed(1234); // Se introduce semilla para aleatorios.

        END
        FRAME;
    END
END
{-}

En el ejemplo se crea una tabla con 16 datos (del 0 al 15). En cada iteraci¢n
del bucle principal, cada vez que se pulse la barra espaciadora se rellenar n
los datos con valores aleatorios entre -100 y 100 (elegidos con la funci¢n
{#149,rand()}).

Y cuando se pulse la tecla ENTER, entonces se definir  la semilla de los
n£meros aleatorios con la funci¢n {rand_seed()} como 1234.

Se puede observar c¢mo cada vez que se pulsa la tecla ENTER, luego, al pulsar
la barra espaciadora, siempre se obtiene la misma serie de n£meros aleatorios
(17, 94, -38, ...). Para cada semilla posible; ‚sta serie ser  diferente.

{/}Ver: {#149,rand()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.152,refresh_scroll()}

{refresh_scroll(}<n£mero de scroll>{)}

{Descripci¢n:}

Esta funci¢n se utiliza cuando se ha modificado un gr fico con las funciones
{#137,map_put()}, {#139,map_xput()}, {#135,map_block_copy()} o {#138,map_put_pixel()} que
est  siendo utilizado como {fondo de una regi¢n de scroll}, para actualizarlo.

La funci¢n requiere como par metro el <n£mero de scroll> que se especific¢
al iniciar el scroll con la funci¢n {#163,start_scroll()}.

Cuando se modifica un gr fico que est  siendo utilizado como fondo de un
scroll no se actualiza en pantalla autom ticamente, sino que hay que llamar a esta
funci¢n para ello.

Una vez modificado el gr fico permanecer  as¡ durante el resto de la
ejecuci¢n del programa, a no ser que se descargue el gr fico de memoria
(con {#169,unload_fpg()}, {#176,unload_map()} o {#176,unload_pcx()}) y se vuelva a cargar, en
cuyo caso se recuperar  el estado original del gr fico.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_refresh_scroll;

BEGIN
    load_fpg("help\help.fpg");
    start_scroll(0, 0, 103, 102, 0, 15);
    scroll.camera=id;
    write(0, 160, 192, 7, "Pulse [ENTER] para poner un gr fico en el scroll.");
    write(0, 160, 200, 7, "Pulse [ESPACIO] para actualizar scroll.");
    LOOP
        IF (scan_code==_enter)
           map_put(0, 103, 100, rand(16, 48), rand(16, 48));
        END
        IF (scan_code==_space)

            refresh_scroll(0); // Refrescamos el scroll 0.

        END
        x+=2;
        y+=1;
        FRAME;
    END
END
{-}

En el ejemplo se crea el scroll (n£mero 0) como un scroll de dos planos:
el primero con el gr fico n£mero 103 y el plano de fondo con el gr fico n£mero 102.

Dentro del bucle principal se imprimir  una bola sobre el gr fico 103 (primer
plano del scroll) cuando se pulse la tecla ENTER. Pero ‚ste no aparecer 
en pantalla a no ser que se espere a que el scroll entre poco a poco en
pantalla (con el gr fico 103 ya modificado), o bien se pulse la barra
espaciadora, en cuyo caso la llamada a la funci¢n {refresh_scroll()}
actualizar  la ventana del scroll con el gr fico ya modificado.

Si en el ejemplo anterior se hubiera llamado a la funci¢n {refresh_scroll()}
justo a continuaci¢n de {#137,map_put()}, los gr ficos impresos sobre el
primer plano aparecer¡an instant neamente al pulsar la barra espaciadora.

En el ejemplo, cada vez que se imprime una bola aparecen muchas; esto es
debido a que el gr fico 103 utilizado como primer plano en el scroll
es un gr fico peque¤o y se muestra varias veces, en mosaico, para rellenar
toda la zona de scroll.

{/}

{Nota:} Se puede observar que si el gr fico que se imprime est  en unas
coordenadas fuera de pantalla, no ser  necesario llamar a esta funci¢n ya
que las partes del scroll que van entrando en pantalla se van refrescando
autom ticamente.

{/}Ver: {#163,start_scroll()} - {#140,move_scroll()} - {#1101,Estructura scroll}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.153,reset_fli()}

{reset_fli()}

{Descripci¢n:}

Esta funci¢n {rebobina} hasta el principio una animaci¢n {FLI/FLC} que se
inici¢ con la funci¢n {#161,start_fli()}.

Tras llamar a esta funci¢n, la animaci¢n se volver  a mostrar completa
desde el principio (para visualizar cada fotograma de la animaci¢n se debe
llamar a la funci¢n {#115,frame_fli()}).

La utilidad de esta funci¢n reside en poder parar una animaci¢n y, sin
descargarla ({#108,end_fli()}) y volverla a cargar, volver a repetirla
desde el principio.

Si una animaci¢n se quiere tocar indefinidamente, volviendo a empezar cuando
llegue al final, entonces {no es necesario utilizar esta funci¢n}, ya que
esto se har  de forma autom tica con {#115,frame_fli()}, si se sigue llamando
una vez haya terminado la animaci¢n.

S¢lo es posible tener una animaci¢n a la vez, por lo que no es necesario
especificar ning£n par metro para esta funci¢n.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_reset_fli;
BEGIN
    start_fli("help\help.fli", 0, 0);
    write(0, 160, 0, 1, "Pulse [ESPACIO] para reiniciar la animaci¢n.");
    LOOP
        frame_fli();
        IF (scan_code==_space)

            reset_fli(); // Se inicializa la animaci¢n

        END
        FRAME;
    END
END
{-}

En el ejemplo se carga una animaci¢n con la funci¢n {#161,start_fli()} y
despu‚s se toca indefinidamente con la funci¢n {#115,frame_fli()}.

En el bucle se comprueba si se ha pulsado la barra espaciadora, y si est 
pulsada se reinicializa con la funci¢n {reset_fli()}.

{/}Ver: {#161,start_fli()} - {#115,frame_fli()} - {#108,end_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.154,roll_palette()}

{roll_palette(}<color inicial>{,} <n£mero de colores>{,} <incremento>{)}

{Descripci¢n:}

Rota una gama de colores de la paleta. Esta funci¢n sirve para crear efectos
de movimiento en gr ficos est ticos, como el efecto del agua corriendo.

Para utilizar esta funci¢n se deben crear primero gr ficos que utilicen
una gama de colores consecutivos de la paleta original, en un ciclo perpetuo,
por ejemplo, los colores del {0} al {15}, pintando algo con los colores
0, 1, 2, 3, ... , 14, 15, 0, 1, 2, ...

Despu‚s, hay que tener cuidado de que dichos colores no sean utilizados por
otros gr ficos que vayan a aparecer en pantalla al mismo tiempo, si no se
quiere tambi‚n el efecto en ellos.

El {incremento} (tercer par metro) suele ser {1} para realizar la rotaci¢n
en un sentido y{ -1} para realizarla en el otro, pero se pueden utilizar otros
valores para realizar el ciclo de colores a m s velocidad.

Para realizar un ciclo de los colores del {0} al {15} se especificar¡a {0}
como <color inicial> y {16} como <n£mero de colores>.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_roll_palette;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 2);
    write(0, 160, 0, 1, "Pulse [ESPACIO] para rotar la paleta entera.");
    LOOP
        IF (scan_code==_space)

            roll_palette(0, 256, 1); // Se rotan los 256 colores.

        END
        FRAME;
    END
END
{-}

En el ejemplo se pone como fondo una pantalla multicolor y dentro del bucle
principal del programa se rotar n los 256 colores de la paleta cada vez que
se pulse la barra espaciadora.

{/}

Si se quiere determinar la paleta con la que se debe realizar el ciclo de
color, se debe cargar ‚sta de un archivo con la funci¢n {#133,load_pal()}.

{/}

Para realizar otros efectos de paleta, sin sustituir unos colores por otros
en ciclos, se debe utilizar la funci¢n {#110,fade()} que permite realizar
m£ltiples fundidos y saturaciones de color a diferentes velocidades.

Existen dos versiones simplificadas de esta £ltima funci¢n que permiten
realizar un fundido a negro ({#111,fade_off()}) y deshacerlo ({#112,fade_on()}).

{/}Ver: {#179,set_color()} - {#133,load_pal()} - {#110,fade()} - {#111,fade_off()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.155,save()}

{save(}<nombre de archivo>{,} <OFFSET dato>{,} <sizeof(dato)>{)}

{Descripci¢n:}

Graba un bloque de datos desde la memoria del programa a un archivo en el disco
para recuperarlos despu‚s, cuando se requiera, con la funci¢n {#130,load()}.

Para ello, la funci¢n requiere el {nombre del archivo}, el desplazamiento dentro
de la memoria del ordenador de la variable, tabla o estructura guardada en
el disco (el desplazamiento del dato se obtiene con {#1085,OFFSET} {<nombre del dato>})
y el n£mero de posiciones de memoria que ocupa dicho dato (lo que se puede obtener
con {#1094,sizeof}{(<nombre del dato>)}).

Es posible guardar varios datos (variables, tablas o estructuras) si estos
se han definido dentro de la misma secci¢n ({#1006,GLOBAL}, {#1007,LOCAL}
o {#1008,PRIVATE}) y de forma consecutiva; en este caso se debe indicar
como {segundo par metro} el {#1085,OFFSET} del primer dato, y como {tercer
par metro} la suma de los {#1094,sizeof()} de todos los datos.

No es necesario especificar una ruta de acceso junto al nombre de archivo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load;

PRIVATE
    tabla[9];
    contador;

BEGIN
    write (0, 0, 0, 0, "Pulse [ENTER] para borrar los datos.");
    write (0, 0, 10, 0, "Pulse [ESPACIO] para cargar los datos del disco");
    write (0, 0, 30, 0, "Valores actuales de los datos:");
    FROM contador=0 TO 9;
        tabla[contador]=rand(0, 100);
        write_int(0, 0, 40+(contador*10), 0, offset tabla[contador]);
    END

    save("help\help.dat", offset tabla, sizeof(tabla)); // Se graba el archivo.

    LOOP
        IF (key(_enter))
            FROM contador=0 TO 9;
                tabla[contador]=0;
            END
        END
        IF (key(_space))
            load("help\help.dat", offset tabla);
        END
        FRAME;
    END
END
{-}

Al inicio del ejemplo se crea una tabla de 10 posiciones (del 0 al 9)
con valores aleatorios. Esta tabla se graba en el disco con la funci¢n
{save()}.

Cuando se pulsa la tecla ENTER se borran los valores de la tabla (se ponen
a 0 las 10 posiciones).

Cuando se pulsa la barra espaciadora se cargan los valores de la tabla
del disco con la funci¢n {#130,load()}.

{/}

Para grabar en el mismo archivo {tabla[9]} y la variable {contador} se
deber¡a haber llamado a la funci¢n {save()} de la siguiente forma:

  {save("help\help.dat", offset tabla, sizeof(tabla)+sizeof(contador));}

No variando la instrucci¢n de carga ({load("help\help.dat", offset tabla);}), ya
que ‚sta no requiere el n£mero de datos.

El valor devuelto por {#1094,sizeof()} para cualquier variable (como {contador})
ser  siempre 1, y para una tabla el n£mero de posiciones de la misma, luego
la sentencia de grabaci¢n podr¡a ponerse como (teniendo en cuenta que se
van a grabar 11 datos, 10 de la tabla y 1 de la variable):

  {save("help\help.dat", offset tabla, 11);

{/}Ver: {#130,load()} - {#1085,OFFSET} - {#1094,sizeof()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.156,set_fps()}

{set_fps(}<n§ de im genes por segundo>{,} <n§ de saltos permitidos>{)}

{Descripci¢n:}

Esta funci¢n es la que regula la velocidad a la que van los juegos; define
el n£mero de im genes por segundo que se mostrar n del juego (el n£mero de
fotogramas por segundo).

Por defecto la visualizaci¢n se regular  a 18 im genes por segundo, lo cual
quiere decir que si un proceso se mueve un punto por cada imagen ({FRAME}),
‚ste se mover  en pantalla a una velocidad de 18 puntos por segundo.

Esta funci¢n puede fijar el n£mero de im genes por segundo ({FPS}, Frames
Per Second) desde {4} como m¡nimo hasta {200} como m ximo; en general no
son necesarias m s de 24 im genes por segundo para conseguir un movimiento
fluido y suave.

El segundo par metro, {n£mero m ximo de saltos permitidos}, se refiere a c¢mo
es preferible que se comporte el programa cuando se ejecute en un ordenador
que sea lo suficientemente r pido como para calcular el n£mero de im genes
por segundo que se solicita. Funciona como se muestra a continuaci¢n.

{N£mero de saltos permitidos:}

{0} - El juego ir  a menos velocidad cuando se ejecute en un ordenador demasiado
lento, es decir, se mostrar n las im genes por segundo que a ese ordenador
le de tiempo a calcular.

{1} - Si el ordenador no puede calcular todas las im genes, se le permite que
de vez en cuando omita alguna imagen para intentar mantener la velocidad
relativa del juego. El juego se ver  un poco m s brusco, pero m s r pido.

{2 o m s} - Se permite al juego que salte tantas im genes consecutivas como
se indica en este par metro con tal de mantener la velocidad relativa original
del juego. Por ejemplo, si se fija el n£mero de saltos a {4} y en el juego un
proceso se desplazaba de un punto en un punto, en un ordenador muy lento se
podr¡a llegar a desplazar de hasta 4 puntos en 4 puntos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_fps;

PRIVATE
    im genes=24;
    saltos=4;

BEGIN
    load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    write(0, 0, 0, 0, "Im genes por segundo: Arriba(+) / Abajo(-)");
    write_int(0, 0, 10, 0, offset im genes);
    write(0, 0, 20, 0, "Saltos permitidos: Derecha(+) / Izquierda(-)");
    write_int(0, 0, 30, 0, offset saltos);
    write(0, 160, 200, 7, "Utilice los CURSORES para cambiar los valores.");
    LOOP

        // Se elige el n£mero imagenes por segundo
        set_fps(im genes, saltos);

        IF (key(_up) AND im genes<200) im genes++; END
        IF (key(_down) AND im genes>4) im genes--; END
        IF (key(_right) AND saltos<20) saltos++; END
        IF (key(_left) AND saltos>0) saltos--; END
        angle+=4000;
        FRAME;
    END
END
{-}

En el ejemplo se imprimen los mensajes necesarios y el proceso
principal crea un gr fico en el centro de la pantalla rotando
indefinidamente.

En cada paso del bucle se detectan las teclas del cursor, se cambia
el n£mero de im genes por segundo ({im genes}) con {arriba/abajo} y
el m ximo n£mero de saltos permitidos ({saltos}) con {derecha/izquierda}.

Al comienzo de cada iteraci¢n del bucle se establece la velocidad seg£n
los valores de ambas variables, con la funci¢n {set_fps()}.

{/}

{Nota:} La variable global {#1426,fps} mantiene actualizado el n£mero
de im genes por segundo que se est n consiguiendo realmente en el programa.

{/}Ver: {#1029,FRAME} - {#1115,max_process_time} - {#157,set_mode()} - {#1426,fps}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.157,set_mode()}

{set_mode(}<nuevo modo de v¡deo>{)}

{Descripci¢n:}

Fija un nuevo modo de v¡deo para la ejecuci¢n del juego. Los modos de v¡deo
est ndar que se pueden especificar como par metro son:

  {m320x200}  - VGA est ndarú
  {m320x240}  - Modo Xú
  {m320x400}  - Modo Xú
  {m360x240}  - Modo Xú
  {m360x360}  - Modo Xú
  {m376x282}  - Modo Xú
  {m640x400}  - SVGA VESAú
  {m640x480}  - SVGA VESAú
  {m800x600}  - SVGA VESAú
  {m1024x768} - SVGA VESAú

{Nota:} Adem s de estos modos (que suelen ser est ndar en la mayor¡a de adaptadores),
existe una estructura global denominada {#1415,video_modes} que contiene la lista
de modos VESA detectados en el adaptador de v¡deo del sistema. Estos modos tambi‚n pueden
ser utilizados con la funci¢n {set_mode()}.

Al realizarse un cambio de modo de v¡deo en el programa se realizar 
autom ticamente un fundido a negro (de la paleta de colores del programa) y
en las siguientes visualizaciones del juego se ir  restaurando gradualmente
la paleta de colores, es decir, {set_mode()} realiza siempre un {#111,fade_off()}
justo antes de cambiar el modo de v¡deo y un {#112,fade_on()} justo despu‚s
de haberlo cambiado.

Por defecto todos los programas comienzan con el modo de 320 por 200 puntos
activado ({set_mode(m320x200)}).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_mode;

PRIVATE
    modos[]=
        m320x200, m320x240, m320x400, m360x240, m360x360,
        m376x282, m640x400, m640x480, m800x600, m1024x768;
    modovideo=0;

BEGIN
    load_fpg("help\help.fpg");
    write (0, 0, 0, 0, "Pulse [ESPACIO] para cambiar el modo de v¡deo");
    LOOP
        IF (scan_code==_space)
            modovideo=modovideo+1;
            IF (modovideo==10) modovideo=0; END

            set_mode(modos[modovideo]);

        END
        FRAME;
    END
END
{-}

En el ejemplo se pone un fondo de pantalla y un texto explicativo.

En la iteraci¢n del bucle principal, si se pulsa la barra espaciadora, se
activar  un nuevo modo de v¡deo con la funci¢n {set_mode()}.

{/}

{Importante:} Al utilizar la funci¢n {set_mode()} se eliminar n todas las ventanas de
scroll y de modo 7 que estuvieran activas en el juego y todos los procesos
que se estuvieran visualizando en ellas.

{/}Ver: {#156,set_fps()} - {#1115,max_process_time} - {#1150,m320x200 ... m1024x768} - {#1415,STRUCT video_modes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.158,signal()}

{signal(}<id>{,} <se¤al>{)}

{Descripci¢n:}

Manda una se¤al a un proceso (un objeto del juego). Esta funci¢n se utiliza
principalmente (aunque no s¢lo) para destruir (matar) a un proceso desde otro, envi ndole una
se¤al {#1153,s_kill}.

Si desconoce a qu‚ se hace referencia cuando se habla del proceso padre, hijo,
{hermano}, un proceso {hu‚rfano}, etc., entonces vea {#1041,Jerarqu¡as de procesos}.

Si desconoce los t‚rminos vivo, {muerto}, {dormido}, etc., referidos a
procesos, vea {#1040,Estados de un proceso}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE id2;
BEGIN
    id2=mi_proceso();
    // ...
    signal(id2, s_kill);
END
PROCESS mi_proceso()
BEGIN
    // ...
    LOOP
        FRAME;
    END
END
{-}

Este programa crear¡a un proceso de tipo {mi_proceso} y despu‚s lo eliminar¡a
con la sentencia {signal(id2,s_kill)} (id2 es una variable del programa principal
que contiene el {#1039,c¢digo identificador} del proceso que se va a destruir).

Cualquier proceso puede enviar una se¤al a otro, siempre que disponga de su
{#1039,c¢digo identificador}, ver:

  {#1039,C¢digos identificadores de procesos}ú
  {#1038,Formas de obtener el c¢digo identificador de un proceso}ú

No obstante, hay otros {tipos de se¤ales} que se le pueden enviar a un proceso,
y son las siguientes:

{#1153,s_kill} - Orden de {matar} al proceso, el proceso ya no aparecer  en las
siguientes im genes del juego.

{#1155,s_sleep} - Orden de {dormir} al proceso, el proceso quedar  paralizado sin
ejecutar su c¢digo y sin visualizarse en pantalla (ni poder ser detectado
por el resto de los procesos), como si se hubiera matado. Pero el proceso
seguir  existiendo en la memoria del ordenador (ver {s_wakeup}).

{#1156,s_freeze} - Orden de {congelar} al proceso, el proceso quedar  inmovilizado
sin ejecutar su c¢digo, pero seguir  visualiz ndose en pantalla y pudiendo
ser detectado (en las colisiones) por el resto de procesos. El proceso
seguir  existiendo en la memoria del ordenador a pesar de no ejecutarse
su c¢digo (ver {s_wakeup}).

{#1154,s_wakeup} - Orden de {despertar} al proceso, devuelve a su estado normal
un proceso que ha sido {dormido} o {congelado}; a partir del momento en que
reciba esta se¤al el proceso volver  a ejecutarse y visualizarse normalmente.
No se puede devolver a su estado normal un proceso que ha sido eliminado
(matado) pues ya ha dejado de existir en la memoria del ordenador.

Un proceso puede enviarse tambi‚n estas se¤ales a s¡ mismo, teniendo en cuenta
que el {#1039,c¢digo identificador} de un proceso es siempre {#1092,ID} (palabra
reservada en el lenguaje para tal fin). La sentencia ser¡a como la siguiente:

{signal(}{#1092,id}{,} <se¤al>{)}

Auto-eliminar un proceso de esta forma, envi ndose una se¤al {#1153,s_kill}, no
destruir  el proceso instant neamente, sino en la pr¢xima visualizaci¢n
({#1029,FRAME}). Para eliminar un proceso de forma inmediata se
puede utilizar la sentencia {#1028,RETURN}.

{Todas las se¤ales enviadas a procesos tendr n efecto justo antes de la pr¢xima
visualizaci¢n del juego}, es decir, en la pr¢xima imagen ({#1029,FRAME}) del juego (no
instant neamente).

Adem s de estas cuatro se¤ales existen otras cuatro que se corresponden
directamente con las anteriores y son: {#1157,s_kill_tree}, {#1158,s_sleep_tree},
{#1160,s_freeze_tree} y {#1159,s_wakeup_tree}.

Estas se¤ales se utilizan cuando se quieren enviar, no s¢lo al proceso indicado,
sino, adem s, {a todos los procesos que ‚ste haya creado}, es decir, si se env¡a
una se¤al {#1157,s_kill_tree} a un proceso, se destruir  ‚l y toda su descendencia
(hijos, nietos, ...), todos los procesos que haya creado y los que hayan creado
estos.

Una excepci¢n a estas £ltimas cuatro se¤ales es cuando existe un {proceso
hu‚rfano}, esto es, un proceso cuyo padre (el proceso que lo llam¢) ya
est  muerto. Los procesos hu‚rfanos no recibir n la se¤al cuando se
les env¡e a un proceso del cual son descendencia, pues al haber desaparecido
su padre, ‚ste no podr  transmitir la se¤al a los procesos que cre¢.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_signal;
PRIVATE
    id_text;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 0, 0, 0, "1 - crear el proceso");
    write(0, 0, 10, 0, "2 - matar el proceso");
    write(0, 0, 20, 0, "3 - dormir el proceso");
    write(0, 0, 30, 0, "4 - congelar el proceso");
    write(0, 0, 40, 0, "5 - despertar el proceso");
    id_text=write(0, 0, 190, 0, "No hay proceso");
    LOOP
        IF (key(_1) AND NOT son)
            delete_text(id_text);
            mi_proceso();
            id_text=write(0, 0, 190, 0, "Proceso vivo");
        END
        IF (key(_2) AND son)
            delete_text(id_text);
            signal(son, s_kill);
            id_text=write(0, 0, 190, 0, "No hay proceso");
        END
        IF (key(_3) AND son)
            delete_text(id_text);
            signal(son, s_sleep);
            id_text=write(0, 0, 190, 0, "Proceso dormido");
        END
        IF (key(_4) AND son)
            delete_text(id_text);
            signal(son, s_freeze);
            id_text=write(0, 0, 190, 0, "Proceso congelado");
        END
        IF (key(_5) AND son)
            delete_text(id_text);
            signal(son, s_wakeup);
            id_text=write(0, 0, 190, 0, "Proceso vivo");
        END
        FRAME;
    END
END

PROCESS mi_proceso()
BEGIN
    graph=100;
    LOOP
        x=160+get_distx(angle, 140);
        y=100+get_disty(angle, 80);
        angle+=5000;
        FRAME;
    END
END
{-}

Este programa crear  con la tecla {1} un proceso ({mi_proceso}) que va
dando vueltas a la pantalla; con las teclas {2} a {5} se le enviar n a dicho
proceso diferentes se¤ales utilizando esta funci¢n. El {#1039,c¢digo identificador}
de {mi_proceso} est  en la variable local {son} (hijo) del programa principal
por defecto.

Cuando se crea un proceso, el sistema define la variable {#1118,son} del padre con el
{#1039,c¢digo identificador} del hijo, y la variable {#1117,father} del hijo con el c¢digo
identificador del padre.

{/}

{signal(}{#1042,TYPE} <nombre de proceso>{,} <se¤al>{)}

{Descripci¢n:}

Esta segunda acepci¢n de la funci¢n {signal} es similar a la anterior,
con la excepci¢n de que, en lugar de enviarle una se¤al a un proceso a partir
de su {#1039,c¢digo identificador}, permite enviar una se¤al {a todos los procesos
de un tipo determinado} o a ellos y su descendencia si se utilizan las
se¤ales como {s_kill_tree} (ver: {#1042,Tipos de procesos}).

Por ejemplo, si en un juego existen, o pueden existir, varios procesos
de tipo {enemigo} y se quiere congelar a dichos procesos (sin congelar
a su descendencia) se utilizar  la siguiente sentencia:

  {signal(TYPE enemigo, s_freeze);}

Como se puede observar para enviar una se¤al a un proceso en concreto se
necesita su {#1039,c¢digo identificador} y para destruir a un grupo de procesos,
que estos sean todos del mismo tipo, que se trate de un proceso y su
descendencia, o bien conocer todos sus identificadores (para enviarles la
se¤al uno a uno).

Se puede enviar una se¤al a un tipo de procesos aun cuando no exista
ning£n proceso de ese tipo ejecut ndose en el juego. Pero si se env¡a una
se¤al a un proceso que ya ha muerto, con su {#1039,c¢digo identificador} (primera
acepci¢n de la sentencia {signal}), se corre el riesgo de que dicho
{#1039,c¢digo identificador} ahora sea usado por otro proceso, siendo ‚ste el que
reciba la se¤al. Esto es si, por ejemplo, se pretende matar a un proceso que ya
est  muerto, cabe la posibilidad de que se est‚ matando a otro.

{/}

{Nota:} Si se quieren eliminar todos los procesos y dejar £nicamente al proceso
actual, se puede utilizar la funci¢n {#129,let_me_alone()}. Esta funci¢n
env¡a una se¤al {s_kill} a todos los procesos, excepto al que ejecut¢ dicha
funci¢n.

{/}Ver: {#129,let_me_alone()} - {#1039,C¢digos identificadores} - {#1042,Tipos de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.159,sound()}

{sound(}<c¢digo del sonido>{,} <volumen>{,} <frecuencia>{)}

{Retorna:}

El {n£mero de canal} por el que se reproduce el sonido.

{Descripci¢n:}

Hace sonar el efecto cuyo {c¢digo de sonido} se especifica como primer par metro.
Primero, el sonido se debe haber cargado de un archivo PCM o WAV con las funciones
{#134,load_pcm()} o {#134,load_wav()}
que son las que devuelven el {c¢digo de sonido} correspondiente a dicho efecto.

Como segundo par metro se debe especificar el {volumen} al que se desea reproducir
el sonido, siendo {0} el volumen m¡nimo y {256} el volumen m ximo.

Como tercer par metro se especificar  la {frecuencia} (velocidad) a la que se
desea reproducir el sonido, siendo {256} la frecuencia est ndar que reproducir 
el sonido original; a valores menores el sonido se reproducir  m s grave, mientras qu a valores
mayores de frecuencia, m s agudo.

La funci¢n devuelve el {n£mero de canal} que puede ser utilizado por las funciones
{#167,stop_sound()} para detener el sonido y {#102,change_sound()} para modificar su volumen o
su frecuencia.

Existen un total de 16 canales de sonido, pudiendo sonar hasta 16 sonidos
simult neamente.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_sound;

PRIVATE
    volumen=128;        // Valor medio (0..256)
    frecuencia=256;     // Valor medio (0..512)
    id_sonido, canal;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 0, 0, 0, "Volumen: Arriba(+) / Abajo(-)");
    write_int(0, 0, 10, 0, offset volumen);
    write(0, 0, 20, 0, "Frecuencia: Derecha(+) / Izquierda(-)");
    write_int(0, 0, 30, 0, offset frecuencia);
    write(0, 160, 180, 1, "Pulse [ESPACIO] para emitir el el sonido.");
    write(0, 160, 190, 1, "Utilice los cursores para cambiar los valores.");

    id_sonido = load_pcm("help\help.pcm", 0);

    LOOP
        IF (scan_code==_space)

            // Hace que suene
            canal = sound(id_sonido, volumen, frecuencia);

        END
        IF (key(_up) AND volumen<256) volumen++; END
        IF (key(_down) AND volumen>0) volumen--; END
        IF (key(_right) AND frecuencia<512) frecuencia++; END
        IF (key(_left) AND frecuencia>0) frecuencia--; END
        FRAME;
    END
END
{-}

En el ejemplo se pone una pantalla de fondo y un texto explicativo,
y se carga un sonido con la funci¢n {#134,load_pcm()}; ‚sta devuelve el
{identificador del sonido}, que se guarda en la variable {id_sonido}.

En el bucle principal, a cada pulsaci¢n de la barra espaciadora, se
emitir  el sonido con la funci¢n {sound()} con los par metros definidos
en las variables {volumen} y {frecuencia}.

Con las teclas de los cursores se podr n manipular estos valores para
comprender as¡ mejor su funcionamiento.

El {n£mero de canal} devuelto por {sound()}, que se guarda en la variable
{canal}, se podr¡a haber utilizado para modificar el sonido con {#102,change_sound()}
o pararlo con {#167,stop_sound()}.

{/}Ver: {#134,load_pcm/wav()} - {#102,change_sound()} - {#167,stop_sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.160,sqrt()}

{sqrt(}<expresi¢n>{)}

{Retorna:}

La ra¡z cuadrada entera de la expresi¢n.

{Descripci¢n:}

Calcula la ra¡z cuadrada de la expresi¢n pasada como par metro, {truncada a
un n£mero entero}.

Por ejemplo, {sqrt(10)} devolver  como resultado {3} y no {3.1623} que es
el valor real (aproximado) de la ra¡z cuadrada de diez.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_sqrt;

GLOBAL
    valores[15];
    n;

BEGIN
    FROM n=0 to 15;
        valores[n]=rand(0, 100000);
        write_int(0, 0, n*10, 0, offset valores[n]);
    END
    write(0, 0, 192, 0, "Pulse [ESPACIO] para calcular su ra¡z cuadrada");
    LOOP
        IF (scan_code==_space)
            FROM n=0 TO 15;

                valores[n] = sqrt(valores[n]);

            END
        END
        FRAME;
    END
END
{-}

Este programa imprimir  en pantalla una lista de valores aleatoriamente
seleccionados; cuando se pulse la barra espaciadora le aplicar 
la funci¢n {sqrt()} a todos estos valores, calculando su ra¡z cuadrada.

{/}Ver: {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.161,start_fli()}

{start_fli(}<nombre de archivo>{,} <x>{,} <y>{)}

{Retorna:}

N£mero de im genes de la animaci¢n.

{Descripci¢n:}

Inicia una animaci¢n {FLI/FLC} contenida en el {archivo} especificado, en las
coordenadas ({x}, {y}) (se debe especificar la coordenada superior izquierda
de la ventana de visualizaci¢n).

En el <nombre de archivo> se puede especificar la ruta de acceso, no siendo
‚sta necesaria si el archivo se encuentra en el directorio de DIV Games
Studio o en un subdirectorio cuyo nombre coincida con la extensi¢n del
archivo (por ejemplo, "fli\anima.fli").

La animaci¢n debe coger por completo en pantalla, es decir, si la animaci¢n
ocupa toda la pantalla, se debe fijar primero el modo de v¡deo con la funci¢n
{#157,set_mode()} y despu‚s iniciar con {start_fli()} la animaci¢n en las
coordenadas (0, 0).

La funci¢n devuelve, a t¡tulo informativo, el n£mero de fotogramas de los
que consta la animaci¢n completa.

El sistema activar  autom ticamente las paletas de color que pudiera tener
la animaci¢n {FLI/FLC}, lo que puede presentar problemas en la representanci¢n
de otros gr ficos o fuentes del programa, si ‚stos hubieran sido dibujados con
una paleta diferente.

Si se pretenden combinar otros gr ficos con la animaci¢n en pantalla, ‚sta
debe tener una £nica paleta de color (lo que se suele denominar "{palette low FLI/FLC}")
y los gr ficos se deben haber dibujado con esa misma paleta.

Una vez iniciada la animaci¢n se ir n mostrando los fotogramas de la misma
con respectivas llamadas a {#115,frame_fli()}.

{S¢lo es posible tener una animaci¢n activa en cada momento}, por lo que despu‚s
de haberse iniciado una animaci¢n con {start_fli()} y haberse visualizado con
{#115,frame_fli()}, se debe finalizar ‚sta con la funci¢n {#108,end_fli()} antes
de iniciar otra animaci¢n diferente.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_start_fli;
BEGIN

    start_fli("help\help.fli", 0, 0); // Se inicia una animaci¢n.

    LOOP
        frame_fli();
        FRAME;
    END
END
{-}

En el ejemplo se inicia la animaci¢n contenida en el archivo {help\help.fli} con
la funci¢n {start_fli()} en las coordenadas (0, 0) y se ejecuta esta animaci¢n
indefinidamente.

{/}

La funci¢n {#115,frame_fli()} utilizada para mostrar cada fotograma devolver 
0 cuando la animaci¢n haya finalizado, por lo que para mostrar la animaci¢n
una sola vez se deber¡a haber hecho:

{#9999,Programa ejemplo:}
PROGRAM ejemplo_start_fli;

PRIVATE
    valor;

BEGIN
    start_fli("help\help.fli", 0, 0);
    REPEAT
        valor=frame_fli();
        FRAME;
    UNTIL (valor==0);
    end_fli();
END
{-}

La funci¢n {#153,reset_fli()} permite {rebobinar} la animaci¢n, para que
la funci¢n {#115,frame_fli()} contin£e ejecut ndola desde el principio.

{/}Ver: {#108,end_fli()} - {#153,reset_fli()} - {#115,frame_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.162,start_mode7()}

{start_mode7(}<n£mero de m7>{,} <fichero>{,} <gr fico>{,} <gr fico exterior>{,}
              <n£mero de regi¢n>{,} <altura del horizonte>{)}

{Descripci¢n:}

sta es una funci¢n avanzada que requiere que el usuario tenga cierta
soltura para poder utilizarla.

Crea una ventana de visualizaci¢n de un modo 7, es decir, visualiza un gr fico
{tridimensionalmente} en un plano abatido; para conseguir este efecto se llamar 
a esta funci¢n con los siguientes par metros:

{<n£mero de m7>} - Se pueden crear hasta 10 ventanas de modo 7 en pantalla,
con los n£mero del {0} al {9}; si £nicamente se quiere crear una, lo mejor
es definir la n£mero {0}. Este n£mero ser  necesario posteriormente para
modificar los par metros de la ventana, pues el sistema necesitar  saber
cu l de las {10} posibles ventanas de modo 7 se quiere alterar.

{<fichero>} - Los gr ficos que se pretendan abatir en la ventana deben estar
en un fichero cuyo {c¢digo de fichero} se debe especificar aqu¡, como
segundo par metro de la funci¢n. Los gr ficos cargados con las funciones
{#174,load_map()} o {#174,load_pcx()} (o creados con {#188,new_map()}) se utilizar n como si pertenecieran al primer fichero (el
fichero con el c¢digo 0).

{<gr fico>} - El tercer par metro debe ser el {c¢digo del gr fico} principal
que se va a abatir en la ventana y debe pertenecer al fichero anteriormente
indicado.

{<gr fico exterior>} - Aqu¡ se puede indicar un {0} si no se quiere que se
vea ning£n gr fico m s all  del gr fico abatido en la perspectiva, o bien un {c¢digo
de gr fico} del mismo fichero que se mostrar  en la perspectiva m s all 
del {gr fico principal}, hasta alcanzar el horizonte. Este gr fico debe
ser de un ancho y alto potencia de dos, no mayor de {8192} (estas potencias
de dos son: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 y 8192),
por ejemplo, podr¡a ser un gr fico de 64 puntos de ancho por 32 de alto; este
gr fico se mostrar  tambi‚n abatido.

{<n£mero de regi¢n>} - Aqu¡ se indicar  la regi¢n rectangular de pantalla
en la que se va a mostrar el modo 7. Si se indica {0} como n£mero de regi¢n,
se mostrar  en toda la pantalla. El resto de regiones se deben definir
previamente con la funci¢n {#106,define_regi¢n()} (una {regi¢n} no es m s
que una zona rectangular de la pantalla).

{<altura del horizonte>} - Como £ltimo par metro se indicar  a cu ntos puntos
desde la parte superior de la ventana se quiere situar la l¡nea del horizonte.
Si la c mara se sit£a por encima del plano abatido, entonces no se mostrar 
nada por encima de la l¡nea del horizonte (ese hueco se suele rellenar con
otra ventana de scroll o de modo 7); en cambio si la camara se sit£a por debajo
del plano, entonces no se mostrar  nada por debajo de la l¡nea del horizonte.

{/}

{Adem s de la llamada a la funci¢n se deben inicializar algunos valores de
la} {#1102,estructura global m7} {para el correcto funcionamiento de la ventana}.
sta es una estructura de 10 registros (uno para cada posible ventana de modo 7)
y cada registro tiene los siguientes campos:

  {camera}   - {#1039,C¢digo identificador} de la c maraú
  {height}   - Altura de la c maraú
  {distance} - Distancia de la c maraú
  {horizon}  - Altura del horizonteú
  {focus}    - Focal de visi¢nú
  {z}        - Plano de profundidadú
  {color}    - Color del exteriorú

{Importante:} El campo {camera} es {imprescindible} inicializarlo para que
se active la ventana de modo 7 ya que, sin este campo, la ventana no puede determinar
desde d¢nde se debe {ver} el plano abatido.

La c mara se situar  en el plano abatido a la distancia ({distance}) indicada
del proceso cuyo {#1039,c¢digo identificador} se haya puesto en {camera}, y
mirando en su mismo  ngulo (el que indique su variable local {#1129,angle}).
La altura a la que se sit£a la c mara respecto al suelo ser  la indicada en el
campo {height}.

Ver la ayuda sobre la {#1102,estructura m7} para m s informaci¢n sobre
estos campos, o para saber c¢mo acceder a ellos.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_start_mode7;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");

    start_mode7(0, fichero1, 4, 0, 0, 64);

    m7.height = 64;
    m7.distance = 32;
    m7.color = 162;
    m7.camera = id;

    write(0, 160, 0, 1, "Utilice los cursores para moverse");
    LOOP
        IF (key(_right)) angle-=8000; END
        IF (key(_left)) angle+=8000; END
        IF (key(_up)) advance(6); END
        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero de gr ficos y entonces se crea un modo 7
tridimensional con la funci¢n {start_mode7()}. A esta £ltima se le pasan
los siguientes par metros:

{0} - N£mero de ventana de modo 7 (la primera, puesto que s¢lo se crear 
una ventana de esta clase).

{fichero1} - C¢digo del fichero del que se deben tomar los gr ficos; este
es el c¢digo del archivo {help.fpg} que se carg¢ con la funci¢n {#132,load_fpg()}.

{4} - C¢digo del gr fico principal a abatir dentro del modo 7; para ver
este gr fico se debe cargar el fichero con el {Men£ de ficheros} y as¡ poder
observar cu l es el gr fico con {c¢digo 4}.

{0} - C¢digo de gr fico secundario, con un 0 se indica que no habr  gr fico
secundario (exterior) en el modo 7, luego el exterior se visualizar  del
color que indique la variable {m7[0].color}. Para observar el efecto de poner
un {gr fico exterior} se puede cambiar este par metro, por ejemplo, por un
{100} (que es el c¢digo de una bola marr¢n de 32 por 32 puntos en el fichero
{help.fpg}).

{0} - N£mero de regi¢n de la pantalla en la que se debe {colocar} el modo 7;
con 0 se indica que se debe colocar en la pantalla entera.

{64} - Altura del horizonte, con este £ltimo par metro se indica que la l¡nea
del horizonte se situar  a 64 puntos del inicio superior de la ventana.

Tras llamar a la funci¢n {start_mode7()} el programa define los siguientes
valores de la {#1102,estructura global m7}:

{m7.height=64;} - Para indicar que la c mara se debe situar a 64 puntos sobre
el suelo.

{m7.distance=32;} - Para indicar que la c mara se debe situar 32 puntos por
detr s del proceso c mara.

{m7.color=162;} - Para indicar que el exterior se debe visualizar del color
n£mero 162 de la paleta.

{m7.camera=}{#1092,id}{;} - Para indicar que el proceso c mara ser  el proceso actual.

La c mara se situar  32 puntos por detr s del proceso principal, a 64 puntos
de altura y mirando en el  ngulo que indique la variable {#1129,angle} del
mismo.

Tras estas inicializaciones el programa ejemplo se quedar  en un bucle que
simplemente controla con los cursores el  ngulo ({#1129,angle}) del proceso
principal, que ser  el  ngulo de la c mara y, cuando se pulse la tecla {cursor
arriba}, se llamar  a la funci¢n {#101,advance()} para que el proceso principal
avance 6 puntos (y por consiguiente la c mara del modo 7).

{/}{C¢mo visualizar gr ficos de procesos sobre el modo 7}{/}

Para crear un proceso cuyo gr fico se visualice en el modo 7, se debe
definir su variable local {#1122,ctype} como {#1169,c_m7} ({tipo de coordenada}
como {coordenada de modo 7}), lo que se har  con la siguiente sentencia:

  {ctype=c_m7;}

Una vez hecho esto el proceso se visualizar  en el modo 7 con su gr fico ({#1126,graph})
escalado acorde a la distancia a la que est‚. El proceso £nicamente debe
modificar sus variables {#1123,x} e {#1124,y} para moverse por el plano abatido.

{/}

{Cuando un proceso pertenezca al modo 7 (se haya asignado el valor c_m7 a su
variable local} {#1122,ctype}{):}

  - Sus variables {#1123,x} e {#1124,y} estar n referidas al punto del gr fico
principal abatido sobre el cual se situar  el gr fico del proceso.

  - Su variable {#1125,z} perder  su efecto, ya que los gr ficos aparecer n
ordenados por estricto orden de profundidad. Esta variable valdr  £nicamente
para indicar prioridades de impresi¢n en gr ficos que se sit£en, exactamente,
en la misma profundidad del plano.

  - El proceso ser  eliminado autom ticamente cuando se elimine la ventana
de modo 7 a la que pertenece el proceso, con la funci¢n {#165,stop_mode7()},
o cuando se cambie el modo de v¡deo con la funci¢n {#157,set_mode()}, ya que
al hacerlo se eliminar n tambi‚n las ventanas de modo 7.

{/}

Si hubiera varias ventanas de {modo 7} el proceso se visualizar¡a por defecto
en todas, si £nicamente se tuviera que visualizar el algunas de ellas, se deber¡a
definir su variable local {#1134,cnumber}. Por ejemplo, si hubiera 6 ventanas
de modo 7 (de la n£mero 0 a la 5) y se quisiera que un proceso se visualizara
£nicamente en las ventanas 0 y 2, se deber¡a incluir en el mismo la siguiente
sentencia:

  {cnumber=c_0+c_2;}

{/}

Para que un proceso tenga varios gr ficos (varias vistas), dependiendo
del  ngulo desde el que se le mire, se debe definir su gr fico con la
variable local {#1132,xgraph} (en lugar de la variable {#1126,graph}).
Para definir esta variable primero se debe crear una tabla (de cualquier
nombre) indicando en primer lugar el {n£mero de vistas} del gr fico y despu‚s
los {c¢digos de los gr ficos} para estas vistas, comenzando por el { ngulo
0} y en sentido contrario a las agujas del reloj. Por ejemplo:

  {GLOBAL}ú
    {vistas_coche[]=4, 100, 101, 102, 103;}ú

La tabla {vistas_coche} definir¡a 4 vistas: el gr fico 100 para  ngulos
pr¢ximos a 0 grados, el gr fico 101 para  ngulos pr¢ximos a 90 grados,
el 102 para  ngulos pr¢ximos a 180 grados, etc.

Y despu‚s en el c¢digo del proceso se deber¡a inicializar la variable
{#1132,xgraph} con la siguiente sentencia:

  {xgraph=OFFSET vistas_coche;}

Para poder observar un ejemplo de lo aqu¡ expuesto, lo mejor es examinar
alguno de los juegos ejemplo de DIV Games Studio que utilizan esta t‚cnica,
por lo que se remite al lector directamente a los comentarios de estos
programas (por ejemplo v‚ase el ejemplo {Speed for dummies}).

{/}Ver: {#165,stop_mode7()} - {#1102,Estructura m7}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.163,start_scroll()}

{start_scroll(}<n£mero de scroll>{,} <fichero>{,} <gr fico>{,} <gr fico fondo>{,}
               <n£mero de regi¢n>{,} <indicador de bloqueo>{)}

{Descripci¢n:}

Esta es una funci¢n de cierta complejidad, que requiere que el usuario tenga
cierta soltura (haya realizado alg£n programa antes) para poder utilizarla.

Crea una ventana de scroll, en la que se realizar  una panor mica sobre
un gr fico de fondo (el decorado del juego). Es decir, utilizando como fondo
del juego un gr fico m s grande que la ventana de visualizaci¢n, se podr 
mostrar una parte del mismo e ir desplaz ndolo en cualquier direcci¢n.

Para conseguir este efecto se llamar  a esta funci¢n con los siguientes
par metros:

{<n£mero de scroll>} - Se pueden crear hasta 10 ventanas de scroll en pantalla,
con los n£meros del {0} al {9}; si s¢lo se quiere crear una, lo mejor
es definir la n£mero {0}. Este n£mero ser  necesario posteriormente para
modificar los par metros de la ventana, pues el sistema necesitar  saber
cu l de las {10} posibles ventanas de scroll se quiere alterar.

{<fichero>} - Los gr ficos que se pretendan mostrar como fondo o decorado
en dicha ventana deben estar en un fichero cuyo {c¢digo de fichero} se debe
especificar aqu¡, como segundo par metro de la funci¢n. Los gr ficos cargados
con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como si pertenecieran al
primer fichero (el fichero con el c¢digo 0).

{<gr fico>} - El tercer par metro debe ser el {c¢digo del gr fico} principal
que se va a mostrar como fondo en la ventana y debe pertenecer al fichero anteriormente
indicado. Este gr fico suele ser el decorado principal del juego sobre el que
se va a desarrollar la acci¢n, un gr fico m s grande que la ventana de visualizaci¢n,
que se ir  desplazando en una o varias direcciones y sobre el que se situar n
los gr ficos del juego.

La ventana de scroll se situar  inicialmente con el {#1136,punto de control}
n£mero {0} de este gr fico en la esquina superior izquierda, cuando se haya
definido este punto en el {editor gr fico}.

{<gr fico fondo>} - Aqu¡ se indicar  un {0} si se quiere un s¢lo plano de
scroll (un s¢lo gr fico de fondo), o bien otro {c¢digo de gr fico} si se
quiere que ‚ste aparezca como segundo plano de scroll (a mayor profundidad),
detr s del plano principal. Para que se vea este plano de fondo es
imprescindible que el {gr fico principal} (primer plano) tenga partes
dibujadas con el color n£mero 0 de la paleta, pues estas zonas transparentes
ser n las que permitir n ver a trav‚s de ellas el {gr fico de fondo}.

{<n£mero de regi¢n>} - Aqu¡ se indicar  la regi¢n rectangular de pantalla
en la que se va a mostrar el scroll, si se indica {0} como n£mero de regi¢n,
se mostrar  en toda la pantalla. El resto de regiones se deben definir
previamente con la funci¢n {#106,define_region()} (una {regi¢n} no es m s
que una zona rectangular de la pantalla).

{<indicador de bloqueo>} - Aqu¡ se indicar  un valor que define si cada uno
de los dos planos de scroll es c¡clico en horizontal y vertical. Por ejemplo,
un plano es c¡clico en horizontal cuando al salirse del dibujo por la derecha
aparece el dibujo por la izquierda. Para componer este valor se deben sumar
las siguientes cantidades:

 { + 1} - Si el primer plano es c¡clico horizontalmente.ú
 { + 2} - Si el primer plano es c¡clico verticalmente.ú
 { + 4} - Si el segundo plano es c¡clico horizontalmente.ú
 { + 8} - Si el segundo plano es c¡clico verticalmente.ú

Es decir, {0} si ninguno de los dos planos debe ser c¡clico, {15} ({1}+{2}+{4}+{8})
si ambos planos deben ser c¡clicos en ambos ejes, {12} ({4}+{8}) si £nicamente
debe ser c¡clico el segundo plano, etc.

Cuando un gr fico (principal o de fondo) sea m s peque¤o que la ventana de visualizaci¢n,
el sistema forzar  a que su plano de scroll sea c¡clico pues, en caso contrario,
no se podr¡a rellenar la ventana de scroll por completo, sin repetir {c¡clicamente}
el gr fico (en mosaico).

{/}

{Adem s de la llamada a la funci¢n se deben inicializar algunos valores de
la} {#1101,estructura global scroll} {para el correcto funcionamiento de la ventana}.
sta es una estructura de 10 registros (uno para cada posible ventana de scroll)
y cada registro tiene los siguientes campos:

  {x0, y0}  - Coordenadas del primer planoú
  {x1, y1}  - Coordenadas del segundo planoú
  {z}       - Plano de profundidadú
  {camera}  - {#1039,C¢digo identificador} de la c maraú
  {ratio}   - Velocidad relativa del segundo planoú
  {speed}   - Velocidad m xima del primer planoú
  {region1} - Primera regi¢n de pantallaú
  {region2} - Segunda regi¢n de pantallaú

Hay dos formas de programar el movimiento de las ventanas de scroll:

- Manualmente, modificando en cada imagen del juego los campos {x0}, {y0},
{x1} e {y1} de esta estructura (las coordenadas de los planos de scroll).

- Autom ticamente, para lo que se necesita el {#1038,c¢digo identificador}
de un proceso en el campo {camera} de esta estructura. Siendo a partir de
entonces el sistema el encargado de realizar en la ventana de scroll un
seguimiento al gr fico de este proceso.

Ver la ayuda sobre la {#1101,estructura scroll} para m s informaci¢n sobre
estos campos, o para saber c¢mo acceder a ellos.

{/}

{#9999,Ejemplo de scroll AUTOMATICO:}
PROGRAM ejemplo_start_scroll;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");

    start_scroll(0, fichero1, 103, 102, 0, 15);

    scroll.camera=id;

    ctype=c_scroll;
    graph=100;
    write(0, 160, 0, 1, "Utilice los cursores para moverse");
    LOOP
        IF (key(_right)) x+=2; END
        IF (key(_left)) x-=2; END
        IF (key(_down)) y+=2; END
        IF (key(_up)) y-=2; END
        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero de gr ficos y entonces se crea una ventana
de scroll con la funci¢n {start_scroll()}. A esta £ltima se le pasan
los siguientes par metros:

{0} - N£mero de ventana de scroll (la primera, puesto que s¢lo se crear 
una ventana de esta clase).

{fichero1} - C¢digo del fichero del que se deben tomar los gr ficos; este
es el c¢digo del archivo {help.fpg} que se carg¢ con la funci¢n {#132,load_fpg()}.

{103} - C¢digo del gr fico principal (primer plano) del scroll, para ver
este gr fico se debe cargar el fichero con el {Men£ de ficheros} y as¡ poder
observar cu l es el gr fico con {c¢digo 103}.

{102} - C¢digo de gr fico secundario (segundo plano, de fondo); ‚ste es el
gr fico que se mostrar  en la ventana de scroll {detr s} del gr fico principal.

{0} - N£mero de regi¢n de la pantalla en la que se debe {colocar} el scroll;
con 0 se indica que se debe colocar en la pantalla entera.

{15} - Indicador de bloqueo, con 15 (1+2+4+8) se indica que tanto el primer
plano como el segundo ser n c¡clicos en ambos ejes (horizontal y vertical).

Tras llamar a la funci¢n {start_scroll()} el programa define el campo {camera}
de la {#1101,estructura scroll}, asign ndole el {#1039,c¢digo identificador}
del proceso principal (con la sentencia {scroll.camera=}{#1092,id}{;}); con esto se convierte
el scroll en {autom tico} siguiendo a partir de ese momento al gr fico del proceso
principal.

El programa contin£a definiendo su {tipo de coordenada} como {coordenada de
scroll} (con la sentencia {ctype=c_scroll;}), definiendo su gr fico como
el n£mero 100, que es una bola marr¢n (con {graph=100;}), imprimiendo un mensaje
y despu‚s permanecer  en un bucle en el que se pueden variar las coordenadas
de este proceso (las variables {#1123,x} e {#1124,y}) con las teclas de los
cursores.

{/}

{#9999,Ejemplo de scroll MANUAL:}
PROGRAM ejemplo_start_scroll;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");

    start_scroll(0, fichero1, 103, 102, 0, 15);

    write(0, 160, 0, 1, "Utilice los cursores desplazar el scroll");
    LOOP
        IF (key(_right))
            scroll.x0+=2;
            scroll.x1+=1;
        END
        IF (key(_left))
            scroll.x0-=2;
            scroll.x1-=1;
        END
        IF (key(_down))
            scroll.y0+=2;
            scroll.y1+=1;
        END
        IF (key(_up))
            scroll.y0-=2;
            scroll.y1-=1;
        END
        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero de gr ficos y entonces se crea una ventana
de scroll con la funci¢n {start_scroll()}. A esta £ltima se le pasan
exactamente los mismos par metros que en el ejemplo anterior.

Tras esto, el programa permanecer  en un bucle dentro del cual; al detectarse
las teclas de los cursores se variar n los campos {x0}, {y0}, {x1} e {y1} de
la {#1101,estructura global scroll}, los cuales definen las coordenadas de
los dos planos del scroll ({x0}, {y0} son las del primer plano y {x1}, {y1}
las del segundo).

Se puede observar la diferencia entre ambos m‚todos; este £ltimo, al no
haber inicializado el campo {camera} de la estrucutra, podr  manipular
directamente las coordenadas de ambos planos.

{/}{C¢mo visualizar gr ficos de procesos sobre el scroll}{/}

Para crear un proceso cuyo gr fico se visualice en la ventana de scroll, se debe
definir su variable local {#1122,ctype} como {#1168,c_scroll} ({tipo de coordenada}
como {coordenada de scroll}), lo que se har  con la siguiente sentencia:

  {ctype=c_scroll;}

Una vez hecho esto, el proceso se visualizar  en el scroll con su gr fico
(definido en la variable local {#1126,graph}). El proceso £nicamente debe
modificar sus variables {#1123,x} e {#1124,y} para moverse por el scroll.

{/}

{Cuando un proceso pertenezca al scroll (se haya asignado el valor c_scroll a su
variable local} {#1122,ctype}{):}

  - Sus variables {#1123,x} e {#1124,y} estar n referidas al punto del gr fico
del primer plano sobre el cual se situar  el gr fico del proceso.

  - Su variable {#1125,z} ahora ser  relativa a las {variables z} de los
procesos que tambi‚n pertenezcan a la misma ventana de scroll. Es decir,
cada vez que se pinte una ventana de scroll, se pintar n justo a continuaci¢n
todos los gr ficos que pertenecen a la misma (ordenados por su {z}), y
despu‚s se seguir n pintando los procesos que {no pertenecen a dicha ventana
de scroll}.

  - El proceso ser  eliminado autom ticamente cuando se elimine la ventana
de scroll a la que pertenece el proceso, con la funci¢n {#166,stop_scroll()}.
O cuando se cambie el modo de v¡deo con la funci¢n {#157,set_mode()}, ya que
al hacerlo se eliminar n tambi‚n las ventanas de scroll.

{/}

Si hubiera varias ventanas de {scroll} el proceso si visualizar¡a por defecto
en todas; si £nicamente se debiera visualizar el algunas de ellas, se deber¡a
definir su variable local {#1134,cnumber}. Por ejemplo, si hubiera 6 ventanas
de scroll (de la n£mero 0 a la 5) y se quisiera que un proceso se visualizara
£nicamente en las ventanas 0 y 2, se deber¡a incluir en el mismo la siguiente
sentencia:

  {cnumber=c_0+c_2;}

Para poder observar un ejemplo de lo aqu¡ expuesto, lo mejor es examinar
alguno de los juegos ejemplo de DIV Games Studio que utilizan esta t‚cnica,
por lo que se remite al lector directamente a los comentarios de estos
programas (por ejemplo v‚ase el ejemplo {Helioball}).

{/}Ver: {#166,stop_scroll()} - {#152,refresh_scroll()} - {#140,move_scroll()} - {#1101,Estructura scroll}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.164,stop_cd()}

{stop_cd()}

{Descripci¢n:}

Detiene la reproducci¢n CD-Audio, parando la canci¢n que estuviese sonando.
Las canciones se reproducen con la funci¢n {#144,play_cd()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_stop_cd;
BEGIN
    write(0, 160, 0, 1, "Pulse [ENTER] para poner en marcha el CD.");
    write(0, 160, 10, 1, "Pulse [ESPACIO] para parar el CD.");
    LOOP
        IF (scan_code==_space)

            stop_cd(); // Para el CD

        END
        IF (scan_code==_enter)
            play_cd(2, 0);
        END
        FRAME;
    END
END
{-}

En el ejemplo se ponen los mensajes necesarios. En cada paso del
bucle, si se pulsa la barra espaciadora, se parar  el CD con la funci¢n
{stop_cd()}.

Si se pulsa la tecla Enter se pondr  en marcha el CD con la funci¢n
{#144,play_cd()}.

El volumen de reproducci¢n de cd-audio se puede controlar con la
estructura {#1104,setup} y la funci¢n {#178,set_volume()}.

{/}Ver: {#144,play_cd()} - {#127,is_play_cd()} - {#178,set_volume()} - {#1104,Estructura setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.165,stop_mode7()}

{stop_mode7(}<n£mero de m7>{)}

{Descripci¢n:}

Elimina la ventana de modo 7 cuyo n£mero (del 0 al 9) se pasa como par metro.
Este <n£mero de m7> es el que se indic¢ como primer par metro en la funci¢n
{#162,start_mode7()}, es necesario debido a que pueden haber hasta 10 ventanas
diferentes de modo 7, y el sistema necesita saber cu l de ellas se est 
finalizando.

Al eliminar una ventana de modo 7, morir n autom ticamente todos los procesos
que pertenezcan en exclusiva a dicha ventana, es decir, todos los procesos que
tengan su variable {#1122,ctype} con el valor {#1169,c_m7} y no se est‚n
visualizando en ninguna otra ventana de modo 7.

{Importante:} Al cambiar de modo de v¡deo con la funci¢n {#157,set_mode()}
todas las ventanas de modo 7 (y sus procesos) ser n igualmente eliminadas,
no siendo en este caso necesario usar esta funci¢n ({stop_mode7()}).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_stop_mode7;
BEGIN
    load_fpg("help\help.fpg");
    write(0, 160, 0, 1, "Pulse [ENTER] para poner modo 7.");
    write(0, 160, 10, 1, "Pulse [ESPACIO] para quitar modo 7.");
    write(0, 160, 190, 1, "Utilice el rat¢n para moverse por el modo 7.");
    angle=90000;
    LOOP
        IF (scan_code==_space)

            stop_mode7(0); // Se quita el modo 7

        END
        IF (scan_code==_enter)
            start_mode7(0, 0, 4, 0, 0, 64);
            m7.camera=id;
        END
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero de gr ficos y se muestran las instrucciones
del programa en pantalla, tras lo cual las coordenadas del proceso principal,
que servir  de c mara del modo 7, ser n controladas con el rat¢n (mediante
las sentencias {x=mouse.x;} y {y=mouse.y}).

Cuando se pulse la tecla ENTER se crear  una ventana de modo 7 con un gr fico
de un circuito abatido, controlada por el proceso principal.

Al pulsarse la barra espaciadora se invocar  a la funci¢n {stop_mode7()},
eliminando esta la ventana de visualizaci¢n en modo 7.

{/}

Crear una ventana de modo 7 es un procedimiento algo avanzado y requiere
iniciar varios par metros, como en este caso la c mara, algunos de ellos
requeridos por la funci¢n {#162,start_mode7()} y otros contenidos en la
estructura global {#1102,m7} (como la variable {m7.camera} utilizada en el
ejemplo).

{/}Ver: {#162,start_mode7()} - {#1102,Estructura m7}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.166,stop_scroll()}

{stop_scroll(}<n£mero de scroll>{)}

{Descripci¢n:}

Elimina la ventana de scroll cuyo n£mero (del 0 al 9) se pasa como par metro.
Este <n£mero de scroll> es el que se indic¢ como primer par metro en la funci¢n
{#163,start_scroll()} y es necesario debido a que puede haber hasta 10 ventanas
diferentes de scroll, y el sistema necesita saber cu l de ellas se est 
finalizando.

Al eliminar una ventana de scroll morir n, autom ticamente, todos los procesos
que pertenezcan en exclusiva a dicha ventana, es decir, todos los procesos que
tengan su variable {#1122,ctype} con el valor {#1168,c_scroll} y no se est‚n
visualizando en ninguna otra ventana de scroll.

{Importante:} Al cambiar de modo de v¡deo con la funci¢n {#157,set_mode()}
todas las ventanas de scroll (y sus procesos) ser n igualmente eliminadas,
no siendo en este caso necesario usar esta funci¢n ({stop_scroll()}).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_stop_scroll;
BEGIN
    load_fpg("help\help.fpg");
    write(0, 160, 0, 1, "Pulse [ENTER] para activar la ventana de scroll.");
    write(0, 160, 10, 1, "Pulse [ESPACIO] para finalizar el scroll.");
    LOOP
        IF (scan_code==_space)

            stop_scroll(0); // Se quita el scroll.

        END
        IF (scan_code==_enter)
            start_scroll(0, 0, 103, 102, 0, 15);
        END
        scroll.x0+=1;
        scroll.y0+=1;
        scroll.x1-=1;
        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero de gr ficos y se muestran las instrucciones
del programa en pantalla.

Cuando se pulse la tecla ENTER se crear  una ventana de scroll y al pulsarse
la barra espaciadora se invocar  a la funci¢n {stop_scroll()}, eliminando
‚sta la ventana de visualizaci¢n del scroll.

Dentro del bucle principal se acceden a las coordenadas del scroll contenidas
en la {#1101,estructura global scroll} para desplazar manualmente la ventana
de scroll ({scroll.x0+=1; ...}).

{/}

Crear una ventana de scroll es un procedimiento algo avanzado y requiere
iniciar varios par metros, algunos de ellos requeridos por la funci¢n
{#163,start_scroll()} y otros contenidos en la {#1101,estructura global scroll}
(como la variable {scroll.x0} utilizada en el ejemplo).

{/}Ver: {#163,start_scroll()} - {#1101,Estructura scroll}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.167,stop_sound()}

{stop_sound(}<n£mero de canal>{)}

{Descripci¢n:}

Para el sonido que est‚ sonando por el canal pasado como par metro.

El <n£mero de canal> requerido es el valor que retorna la funci¢n
{#159,sound()} cuando se inicia la reproducci¢n de un efecto de sonido.

Existen un total de 16 canales de sonido, pudiendo sonar hasta 16 sonidos
simult neamente.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_stop_sound;

PRIVATE
    id_sonido;
    canal;
    sonando=FALSE;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 160, 0, 1, "Pulse [ESPACIO] para iniciar la reproducci¢n.");
    write(0, 160, 10, 1, "Pulse [ENTER] para detener el canal de sonido.");
    id_sonido = load_pcm("help\help.pcm", 1);
    LOOP
        IF (scan_code==_space AND NOT sonando)
            canal = sound(id_sonido, 128, 256);
            sonando=TRUE;
        END
        IF (scan_code==_enter)

            stop_sound(canal); // Se para el sonido

            sonando=FALSE;
        END
        FRAME;
    END
END
{-}

En el ejemplo se pone un gr fico de fondo y los mensajes necesarios, a la
vez que se carga el efecto de sonido contenido en el archivo {help.pcm} con
la funci¢n {#134,load_pcm()}, que devuelve el identificador del sonido
que se guarda en la variable {id_sonido}. Se puede ver que en este ejemplo
se pasa a esta funci¢n un {1} como segundo par metro; esto es para indicar
que el efecto de sonido cargado debe repetirse indefinidamente cada vez
que sea iniciado (esto se hace para resaltar el efecto de la funci¢n
{stop_sound()}.

En cada paso del bucle se comprueba si se pulsa la barra espaciadora, en
cuyo caso se iniciar  la reproducci¢n del efecto de sonido con {#159,sound()},
que devolver  el n£mero de canal que se guardar  en la variable {canal}.

Si se pulsa la tecla ENTER el sonido ser  parado con la funci¢n {stop_sound()}.

{/}

Para parar gradualmente un sonido, bajando su volumen poco a poco, se deben
realizar varias llamadas a la funci¢n {#102,change_sound()} para ir
decrementando ligeramente el volumen del canal hasta que ‚ste llegue a 0;
entonces se puede llamar a la funci¢n {stop_sound()} para detener definitivamente
el efecto de sonido.

{/}Ver: {#159,sound()} - {#102,change_sound()} - {#134,load_pcm/wav()} - {#170,unload_pcm/wav()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.168,system()}

{system(}<"comando externo">{)}

{Descripci¢n:}

Ejecuta el comando de sistema operativo que se pasa como par metro.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_system;
BEGIN
    write(0, 160, 0, 1, "Presione [ESPACIO] para hacer un DIR.");
    LOOP
        IF (scan_code==_space)

            system("dir"); // Se ejecuta un comando del MS-DOS.

        END
        FRAME;
    END
END
{-}

En el ejemplo, tras imprimir un texto, se entra dentro del bucle principal
en el que se ejecutar  el comando {DIR} del sistema operativo MS-DOS cada
vez que se pulse la barra espaciadora.

{/}

Una utilidad que puede tener este comando es, por ejemplo, borrar alg£n
archivo temporal que se haya creado en el programa, invocando el comando
del sistema {DEL <}nombre de archivo{>}.

{/}

{Nota:} El sistema puede bloquearse seg£n qu‚ comandos se ejecuten, debiendo
reinicializar el ordenador en estos casos; no se ofrece ning£n tipo de
garant¡a en cuanto al funcionamiento de esta funci¢n, debido a las m£ltiples
incompatibilidades que se pueden presentar entre los comandos externos y
el gestor de procesos interno de DIV Games Studio.

{/}

{system("COMMAND.COM")}

{Descripci¢n:}

Ejecuta una sesi¢n del sistema operativo MS-DOS desde del propio programa.
Al teclear EXIT desde la misma, se retornar  al programa en el punto en el que
se ejecut¢ esta sentencia.

{/}Ver: {#109,exit()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.169,unload_fpg()}

{unload_fpg(}<c¢digo del fichero>{)}

{Descripci¢n:}

Descarga de memoria el fichero de gr ficos cuyo c¢digo se pasa como par metro.
Este <c¢digo de fichero> es el valor que retorna la funci¢n {#132,load_fpg()}
cuando se carga un nuevo fichero de gr ficos en la memoria.

Tras descargarse un fichero de gr ficos {se deben extremar las precauciones}
para no continuar utilizando en el programa ning£n gr fico que estuviera en
dicho fichero. En cuyo caso el programa correr¡a el riesgo de bloquearse.

{No es necesario descargar el fichero de memoria} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

Por lo tanto, un fichero se debe descargar de memoria £nicamente cuando ya no se
vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio
ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros
de gr ficos, sonidos, fuentes, etc.).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_unload_fpg;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    put_screen(fichero1, 1);
    write(0, 160, 0, 1, "Pulse [ENTER] para descargar el fichero y terminar");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_fpg(fichero1); // Se descarga el fichero.

END
{-}

El ejemplo carga el fichero de gr ficos contenido en el archivo {help.fpg}
con la funci¢n {#132,load_fpg()}, guardando el {c¢digo del fichero} en la
variable privada {fichero1}.

El programa permanecer  en un bucle hasta que se pulse la tecla ENTER,
momento en el cual se descargar  el fichero de memoria con {unload_fpg()}
y terminar  el programa.

{/}

Los gr ficos cargardos individualmente con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) no se
descargar n cuando se descargue el fichero n£mero 0 (con c¢digo 0), aunque
‚stos se utilicen como si pertenecieran al mismo, sino que se deber n descargar
utilizando las funciones {#176,unload_map()} o {#176,unload_pcx()}.

{/}Ver: {#132,load_fpg()} - {#174,load_map/pcx()} - {#176,unload_map/pcx()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.170,unload_pcm() / unload_wav()}

{unload_pcm(}<c¢digo del sonido>{)}

{unload_wav(}<c¢digo del sonido>{)}

{Descripci¢n:}

Descarga de memoria el sonido cuyo c¢digo se pasa como par metro.
Este <c¢digo de sonido> es el valor que retornan las funciones
{#132,load_pcm()} y {#132,load_wav()}
cuando se carga un nuevo efecto de sonido en la memoria.

Tras descargarse un efecto de sonido {se deben extremar las precauciones}
para no continuar utilizando en el programa dicho efecto (su c¢digo), en cuyo
caso el programa correr¡a el riesgo de bloquearse.

{No es necesario descargar el sonido de memoria} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

Por lo tanto, un sonido se debe descargar de memoria £nicamente cuando ya no se
vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio
ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros
de gr ficos, sonidos, fuentes, etc.), lo que tendr  sentido £nicamente con
efectos de sonido de cierta longitud, es decir, que sean lo suficientemente
grandes como para que merezca la pena liberar el espacio que ocupan.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_unload_pcm;

PRIVATE
    sonido1;

BEGIN
    sonido1=load_pcm("help\help.pcm",0);
    write(0, 160, 0, 1, "Pulse [ENTER] para descargar el sonido y terminar");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_pcm(sonido1); // Se descarga el fichero.

END
{-}

El ejemplo carga el efecto de sonido contenido en el archivo {help.pcm}
con la funci¢n {#134,load_pcm()}, guardando el {c¢digo del sonido} en la
variable privada {sonido1}.

El programa permanecer  en un bucle hasta que se pulse la tecla ENTER,
momento en el cual se descargar  el fichero de memoria con {unload_pcm()}
y terminar  el programa.

{/}

Para parar un efecto de sonido, pero seguir manteni‚ndolo en memoria para
cuando se quiera hacer sonar de nuevo, se debe utilizar la funci¢n {#167,stop_sound()}.

{/}Ver: {#134,load_pcm/wav()} - {#159,sound()} - {#102,change_sound()} - {#167,stop_sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.171,write()}

{write(}<fuente>{,} <x>{,} <y>{,} <c¢digo de centrado>{,} <texto>{)}

{Retorna:}

El c¢digo identificador del texto que se ha escrito.

{Descripci¢n:}

Esta funci¢n es la utilizada para mostrar un texto alfanum‚rico en pantalla;
para ello requiere los siguientes par metros:

{<fuente>} - El {c¢digo de la fuente} o {tipo de letra} que se va a utilizar.
Aqu¡ se debe poner un 0 cuando se quiera utilizar la fuente del sistema
(fuente de color blanco, peque¤a, de 6 por 8 puntos), o bien el {c¢digo de
fuente} devuelto por la funci¢n {#131,load_fnt()} cuando se carga una nueva
fuente en el programa.

{<x>}, {<y>} - Las coordenadas relativas a pantalla en las que se va a
imprimir el texto, primero en el eje horizontal y despu‚s en el vertical.

{<c¢digo de centrado>} - Es un c¢digo que determina la posici¢n del texto
que se especifica en las coordenadas anteriores. Sus valores son:

  {0}-Arriba izquierda {1}-Arriba {2}-Arriba derechaú
  {3}-Izquierda        {4}-Centro {5}-Derechaú
  {6}-Abajo izquierda  {7}-Abajo  {8}-Abajo derechaú

Por ejemplo, si se escribe un texto en las coordenadas 160, 0 y con el
c¢digo de centrado 1 (Arriba), entonces se centrar  el texto en la columna
160 y se imprimir  de la l¡nea 0 hacia abajo. O si se quiere un texto en la
esquina superior izquierda, se debe imprimir en las coordenadas 0, 0 y con
c¢digo de centrado 0 (Arriba izquierda).

{<texto>} - Como £ltimo par metro se especificar  texto a escribir como un
literal, es decir, un texto entre comillas (Ver los
{#1047,s¡mbolos delimitadores de literales}).

{/}

El texto impreso permanecer  en pantalla hasta que se borre con la funci¢n
{#107,delete_text()}, que requiere como par metro el {c¢digo identificador}
que devuelve {write()}.

Para imprimir el valor num‚rico de una variable (como pudiera ser la
puntuaci¢n del jugador) se debe utilizar funci¢n {#172,write_int()}.

Los textos permanecer n inalterados en pantalla aunque se impriman gr ficos
en la misma o pasen gr ficos de procesos por delante o por detr s de los
mismos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_write;

PRIVATE
    fuente1;

BEGIN
    fuente1 = load_fnt("help\help.fnt");

    write(0, 160, 100, 4, "Texto de ejemplo con la fuente del sistema.");
    write(fuente1, 0, 0, 0, "ARRIBA IZQUIERDA");
    write(fuente1, 320, 200, 8, "ABAJO DERECHA");

    LOOP
        FRAME;
    END
END
{-}

En el ejemplo anterior se carga la fuente contenida en el archivo {help.fnt}
con la funci¢n {#131,load_fnt()} (cuyo c¢digo de fuente se guarda en la
variable {fuente1}), y despu‚s se escriben tres textos:

El primero con la fuente del sistema (0), situ ndose en las coordenadas 160, 100
(centro de la pantalla) el {centro} del texto (c¢digo de centrado 4).

El segundo con la fuente cargada (cuyo {identificador de fuente} se tiene
almacenado en la variable {fuente1}), situ ndose en las coordenadas 0, 0 la
esquina superior izquierda del texto (c¢digo de centrado 0).

Y, por £ltimo, el tercer texto, tambi‚n con la fuente cargada, situ ndose
en las coordenadas 320, 200 la esquina inferior derecha del texto (c¢digo de
centrado 8).

Tras esto el programa se quedar  esperando indefinidamente dentro de un
bucle.

{/}

El plano de profundidad en el que aparecen los textos escritos se controla
mediante la variable global {#1106,text_z}, que sirve para regular qu‚
gr ficos se deben ver por encima de los textos y cu les por debajo.

Los textos podr n, luego, moverse hasta otra posici¢n si es necesario
utilizando la funci¢n {#141,move_text()}, que tambi‚n requiere como
par metro el {c¢digo identificador} que devuelve {write()}.

{/}

Cuando se utilicen fuentes cargadas de {archivos FNT} debe estar activada
la paleta de colores que se ha utilizado para generar dichas fuentes (ver
{#133,load_pal()}) pues, de lo contrario, los colores pueden aparecer
cambiados, visualiz ndose el texto incorrectamente.

{/}Ver: {#172,write_int()} - {#141,move_text()} - {#107,delete_text()} - {#131,load_fnt()} - {#1106,text_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.172,write_int()}

{write_int(}<fuente>{,} <x>{,} <y>{,} <c¢digo de centrado>{,} <OFFSET variable>{)}

{Retorna:}

El c¢digo identificador del texto que se ha escrito.

{Descripci¢n:}

Esta funci¢n es la utilizada para visualizar el valor num‚rico de una variable;
para ello requiere los siguientes par metros:

{<fuente>} - El {c¢digo de la fuente} o {tipo de letra} que se va a utilizar.
Aqu¡ se debe poner un 0 cuando se quiera utilizar la fuente del sistema
(fuente de color blanco, peque¤a, de 6 por 8 puntos), o bien el {c¢digo de
fuente} devuelto por la funci¢n {#131,load_fnt()} cuando se carga una nueva
fuente en el programa.

{<x>}, {<y>} - Las coordenadas relativas a pantalla en las que se va a
imprimir el valor num‚rico, primero en el eje horizontal y despu‚s en el vertical.

{<c¢digo de centrado>} - Es un c¢digo que determina la posici¢n del valor num‚rico
que se especifica en las coordenadas anteriores. Sus valores son:

  {0}-Arriba izquierda {1}-Arriba {2}-Arriba derechaú
  {3}-Izquierda        {4}-Centro {5}-Derechaú
  {6}-Abajo izquierda  {7}-Abajo  {8}-Abajo derechaú

Por ejemplo, si se escribe un valor num‚rico en las coordenadas 160, 0 y con el
c¢digo de centrado 1 (Arriba), entonces se centrar  el valor num‚rico en la columna
160 y se imprimir  de la l¡nea 0 hacia abajo. O si se quiere un valor num‚rico en la
esquina superior izquierda, se debe imprimir en las coordenadas 0, 0 y con
c¢digo de centrado 0 (Arriba izquierda).

{<OFFSET variable>} - Como £ltimo par metro se debe especificar el
desplazamiento dentro de la memoria del ordenador de la variable cuyo valor
se quiere visualizar (el desplazamiento del dato se obtiene con el
operador {#1085,OFFSET}).

{/}

El valor num‚rico impreso permanecer  en pantalla hasta que se borre con la funci¢n
{#107,delete_text()}, que requiere como par metro el {c¢digo identificador}
que devuelve {write_int()}.

{Importante:} Durante el tiempo que aparezca el valor de la variable en
pantalla, ‚ste se ir  actualizando autom ticamente cada vez que se modifique
la variable, no siendo necesarias nuevas llamadas a {write_int()}.

Para imprimir un texto alfanum‚rico de cualquier tipo (un texto fijo)
se debe utilizar la funci¢n {#171,write()}.

Los textos permanecer n inalterados en pantalla aunque se impriman gr ficos
en la misma o pasen gr ficos de procesos por delante o por detr s de ellos.


{#9999,Programa ejemplo:}
PROGRAM ejemplo_write_int;

PRIVATE
    variable;

BEGIN
    write(0, 160, 190, 1, "Pulse [ESPACIO] para cambiar el valor de la variable.");

    write_int(0, 160, 100, 4, OFFSET variable); // Se imprime una variable.

    LOOP
        IF (scan_code==_space) variable=rand(-100, 100); END
        FRAME;
    END
END
{-}

En el ejemplo se imprime un texto usando {#171,write()} y el valor de una
variable con la funci¢n {write_int()}. A esta £ltima funci¢n se le pasan los siguientes
par metros:

  {0} - Como {fuente} (0 es la fuente del sistema).ú
  {0, 10} - Como coordenadas de pantalla.ú
  {0} - Como c¢digo de centrado (Arriba/Izquierda).ú
  {OFFSET variable} - Como el desplazamiento en memoria de la variable.ú

A cada paso del bucle, si se pulsa la barra espaciadora, se cambia el valor
de la variable asign ndole uno elegido aleatoriamente, al azar, con la
funci¢n {#149,rand()}.

{/}

El plano de profundidad en el que aparecen los textos escritos se controla
mediante la variable global {#1106,text_z}, que sirve para regular qu‚
gr ficos se deben ver por encima de los textos y cu les por debajo.

Los textos podr n luego moverse hasta otra posici¢n si es necesario
utilizando la funci¢n {#141,move_text()}, que tambi‚n requiere como
par metro el {c¢digo identificador} que devuelve {write_int()}.

{/}

Cuando se utilicen fuentes cargadas de {archivos FNT} debe estar activada
la paleta de colores que se ha utilizado para generar dichas fuentes (ver
{#133,load_pal()}) pues, de lo contrario, los colores pueden aparecer
cambiados, visualiz ndose el texto incorrectamente.

{/}

{Advertencia:}

No es posible imprimir una expresi¢n, como se muestra a continuaci¢n:

  {write_int(0, 0, 0, 0, offset variable + 1);}

Para imprimir el valor de la variable m s 1, es decir, si se quisiera
imprimir este valor, se deber¡a sumar 1 a la variable o crear otra
variable y asignarle a ‚sta el valor de la variable original m s 1, por
ejemplo:

  {variable2 = variable + 1;}ú
  {write_int(0, 0, 0, 0, offset variable2);}ú

En este caso se deber¡a tener en cuenta que habr¡a que actualizar el
valor de {variable2} al menos una vez por cada imagen (por cada
{#1029,FRAME}) del juego, ya que al cambiar {variable} no se actualizar¡a
autom ticamente el valor de {variable2} a no ser que se ejecutara
nuevamente la sentencia {variable2 = variable + 1;}.

{/}Ver: {#171,write()} - {#141,move_text()} - {#107,delete_text()} - {#131,load_fnt()} - {#1106,text_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.173,xput()}

{xput(}<fichero>{,} <gr fico>{,} <x>{,} <y>{,} <angle>{,} <size>{,} <flags>{,} <region>{)}

{Descripci¢n:}

Versi¢n avanzada de la funci¢n {#146,put()} para poner un gr fico en el fondo
de la pantalla. Esta funci¢n requiere, por orden, los siguientes par metros:

{<fichero>} - {c¢digo del fichero} con la librer¡a de gr ficos que contiene
a ambos. Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

{<gr fico>} - {c¢digo del gr fico} dentro del fichero que se va a imprimir
en pantalla.

{<x>, <y>} - coordenadas relativas a pantalla donde se desea poner el gr fico.
Estas coordenadas se refieren a donde se situar  el centro del gr fico (o el {#1136,punto
de control} n£mero 0, en caso de estar definido).

{<angle>} -  ngulo (en mil‚simas de grados) en el que se imprimir  el gr fico;
el  ngulo normal es {0}.

{<size>} - tama¤o (en porcentaje) en el que se imprimir  el gr fico; el
tama¤o normal es {100}.

{<flags>} - Indica los espejados y transparencias con los que se imprimir  el
gr fico; los posibles valores son:

 {0}-Gr fico normal.ú
 {1}-Espejado horizontal.ú
 {2}-Espejado vertical.ú
 {3}-Espejado horizontal y vertical (180ø).ú
 {4}-Gr fico transparente.ú
 {5}-Transparente y espejado horizontal.ú
 {6}-Transparente y espejado vertical.ú
 {7}-Transparente, espejado horizontal y vertical.ú

{<regi¢n>} - N£mero de regi¢n (ventana dentro de la pantalla) en la que
se debe imprimir el gr fico; normalmente este valor ser  {0} para poder
imprimir el gr fico en cualquier posici¢n de la pantalla. Para definir
una regi¢n se debe utilizar la funci¢n {#106,define_region()}.

{/}

Los gr ficos impresos de esta forma en el fondo de la pantalla estar n en la
visualizaci¢n del juego {por debajo de todos los procesos, regiones de scroll,
textos, etc.}

Si se desea que un gr fico est‚ por encima de otros se debe {crear
como un nuevo proceso} y fijar su variable {#1125,z} con la prioridad
de impresi¢n del mismo.

Para borrar el fondo de la pantalla se debe utilizar la funci¢n {#103,clear_screen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_put;

PRIVATE
    fichero1;
    coord_x;
    coord_y;
     ngulo1;
    tama¤o1;
    flags1;

BEGIN
    fichero1=load_fpg("help\help.fpg");
    LOOP
        coord_x=rand(0, 319);
        coord_y=rand(0, 199);
         ngulo1=rand(-pi, pi);
        tama¤o1=rand(10, 200);
        flags1=rand(0, 7);

        // Se pone el gr fico 101
        xput(fichero1, 101, coord_x, coord_y,  ngulo1, tama¤o1, flags1, 0);

        FRAME;
    END
END
{-}

En el ejemplo se carga el fichero con los gr ficos y en cada iteraci¢n
de bucle se pone el gr fico n£mero 101 (un tri ngulo) con la funci¢n {xput()} en
coordenadas aleatorias (elegidas al azar con la funci¢n {#149,rand()}),
con un  ngulo y un tama¤o tambi‚n aleatorio, con el valor de {flags} aleatorio y
en la regi¢n n£mero 0 (pantalla completa).

{/}

La funci¢n {#146,put()} es una versi¢n simplificada de la
funci¢n {xput()} de utilidad cuando no se quiera rotar, escalar, espejar
o imprimir con transparencias el gr fico.

Para poner un gr fico en otro (en lugar del fondo de la pantalla)
se deben utilizar las funciones {#137,map_put()} o {#139,map_xput()}.

{/}

Si el gr fico que se quiere poner es simplemente una pantalla de fondo,
resulta m s sencillo utilizar la funci¢n {#148,put_screen()}, ya que ‚sta
no requiere las coordenadas de pantalla, pues centrar  el gr fico en la
misma de forma autom tica.

{/}Ver: {#146,put()} - {#137,map_put()} - {#139,map_xput()} - {#148,put_screen()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.174,load_map() / load_pcx()}

{load_map(}<nombre de archivo>{)}

{load_pcx(}<nombre de archivo>{)}

{Retorna:}

El {c¢digo del gr fico} cargado.

{Descripci¢n:}

Carga un {archivo MAP o PCX} con un gr fico en la memoria del ordenador. Se
requiere el nombre del archivo como par metro, entre comillas.

Se devuelve como valor de retorno el {c¢digo del gr fico}, que es un valor
num‚rico que debe especificarse para utilizar el gr fico, en la variable
{#1126,graph} o, en general, en todas las funciones que requieran un {c¢digo
de gr fico} entre sus par metros.

Es posible cargar tantos gr ficos como sea necesario; cada vez que se
cargue uno la funci¢n devolver  el c¢digo que le corresponde (el primer
gr fico cargado tendr  el c¢digo {1000}, el siguiente el {1001}, etc.)

Se puede especificar la ruta de acceso al archivo con el fichero de gr ficos,
no obstante, si el fichero est  en el directorio por defecto (\MAP o \PCX) no ser 
necesario.

{/}

{Importante:}

Cuando se requiera dentro de una funci¢n el {c¢digo de fichero} al que
pertenece dicho gr fico, se debe indicar el c¢digo {0} (que es el c¢digo
del primer {fichero FPG} que se cargue en el programa).

{/}

Cuando se han cargado diferentes gr ficos se debe tener en cuenta que si
‚stos tienen paletas diferentes, se debe activar cada una de ellas previamente
con la funci¢n {#133,load_pal()}, indicando el nombre del fichero como
par metro, antes de utilizar el gr fico.

No se pueden utilizar simult neamente gr ficos creados con distintas paletas.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_map;

PRIVATE
    mapa1;

BEGIN

    mapa1 = load_map("help\help.map"); // Se carga un fichero de mapa gr fico.

    put_screen(0, mapa1);
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo se carga un mapa gr fico con la funci¢n {load_map()} guardando
el {c¢digo del gr fico} que retorna en la variable privada {mapa1}.

Este c¢digo se usa posteriormente como par metro de la funci¢n {#148,put_screen()}
para poner el gr fico en el fondo de pantalla.

{/}

Las funciones {#176,unload_map()} y {#176,unload_pcx()} permiten liberar la memoria del ordenador utilizada
por el gr fico cuando ya no se va a utilizar m s durante un tiempo, y para ello
requieren tambi‚n el {codigo del gr fico}, para saber qu‚ gr fico es el que se
quiere descargar de memoria.

{No es necesario descargar el gr fico de memoria} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

{/}

Para cargar varios gr ficos de golpe en un programa, ‚stos deben estar incluidos
dentro de un fichero de gr ficos (FPG) y cargarse con la funci¢n {#132,load_fpg()}.

{/}

La funci¢n {#188,new_map()} permite crear en memoria un mapa gr fico de cualquier
tama¤o y color, sin cargarlo de un archivo en disco.

{/}Ver: {#188,new_map()} - {#176,unload_map/pcx()} - {#132,load_fpg()} - {#133,load_pal()} - {#1126,graph}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.175,reset_sound()}

{reset_sound(}{)}

{Descripci¢n:}

Funci¢n avanzada, £nicamente para usuarios muy experimentados. Reinicializa
el sistema de sonido.

Esta funci¢n sirve para activar unos nuevos par metros del hardware de sonido.

Se deben establecer los siguientes valores de la {#1104,estructura global setup}:

    {setup.card}ú
    {setup.port}ú
    {setup.irq}ú
    {setup.dma}ú
    {setup.dma2}ú

Esta funci¢n se utiliza generalmente dentro de los programas de configuraci¢n
del sistema de sonido (ver {#1093,setup_program}).

{/}

Para activar el resto de los valores de la estructura setup, los referentes
al volumen del mezclador ({mixer}), se debe invocar a la funci¢n
{#178,set_volume()}. Los valores para establecer el volumen son:

    {setup.master}ú
    {setup.sound_fx}ú
    {setup.cd_audio}ú

{/}Ver: {#178,set_volume()} - {#1104,Estructura setup} - {#1093,setup_program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.176,unload_map() / unload_pcx()}

{unload_map(}<c¢digo del gr fico>{)}

{unload_pcx(}<c¢digo del gr fico>{)}

{Descripci¢n:}

Descarga de memoria el gr fico cuyo c¢digo se pasa como par metro.
Este <c¢digo de gr fico> es el valor que retornan las funciones {#174,load_map()},
{#174,load_pcx()} o {#188,new_map()} al cargar o crear un gr fico.

Tras descargarse un gr fico {se deben extremar las precauciones}
para no continuar utilizando en el programa dicho gr fico, en cuyo caso el
programa correr¡a el riesgo de bloquearse.

{No es necesario descargar el gr fico} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

Luego, un gr fico solamente debe descargarse de memoria cuando ya no se
vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio
ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros
de gr ficos, sonidos, fuentes, etc.), lo que tendr  sentido £nicamente con
gr ficos de un cierto tama¤o, es decir, que sean lo suficientemente
grandes como para sea rentable liberar el espacio que ocupan.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_unload_map;

PRIVATE
    mapa1;

BEGIN
    mapa1=load_map("help\help.map");
    put_screen(0, mapa1);
    write(0, 160, 0, 1, "Pulse [ENTER] para descargar el gr fico y terminar");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_map(mapa1); // Se descarga el gr fico.

END
{-}

En el ejemplo se carga un mapa gr fico con la funci¢n {#174,load_map()} guardando
el {c¢digo del gr fico} que retorna en la variable privada {mapa1}.

Este c¢digo se usa, posteriormente, como par metro de la funci¢n {#148,put_screen()}
para poner el gr fico en el fondo de pantalla.

Entonces el programa imprimir  un mensaje y esperar  en un bucle hasta que
se pulse la tecla ENTER, momento en el cual se descargar  el gr fico
utilizando la funci¢n {unload_map()}.

{/}

Los gr ficos cargados individualmente con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) no se
descargar n cuando se descargue el fichero n£mero 0 (con c¢digo 0) con la
funci¢n {#169,unload_fpg()}, aunque estos gr ficos se utilicen como si
pertenecieran al mismo.

{/}Ver: {#174,load_map/pcx()} - {#169,unload_fpg()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.177,unload_fnt()}

{unload_fnt(}<c¢digo de la fuente>{)}

{Descripci¢n:}

Descarga de memoria la {fuente} (el {tipo de letra} o el {juego de car cteres
gr ficos}) cuyo c¢digo se pasa como par metro.

Este <c¢digo de fuente> es el valor que retorna la funci¢n {#131,load_fnt()}
al cargar una nueva fuente de letras contenida en un {archivo FNT} en
la memoria del ordenador.

Tras descargarse una fuente {se deben extremar las precauciones}
para no continuar utilizando en el programa dicha fuente; si se hiciera as¡, se correr¡a el
riesgo de que el programa pudiera bloquearse.

{No es necesario descargar la fuente} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

Despu‚s, se debe descargar una fuente de memoria £nicamente cuando ya no se
vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio
ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros
de gr ficos, sonidos, fuentes, etc.).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_unload_fnt;

PRIVATE
    fuente1;

BEGIN
    fuente1=load_fnt("help\help.fnt");
    write(fuente1, 160, 0, 1, "FUENTE DEL ARCHIVO EN DISCO");
    write(0, 160, 190, 1, "Pulse [ENTER] para descargar la fuente y terminar");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_fnt(fuente1); // Se descarga la fuente
END
{-}

En el ejemplo se carga la fuente contenida en el archivo {help.fnt} con la
funci¢n {#131,load_fnt()} guardando el {c¢digo de fuente} que retorna en
la variable privada {fuente1}.

Este c¢digo se usa posteriormente como par metro de la funci¢n {#171,write()}
para poner un texto en pantalla con dicha fuente.

Entonces el programa esperar  en un bucle hasta que se pulse la tecla ENTER,
momento en el cual se descargar  la fuente utilizando la funci¢n {unload_fnt()},
con lo que se terminar  el programa.

{/}

La fuente n£mero 0, (la fuente del sistema que tiene 0 como c¢digo de fuente),
{no se puede descargar}.

{/}Ver: {#131,load_fnt()} - {#171,write()} - {#172,write_int()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.178,set_volume()}

{set_volume(}{)}

{Descripci¢n:}

Funci¢n avanzada, s¢lo para usuarios muy experimentados.
Ajusta los diferentes controles de volumen gestionados por el mezclador
({mixer}) del sistema de sonido.

Se deben establecer los siguientes valores de la {#1104,estructura global
setup} para poder ajustar el volumen:

    {setup.master}   - Volumen generalú
    {setup.sound_fx} - Volumen de los efectos de sonidoú
    {setup.cd_audio} - Volumen de la m£sica de cd-audioú

Esta funci¢n se utiliza generalmente dentro de los programas de configuraci¢n
del sistema de sonido (ver {#1093,setup_program}), o bien en el resto de los
programas, normalmente para fijar el volumen de la m£sica de CD-Audio.

{/}

Para activar el resto de los valores de la estructura setup (los referentes
a par metros de la tarjeta de sonido), se debe invocar a la funci¢n {#175,reset_sound()} con
los siguientes valores de la estructura definidos:

    {setup.card}ú
    {setup.port}ú
    {setup.irq}ú
    {setup.dma}ú
    {setup.dma2}ú

{/}Ver: {#175,reset_sound()} - {#1104,Estructura setup} - {#1093,setup_program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.179,set_color()}

{set_volume(}<color>{,} <red>{,} <green>{,} <blue>{)}

{Descripci¢n:}

Redefine un color de la paleta. Esta funci¢n sirve para modificar las componentes
de un color concreto de la paleta del juego.

Se debe tener cuidado con ella, pues todos los gr ficos de pantalla que utilicen
dicho color se ver n afectados, para modificar los colores de un s¢lo gr fico
se debe utilizar la funci¢n {#105,convert_palette()}.

El <color> debe ser un n£mero entre {0} y {255}. Las {componentes del color}
se especificar n como n£meros entre {0} (m¡nimo) y {63} (m ximo).

  {<red>}   - Componente roja del color.ú
  {<green>} - Componente verde del color.ú
  {<blue>}  - Componente azul del color.ú

A continuaci¢n se muestra un programa que modifica de forma aleatoria los colores
de la paleta.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_color;
GLOBAL color,r,g,b;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 2);
    LOOP
        color=rand(1,255);
        r=rand(0,63);
        g=rand(0,63);
        b=rand(0,63);

        set_color(color, r, g, b); // Se redefine un color de la paleta

        FRAME;
    END
END
{-}

En el ejemplo se pone como fondo una pantalla multicolor y dentro del bucle
principal del programa se modifican al azar las componentes de un color cualquiera
de la paleta cuando est‚ pulsada la barra espaciadora. Para obtener n£meros al azar
se utiliza la funci¢n {#149,rand()}.

{/}

Para modificar toda la paleta, es preferible cargar ‚sta de un archivo con
la funci¢n {#133,load_pal()}.

{/}

Para realizar otros efectos de paleta, se puede utilizar la funci¢n {#154,roll_palette()} que permite realizar
ciclos de color, o la funci¢n {#110,fade()} que permite realizar
m£ltiples fundidos y saturaciones de color a diferentes velocidades.

{/}Ver: {#154,roll_palette()} - {#133,load_pal()} - {#110,fade()} - {#111,fade_off()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.180,net_join_game()}

{net_join_game(}<nombre de la partida>{,} <OFFSET estructura>{,} <SIZEOF(estructura)>{)}

{Retorna:}

N£mero de jugador dentro de la partida (0, 1, 2, ...). Si se produce un error,
se devuelve un n£mero negativo, siendo estos los c¢digos de error existentes:

 { -1} : Conexi¢n abortada por el usuario.ú
 { -2} : No se pudo inicializar la conexi¢n.ú
 { -3} : El n£mero de jugadores no coincide.ú
 { -4} : Se produjeron errores de sincronismo.ú

{Descripci¢n:}

Las funciones de red son de un nivel extremadamente avanzado, por lo que pueden
resultar muy complejas de entender para usuarios que no tengan bastante experiencia en programaci¢n.

En primer lugar debe inicializarse la estructura global predefinida {#1410,net} con los par metros
que definen el tipo de conexi¢n que debe establecerse.

Entonces, una llamada a la funci¢n {net_join_game()} bastar  para crear una nueva partida
o para unirse a la misma (si esta ya estuviera creada).

El nombre de la partida (un literal, como {"MiPartida"}), sirve £nicamente para que un s¢lo juego pueda
ejecutar varias partidas simult neamente en una sola red local. Diferenciando a cada una de las
mismas de esta forma.

A partir de ese momento todos los equipos que se hayan conectado a la partida enviar n
y recibir n datos de los dem s de forma autom tica, a trav‚s de la estructura indicada como
par metro.

{La estructura de datos.}

Esta debe ser una estructura global del programa con tantos registros como jugadores
deban conectarse simult neamente.

En los campos de esta estructura se podr n leer y escribir los datos enviados; cada jugador
debe introducir sus valores en su registro. El n£mero de registro que le corresponde a cada
jugador es el devuelto por esta funci¢n.

El sistema enviar  autom ticamente su registro a los dem s jugadores, y los registros de los
dem s jugadores a este.

{#1410,La estructura predefinida net}

En esta estructura se establecen los par metros que definen el tipo de conexi¢n. Los campos de esta
estructura se resumen a continuaci¢n.

{net.device} - Dispositivo de conexi¢n (1-IPX, 2-Cable serie o 3-M¢dem).

{net.com} - N§ de dispositivo COM, de 1 a 4 (s¢lo para serie y m¢dem).

{net.speed} - Velocidad (en baudios), hasta 115000 (s¢lo para serie y m¢dem).

{net.number} - N£mero de tel‚fono (s¢lo m¢dem), por ejemplo {net.number="913040622";}.

{net.init} - Cadena de inicio del m¢dem, por ejemplo {net.init="ATZ";}.

{net.mode} - 0 o 1 seg£n sea pulsos o tonos (tambi‚n s¢lo para el m¢dem).

{net.server} - Indica si es el servidor (s¢lo lectura, no se debe modificar).

{net.max_players} - Numero m ximo de jugadores, de 2 a 16 (debe coincidir con el n£mero de registros de la estructura global).

{net.num_players} - Numero actual de jugadores, de 1 a 16 (se pueden ir conectando y desconectando jugadores en cualquier momento).

Cuando la conexi¢n se realiza por cable serie o por m¢dem £nicamente podr n
conectarse {2 jugadores}.

{/}

Es muy importante que el n£mero de registros de la estructura utilizada
para el traspaso de datos tenga tantos registros como los indicados en {net.max_players}.

Por ejemplo, si se crea un juego en el que el n£mero m ximo de jugadores sean 8,
y la informaci¢n que deben pasarse los jugadores es £nicamente sus coordenadas (x,y),
entonces se podr¡a hacer como se indica en el siguiente programa (suponiendo una conexi¢n
IPX para una red local).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_net_join_game;

GLOBAL
  STRUCT jugador[7] // 8 jugadores como m ximo (de 0 a 7).
    x,y;
  END

  id_red;

BEGIN

  net.device=1;
  net.max_players=8; // Se indica aqu¡ el n£mero de registros.

  // ...

  id_red=net_join_game("xxx",OFFSET jugador, sizeof(jugador));

  IF (id_red<0)

    // Se ha producido un error ...

  END

  // El registro de este jugador es "jugador[id_red]"

  jugador[id_red].x=x; // Defino mis campos
  jugador[id_red].y=y;

  FRAME; // Envio / Recepci¢n de datos

  // Ahora hay conectados "net.num_players", y sus datos est n en
  // los dem s registros de la estructura jugador[].

  // ...

END
{-}

{Nota:} Se puede encontrar m s informaci¢n sobre como estructurar un juego por red en
el manual de usuario de DIV Games Studio.

{/}Ver: {#181,net_get_games()} - {#1410,STRUCT net}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.181,net_get_games()}

{net_get_games()}

{Retorna:}

Partidas activas para este juego.

{Descripci¢n:}

Devuelve el n£mero de partidas activas para este juego (para conexiones en red local).
Esta funci¢n sirve para ver si existe alguna partida activa en un momento determinado.

Para establecer una conexi¢n se utiliza la funci¢n {#180,net_join_game()}, bien sea
para crear partidas o para conectarse a las mismas.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_net_get_games;

GLOBAL
  n;  // Partidas activas.

BEGIN

  // ...

  n=net_get_games();

  IF (n>0)
    // ...
  END

  //...

END
{-}

Unicamente es £til para conexiones IPX, careciendo de sentido en conexiones por
cable serie o a trav‚s de m¢dem (ya que en estos casos £nicamente puede haber una
partida).

{/}Ver: {#180,net_join_game()} - {#1410,,STRUCT net}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.182,stop_mode8()}

{stop_mode8(}<n£mero de m8>{)}

{Descripci¢n:}

Elimina la ventana de modo 8 cuyo n£mero (del 0 al 9) se pasa como par metro.
Este <n£mero de m8> es el que se indic¢ como primer par metro en la funci¢n
{#190,start_mode8()}, es necesario debido a que pueden haber hasta 10 ventanas
diferentes de modo 8, y el sistema necesita saber cu l de ellas se est 
finalizando.

{/}

{Nota:} Crear una ventana de modo 8 es un procedimiento avanzado y requiere
iniciar varios par metros, como en este caso la c mara, algunos de ellos
requeridos por la funci¢n {#190,start_mode8()} y otros contenidos en la
{#1411,estructura global m8} (como la variable {m8.camera}).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_stop_mode8;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  write(0,0,0,0,"Pulse ESC para finalizar ...");
  REPEAT
      FRAME;
  UNTIL (key(_esc));

  stop_mode8(0); // Elimina la regi¢n n£mero 0 de modo 8

END
{-}

Este programa muestra un ejemplo de inicializaci¢n de una regi¢n de modo 8,
cargando el mapa contenido en el archivo {wld_view.prg}, e inicializando una
regi¢n (la n£mero {0}) con {#190,start_mode8()}.

El programa espera en un bucle hasta detectar la tecla {ESC}, momento en
el que sale del mismo y elimina esta regi¢n con {stop_mode8()}.

{/}Ver: {#190,start_mode8()} - {1411,STRUCT m8} - {#189,load_wld()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.183,xadvance()}

{xadvance(}<angulo>{,} <distancia>{)}

{Descripci¢n:}

Avanza el proceso {en el  ngulo indicado} tantos puntos como indique {la distancia indicada} como par metro.

Esta funci¢n equivale a la funci¢n {#101,advance()}, si se utiliza la variable {#1129,angle} como primer par metro.

La distancia puede ser tambi‚n un n£mero negativo, con lo cual el gr fico
del proceso avanzar  (sus coordenadas {#1123,x} e {#1124,y}) en la direcci¢n
contraria a este  ngulo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_xadvance;

PRIVATE
  angle2;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=101;
    x=160;
    y=100;
    write(0, 0, 0, 0, "Use los cursores para cambiar la direcci¢n.");
    LOOP
        angle+=5000;
        IF (key(_right)) angle2-=10000; END
        IF (key(_left)) angle2+=10000; END

        advance(angle2,4); // Avanzamos dos puntos el proceso

        FRAME;
    END
END
{-}

Este ejemplo dibujar  un tri ngulo en pantalla que avanzar  en la direcci¢n
seleccionada con los cursores, independiente en todo momento de la orientaci¢n del gr fico en
pantalla (del  ngulo de visualizaci¢n del mismo).

Se recuerda que el  ngulo se especifica en mil‚simas de grado.

{/}Ver: {#1044,Uso de  ngulos en el lenguaje} - {#101,advance()} - {#118,get_distx()} - {#119,get_disty()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.184,char()}

{char(}<literal>{)}

{Retorna:}

El valor {ASCII} del (primer) car cter contenido en el literal.

{Descripci¢n:}

La funci¢n {char()} sirve para obtener el valor ordinal de un car cter

{#9999,Programa ejemplo:}
PROGRAM ejemplo_char;
PRIVATE valor;
BEGIN
  // ..
  valor="A";       // Se asigna la direcci¢n del literal "A" en memoria.
  // ..
  valor=char("A"); // Se asigna el valor ASCII de "A" (65 en decimal).
  // ..
END
{-}

En un programa, los literales (textos entre comillas) se traducen como la
direcci¢n de memoria en la que se han almacenado los mismos. Para asignar a una
variable un car cter (su valor ordinal), en lugar de la direcci¢n de la cadena,
se debe utilizar esta funci¢n.

Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.185,path_find()}

{path_find(}<modo>{,} <fichero>{,} <gr fico>{,} <tama¤o casilla>{,} <x>{,} <y>, <OFFSET estructura>{,} <sizeof(estructura)>{)}

{Retorna:}

N£mero de puntos de la ruta, o 0 si no se encontr¢ ninguna.

{Descripci¢n:}

Busca una ruta desde las coordenadas actuales del proceso hasta un
punto determinado, sorteando los obst culos definidos en un mapa de b£squeda
(en el manual de usuario se puede encontrar informaci¢n sobre estos mapas).

{El modo.}

Se puede realizar la b£squeda de diferente forma, seg£n el {<modo>} indicado
como primer par metro de la funci¢n.

  {0} - B£squeda menos precisa y m s r pida.ú
  {1} - B£squeda m s precisa, pero m s lenta.ú

{El mapa de b£squeda.}

Los c¢digos de {<fichero>} y {<gr fico>} se refieren al mapa de b£squeda. Este
es una versi¢n reducida del decorado real, donde se aparecen en {color negro}
(el n£mero 0 de la paleta) las zonas libres y con {color blanco} los obst culos
del mismo.

Como {<tama¤o casilla>} se indica el factor de reducci¢n del mapa de b£squeda,
es decir, por cuanto se tendr¡an que multiplicar el ancho y alto del mismo para
mostrarse a tama¤o real. Por ejemplo, si para una pantalla de 320x200 se genera
un mapa de b£squeda de 160x100, entonces el tama¤o de casilla ser  2.

{Los puntos de la ruta.}

A continuaci¢n se deben indicar las coordenadas {<x>} e {<y>} hacia las que debe
dirigirse el proceso (se toma como origen de la ruta las coordenadas actuales del
proceso que ejecute la funci¢n {path_find()}).

Esta funci¢n retorna una serie de puntos en una estructura, estos son los
puntos que conforman la ruta desde el origen hasta el punto destino.

Por ello se debe declarar una estructura que contenga dos campos (x,y),
y tantos registros como puntos puedan conformar la ruta calculada.

A la funci¢n se le debe pasar, como los dos £ltimos par metros, la direcci¢n ({#1085,OFFSET}) de
esta estructura y su tama¤o ({#1094,SIZEOF()}), de forma que pueda devolver el resultado
en la misma.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_path_find;

GLOBAL
    num_puntos;
    STRUCT puntos[100]
      x,y;
    END
    ¡ndice;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 7);
    graph=200;
    mouse.graph=200;
    LOOP

        // Obtiene la ruta hasta las coordenadas del rat¢n

        num_puntos=path_find(0,0,201,2,mouse.x,mouse.y,OFFSET puntos,sizeof(puntos));

        // Si se obtuvo una ruta, se muestra y se avanza hasta el destino

        IF (num_puntos>0)
            FOR (¡ndice=0;¡ndice<num_puntos-1;¡ndice++)
                draw(1,24,15,0,puntos[¡ndice].x,puntos[¡ndice].y,puntos[¡ndice+1].x,puntos[¡ndice+1].y);
            END
            IF (fget_dist(x,y,puntos[0].x,puntos[0].y)>4)
                xadvance(fget_angle(x,y,puntos[0].x,puntos[0].y),4);
            ELSE
                x=puntos[0].x;
                y=puntos[0].y;
            END
            draw(1,24,15,0,x,y,puntos[0].x,puntos[0].y);
        END

        FRAME;
        delete_draw(all_drawing);
    END
END
{-}

En este ejemplo se utiliza el {gr fico n£mero 7} del fichero {help.fpg} como
decorado, y el {gr fico n£mero 201} del mismo como su {mapa de b£squeda}.

El tama¤o de las casillas en el mapa de b£squeda es {2}

El proceso principal est  continuamente obteniendo una ruta hasta el puntero
del rat¢n con la funci¢n {path_find()}.

Los diferentes segmentos de esta ruta se representas con l¡neas utilizando la
funci¢n {#249,draw()}, y el incremento de las coordenadas se realiza con la
funci¢n {#183,xadvance()}.

Para obtener la distancia y el  ngulo hacia el siguiente punto de la ruta se
utilizan las funciones {#114,fget_dist()} y {#113,fget_angle()}.

{/}

Para ver si se puede ir directamente en l¡nea recta entre dos puntos (sin
atravesar ning£n obst culo) se puede utilizar la funci¢n {#186,path_line()}.

La funci¢n {#187,path_free()} determina si un punto determinado del mapa es
un obst culo o si es un punto libre (accesible).

{/}Ver: {#186,path_line()} - {#187,path_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.186,path_line()}

{path_line(}<fichero>{,} <gr fico>{,} <tama¤o casilla>{,} <x>{,} <y>{)}

{Retorna:}

{#1151,True (1)}, si se puede ir hasta un punto sin atravesar ning£n obst culo,
o {#1152,false (0)} en caso contrario.

{Descripci¢n:}

Determina si, dentro de un mapa de b£squeda, se puede ir en linea recta hasta
un punto (partiendo de las coordenadas actuales del proceso), sin atravesar
ning£n obst culo del mapa de b£squeda (en el manual de usuario se puede encontrar
informaci¢n sobre estos mapas).

En caso de querer obtener una ruta para sortear los obst culos entre dos puntos,
se debe utilizar la funci¢n {#185,path_find()}, y para ver si el punto destino
est  dentro de un obst culo la funci¢n {#187,path_free()}.

{El mapa de b£squeda.}

Los c¢digos de {<fichero>} y {<gr fico>} se refieren al mapa de b£squeda. Este
es una versi¢n reducida del decorado real, donde se aparecen en {color negro}
(el n£mero 0 de la paleta) las zonas libres y con {color blanco} los obst culos
del mismo.

Como {<tama¤o casilla>} se indica el factor de reducci¢n del mapa de b£squeda,
es decir, por cuanto se tendr¡an que multiplicar el ancho y alto del mismo para
mostrarse a tama¤o real. Por ejemplo, si para una pantalla de 320x200 se genera
un mapa de b£squeda de 160x100, entonces el tama¤o de casilla ser  2.

A continuaci¢n se deben indicar las coordenadas {<x>} e {<y>} hacia las que debe
dirigirse el proceso (se toma como origen de la ruta las coordenadas actuales del
proceso que ejecute la funci¢n {path_find()}).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_path_line;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 7);
    graph=200;
    mouse.graph=200;
    LOOP

        // Mira si puede ir en l¡nea recta hacia el rat¢n

        IF (path_line(0,201,2,mouse.x,mouse.y))

            IF (fget_dist(x,y,mouse.x,mouse.y)>4)
                xadvance(fget_angle(x,y,mouse.x,mouse.y),4);
                draw(1,24,15,0,x,y,mouse.x,mouse.y);
            ELSE
                x=mouse.x;
                y=mouse.y;
            END
        END

        FRAME;
        delete_draw(all_drawing);
    END
END
{-}

En este ejemplo se utiliza el {gr fico n£mero 7} del fichero {help.fpg} como
decorado, y el {gr fico n£mero 201} del mismo como su {mapa de b£squeda}. El
tama¤o de las casillas en el mapa de b£squeda es {2}

El proceso principal est  continuamente comprobando si se puede ir en l¡nea
recta hsata las coordenadas del rat¢n con la funci¢n {path_line()}. Cuando
esto sea posible, se traza la l¡nea con la funci¢n {#249,draw()}, y se avanzan
las coordenadas del proceso con la funci¢n {#183,xadvance()}.

Para obtener la distancia y el  ngulo hacia el cursor del rat¢n se
utilizan las funciones {#114,fget_dist()} y {#113,fget_angle()}.

{/}Ver: {#185,path_find()} - {#187,path_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.187,path_free()}

{path_free(}<fichero>{,} <gr fico>{,} <tama¤o casilla>{,} <x>{,} <y>{)}

{Retorna:}

{#1151,True (1)}, si un punto est  libre (no es un obst culo) en un mapa
de b£squeda, o {#1152,false (0)} en caso contrario.

{Descripci¢n:}

Determina si, dentro de un mapa de b£squeda, unas coordenadas est n situadas
en una zona acesible, fuera de cualquier obst culo (en el manual de usuario
se puede encontrar informaci¢n sobre estos mapas de b£squeda).

En caso de querer obtener una ruta para sortear los obst culos entre dos puntos,
se debe utilizar la funci¢n {#185,path_find()}, y para ver si se puede ir hasta
un punto en l¡nea recta sin atravesar ning£n obst culo la funci¢n {#186,path_line()}.

{El mapa de b£squeda.}

Los c¢digos de {<fichero>} y {<gr fico>} se refieren al mapa de b£squeda. Este
es una versi¢n reducida del decorado real, donde se aparecen en {color negro}
(el n£mero 0 de la paleta) las zonas libres y con {color blanco} los obst culos
del mismo.

Como {<tama¤o casilla>} se indica el factor de reducci¢n del mapa de b£squeda,
es decir, por cuanto se tendr¡an que multiplicar el ancho y alto del mismo para
mostrarse a tama¤o real. Por ejemplo, si para una pantalla de 320x200 se genera
un mapa de b£squeda de 160x100, entonces el tama¤o de casilla ser  2.

A continuaci¢n se deben indicar las coordenadas {<x>} e {<y>} a consultar.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_path_free;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 7);
    mouse.graph=200;
    mouse.size=400;
    LOOP

        // Mira si el rat¢n est  en una zona accesible

        IF (path_free(0,201,2,mouse.x,mouse.y))
            mouse.angle+=5000;
        END

        FRAME;
    END
END
{-}

En este ejemplo se utiliza el {gr fico n£mero 7} del fichero {help.fpg} como
decorado, y el {gr fico n£mero 201} del mismo como su {mapa de b£squeda}. El
tama¤o de las casillas en el mapa de b£squeda es {2}

El proceso principal est  continuamente comprobando, con la funci¢n {path_free()},
si el puntero del rat¢n se encuentra sobre una zona libre, o bien sobre un obst culo.

Cuando el cursor se encuentre en una zona libre, fuera de cualquier obst culo,
se ir  rotando su gr fico.

{/}Ver: {#185,path_find()} - {#186,path_find()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.188,new_map()}

{new_map(}<ancho>{,} <alto>{,} <centro x>{,} <centro y>{,} <color>{)}

{Retorna:}

El {c¢digo del gr fico} creado.

{Descripci¢n:}

Crea un nuevo mapa en memoria (sin cargarlo de un archivo del disco).

Para ello, la funci¢n requiere el {<ancho>} y {<alto>} (en puntos) del mapa
que se debe crear, su punto central (dentro del mismo) en {<centro x>} y {<centro y>},
y el color con el que se debe rellenar inicialmente el mapa (el n£mero de color
dentro de la paleta activa, de 0 a 255).

Esta funci¢n se comporta practicam‚nte igual que {#174,load_map()}, salvo que
no se lee un archivo en disco con el gr fico, sino que se crea como un gr fico
s¢lido de un s¢lo color.

Se devuelve como valor de retorno el {c¢digo del gr fico}, que es un valor
num‚rico que debe especificarse para utilizar el gr fico, en la variable
{#1126,graph} o, en general, en todas las funciones que requieran un {c¢digo
de gr fico} entre sus par metros.

{/}

{Importante:}

Cuando se requiera dentro de una funci¢n el {c¢digo de fichero} al que
pertenece dicho gr fico, se debe indicar el c¢digo {0} (que es el c¢digo
del primer {fichero FPG} que se cargue en el programa).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_new_map;

BEGIN

    // Se crea un mapa de 16x32 puntos
    // con su centro en el punto (0,0)
    // y con el color 15 de la paleta

    mouse.graph = new_map(16,32,0,0,15); // Se asigna como puntero del rat¢n

    REPEAT
        FRAME;
    UNTIL (key(_esc));

    unload_map(mouse.graph); // Y finalmente se libera o descarga el gr fico
END
{-}

En el ejemplo se crea un mapa con la funci¢n {new_map()} guardando
el {c¢digo del gr fico} que retorna en la variable {#1100,mouse.graph}, de
forma que aparezca como puntero del rat¢n.

Pulsando la tecla {ESC} se saldr  del bucle de visualizaci¢n del programa y
se descargar  el gr fico con la funci¢n {#176,unload_map()} (exactamente igual
que si se hubiera cargado de un archivo del disco).

{/}

La funci¢n {#176,unload_map()} permite liberar la memoria del ordenador utilizada
por el gr fico cuando ya no se va a utilizar m s durante un tiempo, y para ello
requiere tambi‚n el {codigo del gr fico} para saber qu‚ gr fico es el que se
quiere descargar de memoria.

{No es necesario descargar el gr fico de memoria} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.

{/}Ver: {#174,load_map/pcx()} - {#176,unload_map/pcx()} - {#1126,graph}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.189,load_wld()}

{load_wld(}<nombre de archivo>{,} <fichero>{)}

{Descripci¢n:}

Carga un {mapa de modo 8} en un programa. Estos mapas se guardan en los archivos
con extensi¢n WLD, y se crean con el men£ de mapas 3d (en el manual de usuario
se puede encontrar m s informaci¢n sobre como construir estos mapas).

Se requieren como par metros el {<nombre de archivo>} que contiene el mapa en
formato WLD, y el c¢digo del {<fichero>} que contiene las texturas del mismo.
Este fichero con las texturas del mapa se debe haber cargado previamente en
el programa con la funci¢n {#132,load_fpg()}.

Una vez cargado el mapa, se debe iniciar una regi¢n de pantalla de modo 8 con
la funci¢n {#190,start_mode8()}. El funcionamiento es muy similar a los modos 7
que muestran un plano abatido (ver {#162,start_mode7()}).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_wld;

GLOBAL
    fichero;

BEGIN
  set_mode(m640x480);
  set_fps(70,0);
  fichero = load_fpg("HELP\WLD_VIEW.FPG");

  load_wld("HELP\WLD_VIEW.WLD",fichero); // Carga un archivo WLD

  start_mode8(id,0,0);
  ctype=c_m8;
  height=64;
  radius=64;
  m8.height=32;
  go_to_flag(0);
  LOOP
    IF (key(_right)) angle-=5000; END
    IF (key(_left))  angle+=5000; END
    IF (key(_up))    advance(24); END
    IF (key(_down))  advance(-9); END
    IF (key(_q))     z+=16;       END
    IF (key(_a))     z-=16;       END
    IF (key(_w))     m8.angle+=8; END
    IF (key(_s))     m8.angle-=8; END
    FRAME;
  END
END
{-}

Este programa muestra un ejemplo de inicializaci¢n de una regi¢n de modo 8,
cargando el mapa contenido en el archivo {wld_view.prg}, y cuyas texturas se
encuentran en el fichero {wld_view.fpg}.

{/}Ver: {#190,start_mode8()} - {#191,go_to_flag()} - {#132,load_fpg()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.190,start_mode8()}

{start_mode8(}<identificador de la c mara>{,} <n£mero de m8>{,} <n£mero de regi¢n>{)}

{Descripci¢n:}

sta es una funci¢n avanzada que requiere que el usuario tenga cierta
experiencia para poder utilizarla.

Crea una ventana de visualizaci¢n de un modo 8, es decir, visualiza un mapa
de sectores tridimensional; {en primer lugar se debe cargar el mapa con la
funci¢n} {#189,load_wld()}, y entonces a esta funci¢n con los siguientes
par metros:

{<identificador de la c mara>} - {#1039,C¢digo identificador} del proceso
en cuya posici¢n debe situarse la c mara del modo 8, la c mara se situar 
en las coordenadas {(x,y)}, a la altura {(z)} y mirando en la direcci¢n
indicada por {(angle)} (todos son {#1201,datos locales predefinidos} del
proceso).

{<n£mero de m8>} - Se pueden crear hasta 10 ventanas de modo 8 en pantalla,
con los n£mero del {0} al {9}; si £nicamente se quiere crear una, lo mejor
es definir la n£mero {0}. Este n£mero ser  necesario posteriormente para
modificar los par metros de la ventana, pues el sistema necesitar  saber
cu l de las {10} posibles ventanas de modo 8 se quiere alterar.

{<n£mero de regi¢n>} - Aqu¡ se indicar  la regi¢n rectangular de pantalla
en la que se va a mostrar el modo 8. Si se indica {0} como n£mero de regi¢n,
se mostrar  en toda la pantalla. El resto de regiones se deben definir
previamente con la funci¢n {#106,define_regi¢n()} (una {regi¢n} no es m s
que una zona rectangular de la pantalla).

{Nota:} El funcionamiento es muy similar a los modos 7 que muestran un plano
abatido (ver {#162,start_mode7()}).

{/}

{Adem s de la llamada a la funci¢n se deben inicializar algunos valores de
la} {#1411,estructura global m8} {para el correcto funcionamiento de la ventana}.
sta es una estructura de 10 registros (uno para cada posible ventana de modo 8)
y cada registro tiene los siguientes campos:

  {camera}   - {#1039,C¢digo identificador} de la c maraú
  {height}   - Altura de la c mara respecto al procesoú
  {angle}    - Angulo vertical de la c mara (-128,128)ú
  {z}        - Plano de profundidad (prioridad de impresi¢n de la regi¢n)ú

El campo {camera} es {imprescindible}, por ello se solicita como uno de los
par metros de llamada de la funci¢n {start_mode8()} ya que, sin este campo, la
ventana no puede determinar desde d¢nde se debe {ver} el mapa.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_start_mode8;

GLOBAL
    fichero;

BEGIN
  set_mode(m640x480);
  set_fps(70,0);
  fichero = load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",fichero);

  start_mode8(id,0,0); // Inicializa una regi¢n de modo 8

  ctype=c_m8;
  height=64;
  radius=64;
  m8.height=32;
  go_to_flag(0);
  LOOP
      IF (key(_right)) angle-=5000; END
      IF (key(_left))  angle+=5000; END
      IF (key(_up))    advance(24); END
      IF (key(_down))  advance(-9); END
      IF (key(_q))     z+=16;       END
      IF (key(_a))     z-=16;       END
      IF (key(_w))     m8.angle+=8; END
      IF (key(_s))     m8.angle-=8; END
      FRAME;
  END
END
{-}

Este programa muestra un ejemplo de inicializaci¢n de una regi¢n de modo 8,
cargando el mapa contenido en el archivo {wld_view.prg}, y cuyas texturas se
encuentran en el fichero {wld_view.fpg}.

{/}

Para crear un proceso cuyo gr fico se visualice en el modo 8, se debe
definir su variable local {#1122,ctype} como {#1412,c_m8} ({tipo de coordenada}
como {coordenada de modo 8}).

Cuando un proceso pertenezca al modo 8 sus variables {#1123,x} e {#1124,y}
estar n referidas al punto dentro del mapa de sectores (WLD), y su variable
{#1125,z} indicar  la altura.

Si hubiera varias ventanas de {modo 8} el proceso se visualizar¡a por defecto
en todas, si £nicamente se tuviera que visualizar el algunas de ellas, se deber¡a
definir su variable local {#1134,cnumber}.

Para que un proceso tenga varios gr ficos (varias vistas), dependiendo
del  ngulo desde el que se le mire, se debe definir su gr fico con la
variable local {#1132,xgraph} (en lugar de la variable {#1126,graph}).

{/}

{Nota:} Para eliminar una regi¢n de modo 8 se debe utilizar la funci¢n
{#182,stop_mode8()}, a la que se le debe indicar el {n£mero de m8}.

{/}Ver: {#1411,STRUCT m8} - {#189,load_wld()} - {#191,go_to_flag()} - {#182,stop_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.191,go_to_flag()}

{go_to_flag(}<n£mero de bandera>{)}

{Descripci¢n:}

Posiciona un proceso de un modo 8 en una bandera, el propio proceso que
quiere situarse en dicha posici¢n es el que debe llamar a la funci¢n, y como
£nico par metro se debe indicar el {<n£mero de bandera>}.

Tras llamar a la funci¢n el proceso se situar , en el pr¢ximo {#1029,FRAME},
en las coordenadas de la bandera. La altura de la bandera siempre se entiende
como la altura m¡nima del sector en el que se encuentre.

Las banderas se sit£an en el editor de mapas tridimensionales, cuyo manejo
est  explicado en el manual de usuario del programa.

{Nota:} Esta funci¢n equivale simplemente a asignarle al proceso las
coordenadas de esta bandera a sus coordenadas ({x},{y},{z}). La ventaja que
proporciona, es el poder situar directamente en el editor la posici¢n
de determinados objetos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_go_to_flag;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;

  go_to_flag(0); // Sit£a el proceso c mara en la bandera 0

  LOOP
      FRAME;
  END
END
{-}

Este programa ejemplo inicializa de una regi¢n de modo 8 cargando el mapa
contenido en el archivo {wld_view.prg} con la funci¢n {#189,load_wld()},
e inicializa una regi¢n con {#190,start_mode8()}.

Entonces sit£a al proceso (que act£a como c mara de la ventana) en la
posici¢n indicada por la bandera n£mero 0 del mapa de sectores.

{/}Ver: {#190,start_mode8()} - {#1411,STRUCT m8} - {#189,load_wld()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.192,set_sector_height()}

{set_sector_height(}<n£mero de sector>{,} <altura del suelo>{,} <altura del techo>{)}

{Descripci¢n:}

Modifica la altura del {suelo} o {techo} de un sector de un modo 8. Se requieren
los siguientes par metros:

{<n£mero de sector>} - N£mero de sector del mapa cuyas alturas se quieren
modificar. Este n£mero se puede obtener en el editor de mapas tridimensionales,
cuyo manejo se aborda en el manual de usuario del programa.

{<altura del suelo>} - Se debe indicar la nueva altura del suelo del sector
(un valor entre 0 y 4096), si se indica{ -1} como par metro, se mantendr  la
altura actual del suelo del sector (£til para modificar s¢lo la altura del techo).

{<altura del techo>} - Se debe indicar la nueva altura del techo del sector
(un valor entre 0 y 4096), si se indica{ -1} como par metro, se mantendr  la
altura actual del techo del sector (£til para modificar s¢lo la altura del suelo).

Para iniciar una regi¢n de modo 8, se debe llamar a la funci¢n {#190,start_mode8()}.

{/}

{Nota:} Si la altura del techo es igual a la del suelo, no se podr  entrar en
dicho sector (si este est  dentro de otro, aparecer  como una columna). La altura
del techo no debe ser inferior a la altura del suelo.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_sector_height;

GLOBAL
    sector=255;
    altura;
     ngulo1;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=64;
    LOOP
        altura=1000+get_distx( ngulo1,64);
         ngulo1+=5000;

        set_sector_height(sector,altura,-1);

        FRAME;
    END
END
{-}

Este peque¤o ejemplo inicializa una regi¢n de modo 8, cargando el mapa
{wld_view.wld}, y se sit£a en unas coordenadas predeterminadas con la
funci¢n {#191,go_to_flag()}.

Posteriormente, dentro del bucle principal del programa, se fija la altura
del suelo del sector n£mero {255} con la funci¢n {set_sector_height()}.

{/}

La funci¢n {#193,get_sector_height()} permite averiguar las alturas de suelo
y techo de un sector de un modo 8.

{/}Ver: {#193,get_sector_height()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.193,get_sector_height()}

{get_sector_height(}<n£mero de sector>{,} <OFFSET suelo>{,} <OFFSET techo>{)}

{Retorna:}

La {altura de suelo y techo} de un sector de un modo 8 (en las variables cuyo
{#1085,offset} se indica como los dos £ltimos par metros).

{Descripci¢n:}

Esta funci¢n permite determinar dentro de un programa la altura del suelo
y techo de un sector determinado, dentro de un modo 8.

Para ello se requiere el {<n£mero de sector>}, y el {#1085,OFFSET} (direcci¢n
de memoria) de las dos variables en las que debe devolver el resultado.

Esta informaci¢n tambi‚n puede obtenerse dentro del editor de mapas
tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_sector_height;

GLOBAL
    altura_techo;
    altura_suelo;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtiene las alturas de un sector

    get_sector_height(255,OFFSET altura_suelo,OFFSET altura_techo);

    // ...
END
{-}

Este peque¤o ejemplo muestra como debe llamarse a la funci¢n {get_sector_height()}
para obtener las alturas de un sector (en este caso, en las variables {altura_techo}
y {altura_suelo} se obtiene estos valores para el sector n£mero {255}).

{/}

Para establecer din micamente las alturas de un sector se debe utilizar la
funci¢n {#192,set_sector_height()}.

{/}Ver: {#192,set_sector_height()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.194,set_point_m8()}

{set_point_m8(}<n£mero de v‚rtice>{,} <x>{,} <y>{)}

{Descripci¢n:}

Modifica las coordenadas de un v‚rtice de un mapa tridimensional de modo 8.
Se requieren los siguientes par metros:

{<n£mero de v‚rtice>} - N£mero de v‚rtice del mapa cuya posici¢n se quiere
modificar. Este n£mero se puede obtener en el editor de mapas tridimensionales,
cuyo manejo se aborda en el manual de usuario del programa.

{<x>}, {<y>} - Se debe indicar las nuevas coordenadas del v‚rtice. Las
coordenadas dentro de un mapa tridimensional se situan dentro del rango ({0} ..
{30200}).

Para iniciar una regi¢n de modo 8, se debe llamar a la funci¢n {#190,start_mode8()}.

{/}

{Nota:} Esta es una funci¢n cuya utilizaci¢n puede desembocar en m£ltiples
{errores de visibilidad}. Por ello, no se recomienda su utilizaci¢n a usuarios
con poca experiencia.

Los v‚rtices £nicamente se pueden mover {dentro del sector} en el que se encuentren,
{no se pueden cruzar} (ni los v‚rtices, ni las l¡neas que estos forman) y, adem s,
no se deben mover sectores que puedan contener procesos en su interior.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_point_m8;

GLOBAL
    posici¢n1;
    posici¢n2;
     ngulo1;
     ngulo2;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=64;
    LOOP
        posici¢n1=3400+get_distx( ngulo1,150);
         ngulo1+=5000;
        posici¢n2=3400+get_distx( ngulo2,150);
         ngulo2+=7000;

        set_point_m8(1620,posicion1,9280); // Fija el v‚rtice 1620

        set_point_m8(1621,posicion2,9456); // Fija el v‚rtice 1621

        FRAME;
    END
END
{-}

Este peque¤o ejemplo inicializa una regi¢n de modo 8, cargando el mapa
{wld_view.wld}, y se sit£a en unas coordenadas predeterminadas con la
funci¢n {#191,go_to_flag()}.

Posteriormente, dentro del bucle principal del programa, se fija la posici¢n
de los v‚rtices {1620} y {1621} con la funci¢n {set_point_m8()}.

{/}

La funci¢n {#195,get_point_m8()} permite averiguar las coordenadas de un v‚rtice
de un mapa tridimensional para modo 8.

{/}Ver: {#195,get_point_m8()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.195,get_point_m8()}

{get_point_m8(}<n£mero de v‚rtice>{,} <OFFSET x>{,} <OFFSET y>{)}

{Retorna:}

Las {coordenadas de un v‚rtice} de un mapa de modo 8 (en las variables cuyo
{#1085,offset} se indica como los dos £ltimos par metros).

{Descripci¢n:}

Esta funci¢n permite determinar dentro de un programa las coordenadas de
un v‚rtice determinado, dentro de un modo 8.

Para ello se requiere el {<n£mero de v‚rtice>}, y el {#1085,OFFSET} (direcci¢n
de memoria) de las dos variables en las que debe devolver el resultado.

Esta informaci¢n tambi‚n puede obtenerse dentro del editor de mapas
tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_point_m8;

GLOBAL
    posici¢n_x;
    posici¢n_y;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtiene las coordenadas de un v‚rtice

    get_point_m8(1620,OFFSET posici¢n_x,OFFSET posici¢n_y);

    // ...
END
{-}

Este peque¤o ejemplo muestra como debe llamarse a la funci¢n {get_point_m8()}
para obtener las alturas de un sector (en este caso, en las variables {posici¢n_x}
y {posici¢n_y}).

{/}

Para establecer din micamente las posici¢n de un v‚rtice se debe utilizar la
funci¢n {#194,set_point_m8()}.

{/}Ver: {#194,set_point_m8()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.196,set_fog()}

{set_fog(}<posici¢n inicio>{,} <posici¢n final>{)}

{Descripci¢n:}

Modifica la niebla de un modo 8 iniciado con la funci¢n {#190,start_mode8()},
para ello se requieren los siguientes par metros:

{<posici¢n inicio>} - Porcentaje o distancia inicial de la niebla (de 0 a 100),
de esta forma se determina a partir de que punto se comienza a aplicar el efecto.

{<posici¢n final>} - Porcentaje o distancia final de la niebla (de 0 a 100),
de esta forma se determina a partir de que punto la niebla ser  completamente
opaca.

Normalmente se suele establecer la posici¢n o porcentaje final como el doble
del inicial, cuanto m s distanciados est‚n ambos valores, m s l‚ntamente se
ir  introduciendo la niebla.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_fog;

GLOBAL
    niebla;
     ngulo1;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  FRAME;
  z+=128;
  LOOP
      niebla=25+get_distx( ngulo1,20);
       ngulo1+=5000;

      set_fog(niebla,niebla*2); // Establece el nivel de niebla del modo 8

      FRAME;
  END
END
{-}

Este peque¤o ejemplo muestra como debe llamarse a la funci¢n {set_fog()}
para modificar la niebla de una regi¢n de modo 8.

La variable {niebla} se va variando entre {5} y {45} (utilizando la funci¢n
{#118,get_distx()}), este ser  la posici¢n inicial, la final se fijar 
siempre el doble que esta.

{/}

{Nota:} La funci¢n {#201,set_env_color()} permite fijar el color ambiente
o de niebla de una regi¢n de modo 8.

{/}Ver: {#201,set_env_color()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.197,set_sector_texture()}

{set_sector_texture(}<n£mero de sector>{,} <textura suelo>{,} <textura techo>{,} <luminosidad>{)}

{Descripci¢n:}

Modifica las {texturas de suelo y techo} de un sector de un modo 8. Se requieren
los siguientes par metros:

{<n£mero de sector>} - N£mero de sector del mapa cuyas texturas se quieren
modificar. Este n£mero se puede obtener en el editor de mapas tridimensionales,
cuyo manejo se aborda en el manual de usuario del programa.

{<textura del suelo>} - Se debe indicar c¢digo del gr fico que se desea
asignar como nueva {textura del suelo} del sector (el n£mero de gr fico dentro
del FPG que contiene todas las texturas del modo 8). Si se indica{ -1} como
par metro, se mantendr  la textura actual (para modificar s¢lo la del techo).

{<textura del techo>} - Se debe indicar c¢digo del gr fico que se desea
asignar como nueva {textura del techo} del sector (el n£mero de gr fico dentro
del FPG que contiene todas las texturas del modo 8). Si se indica{ -1} como
par metro, se mantendr  la textura actual (para modificar s¢lo la del suelo).

{<luminosidad>} - Luminosidad de la textura, de {0} (color de ambiente, que
normalmente es de color negro) hasta {15} (textura con los colores originales).
Si se indica{ -1} se mantendr  el nivel de luminosidad actual del sector.

{/}

{Nota:} Todas las texturas deben estar contenidas en un mismo archivo FPG,
este es el archivo que se carga con {#132,load_fpg()} y cuyo n£mero se pasa
como par metro a la funci¢n {#189,load_wld()}.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_sector_texture;

GLOBAL
    textura=94;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=128;
    m8.angle=-64;
    LOOP
        IF (textura++==103) textura=94; END

        set_sector_texture(255,textura,-1,15);

        FRAME;
    END
END
{-}

Este peque¤o ejemplo inicializa una regi¢n de modo 8, cargando el mapa
{wld_view.wld}, y se sit£a en unas coordenadas predeterminadas con la
funci¢n {#191,go_to_flag()}.

Posteriormente, dentro del bucle principal del programa, se fija la textura
del suelo del sector n£mero {255} con la funci¢n {set_sector_texture()}.

{/}

La funci¢n {#198,get_sector_texture()} permite averiguar cuales son las texturas
(y luminosidad) que tiene un sector de modo 8.

La funci¢n {#199,set_wall_texture()} permite establecer la textura de una pared.

{/}Ver: {#198,get_sector_texture()} - {#199,set_wall_texture()} - {#192,set_sector_height()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.198,get_sector_texture()}

{get_sector_texture(}<n£mero de sector>{,} <OFFSET textura suelo>{,} <OFFSET textura techo>{,} <OFFSET luminosidad>{)}

{Retorna:}

La {luminosidad, y las texturas del suelo y techo} de un sector de un modo 8
(en las variables cuyo {#1085,offset} se indica en los par metros).

{Descripci¢n:}

Esta funci¢n permite determinar dentro de un programa cuales son las texturas
de suelo y techo o la luminosidad de un sector determinado, dentro de un modo 8.

Para ello se requiere el {<n£mero de sector>}, y el {#1085,OFFSET} (direcci¢n
de memoria) de las variables en las que debe devolver el resultado.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_sector_texture;

GLOBAL
    textura_suelo;
    textura_techo;
    luminosidad;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtiene la luminosidad y texturas de un sector

    get_sector_texture(255,OFFSET textura_suelo,OFFSET textura_techo,OFFSET luminosidad);

    // ...
END
{-}

Este peque¤o ejemplo muestra como debe llamarse a la funci¢n {get_sector_texture()}
para obtener las texturas y luminosidad de un sector (en este caso, en las variables
{textura_techo}, {textura_suelo} y {luminosidad} se obtiene estos valores para
el sector n£mero {255}).

{/}

La funci¢n {#197,set_sector_texture()} permite establecer las texturas y
luminosidad de un sector de modo 8 din micamente.

La funci¢n {#200,get_wall_texture()} permite averiguar cual es la textura de
una pared de un modo 8.

{/}Ver: {#197,set_sector_texture()} - {#200,get_wall_texture()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.199,set_wall_texture()}

{set_wall_texture(}<n£mero de sector>{,} <textura>{,} <luminosidad>{)}

{Descripci¢n:}

Modifica la {textura de una pared} de un modo 8. Se requieren
los siguientes par metros:

{<n£mero de pared>} - N£mero de pared del mapa cuya textura se quiere
modificar. Este n£mero se puede obtener en el editor de mapas tridimensionales,
cuyo manejo se aborda en el manual de usuario del programa.

{<textura>} - Se debe indicar c¢digo del gr fico que se desea
asignar como nueva textura de la pared (el n£mero de gr fico dentro
del FPG que contiene todas las texturas del modo 8). Si se indica{ -1} como
par metro, se mantendr  la textura actual.

{<luminosidad>} - Luminosidad de la textura, de {0} (color de ambiente, que
normalmente es de color negro) hasta {15} (textura con los colores originales).
Si se indica{ -1} se mantendr  el nivel de luminosidad actual.

{/}

{Nota:} Todas las texturas deben estar contenidas en un mismo archivo FPG,
este es el archivo que se carga con {#132,load_fpg()} y cuyo n£mero se pasa
como par metro a la funci¢n {#189,load_wld()}.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_wall_texture;

GLOBAL
    textura=104;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=128;
    LOOP
        IF (textura++==113) textura=104; END

        set_wall_texture(511,textura,15); // Modifica la textura de una pared

        FRAME;
    END
END
{-}

Este peque¤o ejemplo inicializa una regi¢n de modo 8, cargando el mapa
{wld_view.wld}, y se sit£a en unas coordenadas predeterminadas con la
funci¢n {#191,go_to_flag()}.

Posteriormente, dentro del bucle principal del programa, se fija la textura
de la pared n£mero {255} con la funci¢n {set_wall_texture()}.

{/}

La funci¢n {#200,get_wall_texture()} permite averiguar cual es la textura
de una pared.

La funci¢n {#197,set_sector_texture()} permite establecer las {texturas de
suelo y techo} de un sector de modo 8.

{/}Ver: {#200,get_wall_texture()} - {#197,set_sector_texture()} - {#192,set_sector_height()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.200,get_wall_texture()}

{get_wall_texture(}<n£mero de pared>{,} <OFFSET textura>{,} <OFFSET luminosidad>{)}

{Retorna:}

La {luminosidad y la textura} de una pared de un modo 8 (en las variables
cuyo {#1085,offset} se indica en los par metros).

{Descripci¢n:}

Esta funci¢n permite determinar dentro de un programa cual es la textura
y luminosidad de una pared determinada, dentro de un modo 8.

Para ello se requiere el {<n£mero de pared>}, y el {#1085,OFFSET} (direcci¢n
de memoria) de las variables en las que debe devolver el resultado.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_wall_texture;

GLOBAL
    textura;
    luminosidad;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtiene la luminosidad y textura de una pared

    get_wall_texture(255,OFFSET textura,OFFSET luminosidad);

    // ...
END
{-}

Este peque¤o ejemplo muestra como debe llamarse a la funci¢n {get_wall_texture()}
para obtener la textura y luminosidad de un sector (en este caso, en las variables
{textura} y {luminosidad} se obtiene estos valores para la pared n£mero {255}).

{/}

La funci¢n {#199,set_wall_texture()} permite establecer la textura y
luminosidad de una pared de modo 8 din micamente.

La funci¢n {#198,get_sector_texture()} permite averiguar cuales son las texturas
de suelo y techo de un sector de un modo 8.

{/}Ver: {#199,set_wall_texture()} - {#198,get_sector_texture()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.201,set_env_color()}

{set_env_color(}<% red>{,} <% green>{,} <% blue>{)}

{Descripci¢n:}

Modifica el color del ambiente o niebla de un modo 8, para ello se requieren
las componentes {<red>} (rojo), {<green>} (verde) y {<blue>} (azul) del mismo.

Las tres componentes se deben especificar como un porcentaje, de {0} a {100}.

Por defecto la niebla se establece de color negro (0,0,0), pero se puede
modificar este color para crear ambientes distintos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_env_color;

GLOBAL
    luz;
     ngulo1;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  FRAME;
  set_fog(30,90);
  z+=128;
  LOOP
      luz=50+get_distx( ngulo1,50);
       ngulo1+=5000;

      set_env_color(luz,luz,luz); // Establece el color ambiente

      FRAME;
  END
END
{-}

Este peque¤o ejemplo muestra como debe llamarse a la funci¢n {set_env_color()}
para modificar el color de la niebla de una regi¢n de modo 8.

La variable {luz} se va variando entre {0} y {100} (utilizando la funci¢n
{#118,get_distx()}), y se fija este mismo porcentaje para las tres componentes
del color, de forma que este aparecer  entre {negro} y {blanco}, pasando por
toda la escala de grises.

{/}

{Nota:} La funci¢n {#196,set_fog()} permite fijar la densidad de la niebla
o ambiente de una regi¢n de modo 8.

{/}Ver: {#196,set_fog()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.202,strcpy()}

{strcpy(}<cadena destino>{,} <cadena origen>{)}

{Retorna:}

Copia una cadena y retorna la direcci¢n de la cadena destino.

{Descripci¢n:}

Copia la {<cadena origen>} sobre la {<cadena destino>}, a partir de su
inicio (se perder  el contenido de anterior de esta £ltima).

La {<cadena destino>} debe ser un dato de tipo {#1406,STRING}, de una longitud
suficiente como para contener el texto de la {<cadena origen>}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strcpy;

GLOBAL
    STRING cadena1="Texto inicial";

BEGIN
    write(0,0,0,0,"Texto contenido en <cadena1>:");
    write(0,0,10,0,cadena1);
    write(0,0,192,0,"Pulse [ESPACIO] para copiar otro texto en <cadena1>");
    LOOP
        IF (key(_space))

            strcpy(cadena1,"Texto final"); // Modifica cadena1

        END
        FRAME;
   END
END
{-}

{/}

Cuando la longitud de la cadena copiada sea menor de 1024 car cteres, se
podr  realizar esta misma operaci¢n con una sentencia como la siguiente
(continuando con el ejemplo anterior):

  {cadena1 = "Texto final";}

Es decir, con una sentencia gen‚rica de {#1019,asignaci¢n} como la siguiente:

  {<cadena destino> = <cadena origen> ;}

Siendo siempre {<cadena destino>} un dato de tipo {#1406,STRING}. Para unir varias
cadenas de texto en una sola se debe utilizar la funci¢n {#203,strcat()}.

{/}Ver: {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.203,strcat()}

{strcat(}<cadena destino>{,} <cadena origen>{)}

{Retorna:}

Concatena (une) dos cadenas y retorna la direcci¢n de la cadena destino.

{Descripci¢n:}

Une dos cadenas de texto, copiando la {<cadena origen>} a continuaci¢n
del texto contenido en la {<cadena destino>}.

La {<cadena destino>} debe ser un dato de tipo {#1406,STRING}, de una longitud
suficiente como para contener ambas cadenas.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strcat;

GLOBAL
    STRING cadena1="Inicio ";

BEGIN
    write(0,0,0,0,"Texto contenido en <cadena1>:");
    write(0,0,10,0,cadena1);
    write(0,0,192,0,"Pulse [ESPACIO] para a¤adir un texto a <cadena1>");
    LOOP
        IF (key(_space))

            strcat(cadena1,"Final"); // Suma un texto a cadena1

        END
        FRAME;
   END
END
{-}

{/}

Cuando la longitud de la cadena resultante de la suma de ambas sea menor de 1024
car cteres, se podr  realizar esta misma operaci¢n con una sentencia como la siguiente
(continuando con el ejemplo anterior):

  {cadena1 = cadena1 + "Final";}

  (o bien)

  {cadena1 += "Final";}

Es decir, con una sentencia gen‚rica de {#1019,asignaci¢n} (o con el s¡mbolo
{#1058,+=}, de asignaci¢n operativa) como la siguiente:

  {<cadena destino> = <cadena destino> + <cadena origen> ;}

  (o bien)

  {<cadena destino> += <cadena origen> ;}

Siendo siempre {<cadena destino>} un dato de tipo {#1406,STRING}.

{/}

Para copiar cadenas de texto se debe utilizar la funci¢n {#202,strcpy()}.

Para separar (o restar) cadenas de texto, se debe utilizar la funci¢n
{#211,strdel()}.

{/}Ver: {#202,strcpy()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.204,strlen()}

{strlen(}<cadena de texto>{)}

{Retorna:}

La longitud de la cadena, en car cteres (contando los espacios).

{Descripci¢n:}

Cuenta el n£mero de car cteres del texto pasado como par metro, o contenido
actualmente en la cadena pasada.

La {<cadena de texto>} puede ser un literal (texto entre comillas) o un
dato de cualquier otro tipo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strlen;

GLOBAL
    STRING cadena1="Texto ejemplo";
    longitud_cadena1;

BEGIN
    write(0,0,0,0,"Texto contenido en <cadena1>:");
    write(0,0,10,0,cadena1);
    write(0,0,20,0,"Longitud de <cadena1>:");

    longitud_cadena1=strlen(cadena1); // Calcula la longitud

    write_int(0,0,30,0,OFFSET longitud_cadena1);
    LOOP
        FRAME;
    END
END
{-}

{/}

Se puede a¤adir un car cter a una cadena con la funci¢n {#203,strcat()}, o
bien con una sentencia de {#1019,asignaci¢n} como la siguiente:

  {cadena1+="a";}

Para quitar car cteres de una cadena se debe utilizar {#211,strdel()}, aunque
tambi‚n es posible eliminar car cteres del final de una cadena con sentencias
como las siguientes:

  {cadena1--;}ú
  {cadena1-=1;}ú
  {cadena1=cadena1-1;}ú

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.205,strcmp()}

{strcmp(}<cadena1>{,} <cadena2>{)}

{Retorna:}

{ +n} - Si la primera cadena es mayor que la segunda.ú
{  0} - Si las dos cadenas son id‚nticas.ú
{ -n} - Si la primera cadena es menor que la segunda.ú

{Descripci¢n:}

Compara dos cadenas de texto, car cter a car cter, devolviendo {0} cuando
ambas cadenas sean id‚nticas.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strcmp;

GLOBAL
    STRING micadena;

BEGIN
    // ...

    IF (strcmp(micadena,"abc")==0)

        // Las dos cadenas son iguales ...

    END

    // ...
END
{-}

{/}

La comparaci¢n de cadenas puede realizarse, siempre que las cadenas sean
de menos de 1024 car cteres, con los operadores de comparaci¢n usuales del
lenguaje.

Por ejemplo, la comparaci¢n del ejemplo anterior podr¡a haberse expresado
con la siguiente sentencia:

  {IF (micadena=="abc")}ú
  {//...}ú
  {END}ú

De igual forma, se puede comparar el s¡mbolo {#1046,<>} si dos cadenas son
diferentes, con los s¡mbolos {#1069,<} o {#1072,<=} si una cadena es menor,
o menor o igual a otra, etc.

{/}

Para buscar una cadena dentro de otra (ver si esta contenida en ella), se
utiliza la funci¢n {#207,strstr()}, y para ver si una cadena contiene alg£n
car cter se utiliza la funci¢n {#206,strchr()}.

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.206,strchr()}

{strchr(}<cadena de texto>{,} <car cteres>{)}

{Retorna:}

 { -1} Si no se encontraron los car cteres dentro de la cadena.ú
 { +n} Si uno de los car cteres se encontr¢ en la posici¢n {n} de la cadena.

{Descripci¢n:}

Busca uno o varios {<car cteres>} en una {<cadena de texto>}. Se recibe la
cadena como primer par metro y, como segundo, uno o varios car cteres en
un literal (entre comillas).

Esta funci¢n determinar  si la cadena contiene alguno de dichos car cteres y,
en caso afirmativo, indicar  en que posici¢n aparece el car cter dentro de la
cadena (de 0 en adelante). En caso de aparecer el car cter varias veces, la
funci¢n siempre retornar  la posici¢n primera.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strchr;

GLOBAL
    STRING micadena="FGHIJK";
    posici¢n;

BEGIN
    write(0,0,0,0,"Primera vocal de <micadena> en la posici¢n:");

    posici¢n=strchr(micadena,"AEIOU");

    write_int(0,0,10,0,OFFSET posici¢n);
    LOOP
        FRAME;
    END
END
{-}

En este ejemplo se utiliza la funci¢n {strchr()} para que determine que la
primera vocal de {micadena} se encuentra en la posici¢n {3} de dicha cadena.

{/}

Siempre se puede acceder a los car cteres de un dato de tipo {#1406,STRING} como
si este fuera una tabla de car cteres. Por ejemplo, para sustituir en el dato
{micadena} del ejemplo anterior, el car cter "I" por un car cter "-" se podr¡a
utilizar la siguiente sentencia:

  {micadena[3]=char("-");}

Para convertir un car cter contenido en un literal en su valor ordinal (ASCII)
se utiliza la funci¢n {#184,char()}.

{/}

Para determinar si una cadena esta completamente contenida en otra (si aparece
como una subcadena dentro de la misma), se debe utilizar la funci¢n {#207,strstr()}.

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.207,strstr()}

{strstr(}<cadena de texto>{,} <subcadena>{)}

{Retorna:}

 { -1} Si no se encontrar¢ la subcadena dentro de la cadena.ú
 { +n} Si se encontr¢ en la posici¢n {n} de la cadena de texto.

{Descripci¢n:}

Busca la secuencia de car cteres contenida en la {<subcadena>} en una
{<cadena de texto>}.

Esta funci¢n determinar  si la cadena contiene a la subcadena (como "CASA"
contiene "ASA") y, en caso afirmativo, indicar  en que posici¢n aparece la
subcadena dentro de la cadena (de 0 en adelante, 1 en el ejemplo anterior).
En caso de aparecer la subcadena varias veces, la funci¢n siempre retornar 
la posici¢n primera.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strstr;

GLOBAL
    STRING micadena="Esta es una cadena de ejemplo.";
    posici¢n;

BEGIN

    posici¢n=strstr(micadena,"es");

    write_int(0,0,10,0,OFFSET posici¢n);
    LOOP
        FRAME;
    END
END
{-}

En este ejemplo se utiliza la funci¢n {strstr()} para que determine d¢nde
se encuentra la subcadena {"es"} dentro de {micadena}. Retornar  la posici¢n
{5}, debido a que la funci¢n distingue entre may£sculas y min£sculas, por lo
que no se reconoce la subcadena "Es" (de "Esta") que se encuentra en la
posici¢n {0} de la cadena.

{/}

Para realizar conversiones entre may£sculas y min£sculas, se pueden utilizar
las funciones {#209,upper()} y {#210,lower()}.

{/}

Para determinar si una cadena contiene alg£n car cter en concreto, se debe utilizar
la funci¢n {#206,strchr()} que, adem s, permite buscar de una sola vez cualquier
car cter dentro de un conjunto especificado.

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.208,strset()}

{strset(}<cadena de texto>{,} <car cter>{)}

{Descripci¢n:}

Asigna a todas las posiciones de la {<cadena>} el {<car cter>} indicado como
segundo par metro.

La funci¢n puede recibir el {<car cter>} de dos formas; como un literal (el
car cter entre comillas), o bien como su ordinal (su valor ASCII) que debe
ser un valor entre {0} y {255}.

Se inicializar  toda la cadena con ese mismo car cter. La longitud de la cadena
depende del valor indicado entre corchetes en su inicializaci¢n, en caso de
no indicarse la longitud del dato de tipo {#1406,STRING}, se crear  una cadena
de {256} car cteres (desde la posici¢n 0 hasta 255).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strset;

GLOBAL
    STRING micadena="Esta es una cadena de ejemplo.";

BEGIN
    write(0,0,0,0,"Contenido de <micadena> (pulse espacio para cambiarlo):");
    write(0,0,10,0,micadena);
    LOOP
        IF (key(_space))

            strset(micadena,"*"); // Rellena la cadena con asteriscos

        END
        FRAME;
    END
END
{-}

{/}

Para calcular la longitud actual de una cadena se utiliza la funci¢n {#204,strlen()}.

Para borrar caracteres de una cadena (tanto del inicio como del final) se debe
utilizar {#211,strdel()}.

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.209,upper()}

{upper(}<cadena o car cter>{)}

{Retorna:}

Si se recibe un car cter correspondiente a una letra min£scula, retorna
dicho car cter convertido en may£scula.

{Descripci¢n:}

Convierte una cadena (o un simple car cter) a may£sculas, incluyendo los
car cteres especiales, como la letra "¤" o las vocales acentuadas.

Esta funci¢n puede trabajar en dos modos, en funci¢n del par metro que reciba:

- Si recibe una cadena de texto (o literal entre comillas), convertir  a
may£sculas todos los car cteres contenidos en dicha cadena y no retornar 
ning£n valor significativo (£nicamente el propio puntero a la cadena recibida).

- Si recibe un s¢lo car cter (su valor ordinal o ASCII), devolver  el
car cter convertido en may£scula (nuevamente su valor ordinal), y la funci¢n
no cambiar  ning£n dato en memoria.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_upper;

GLOBAL
    STRING micadena="Esta es una cadena de ejemplo.";
    BYTE   miletra="a";

BEGIN

    upper(micadena); // Convierte una cadena a may£sculas
    upper(miletra);  // Convierte un car cter en may£scula

    write(0,0,0,0,micadena);
    write(0,0,10,0,OFFSET miletra);
    LOOP
        FRAME;
    END
END
{-}

Este ejemplo tiene definidos dos datos globales ({micadena} y {miletra}), se
utilizar  la funci¢n {upper()} para convertirlos a may£sculas, y entonces se
mostrar n en pantalla.

{/}

Esta funci¢n no modificar  aquellos car cteres que no sean letras min£sculas.

{/}

La funci¢n {#210,lower()} es la inversa a {upper()}, ya que puede convertir
una cadena (o un car cter) a min£sculas.

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.210,lower()}

{lower(}<cadena o car cter>{)}

{Retorna:}

Si se recibe un car cter correspondiente a una letra may£scula, retorna
dicho car cter convertido en min£scula.

{Descripci¢n:}

Convierte una cadena (o un simple car cter) a min£sculas, incluyendo los
car cteres especiales, como la letra "¤" o las vocales acentuadas.

Esta funci¢n puede trabajar en dos modos, en funci¢n del par metro que reciba:

- Si recibe una cadena de texto (o literal entre comillas), convertir  a
min£sculas todos los car cteres contenidos en dicha cadena y no retornar 
ning£n valor significativo (£nicamente el propio puntero a la cadena recibida).

- Si recibe un s¢lo car cter (su valor ordinal o ASCII), devolver  el
car cter convertido en min£scula (nuevamente su valor ordinal), y la funci¢n
no cambiar  ning£n dato en memoria.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_lower;

GLOBAL
    STRING micadena="ESTA ES UNA CADENA DE EJEMPLO";
    BYTE   miletra="A";

BEGIN

    lower(micadena); // Convierte una cadena a min£sculas
    lower(miletra);  // Convierte un car cter en min£scula

    write(0,0,0,0,micadena);
    write(0,0,10,0,OFFSET miletra);
    LOOP
        FRAME;
    END
END
{-}

Este ejemplo tiene definidos dos datos globales ({micadena} y {miletra}), se
utilizar  la funci¢n {lower()} para convertirlos a min£sculas, y entonces se
mostrar n en pantalla.

{/}

Esta funci¢n no modificar  aquellos car cteres que no sean letras may£sculas.

{/}

La funci¢n {#209,upper()} es la inversa a {lower()}, ya que puede convertir
una cadena (o un car cter) a may£sculas.

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.211,strdel()}

{strdel(}<cadena de texto>{,} <resta inicio>{,} <resta final>{)}

{Descripci¢n:}

Esta funci¢n borra car cteres de una {<cadena de texto>}. Se eliminar n
{<resta inicio>} car cteres del inicio de la cadena y {<resta final>}
car cteres del final de la misma.

Para eliminar £nicamente car cteres del inicio de la cadena se debe indicar
{0} como {<resta final>}, y para eliminar s¢lo del final, {0} como {<resta
inicio>}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_strdel;

GLOBAL
    STRING micadena="Esta es una cadena de ejemplo.";

BEGIN

    strdel(micadena,5,9);

    write(0,0,0,0,micadena);
    LOOP
        FRAME;
    END
END
{-}

Este ejemplo utiliza la funci¢n {strdel()} para eliminar los primeros {5}
car cteres de {<micadena>} y los £ltimos {9}, para luego mostrar la cadena
resultante en pantalla ("es una cadena de").

{/}

{Nota:} Si se indica una cantidad negativa de car cteres (bien sea para el
inicio o para el final), la funci¢n a¤adir  espacios a la cadena.

{/}

Tambi‚n es posible eliminar car cteres del final de una cadena con sentencias
como las siguientes:

  {cadena1--;}ú
  {cadena1-=1;}ú
  {cadena1=cadena1-1;}ú

{/}Ver: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.212,screen_copy()}

{screen_copy(}<regi¢n>{,} <fichero>{,} <gr fico>{,} <x>{,} <y>{,} <ancho>{,} <alto>{)}

{Descripci¢n:}

Copia una region de pantalla a una regi¢n de cualquier gr fico.

Se trata de una potente funci¢n que puede resultar muy vers til, al
proporcionar "feedback" de la pantalla del ordenador, es decir, que puede
enviar una imagen de la pantalla a un gr fico (operaci¢n contraria a lo
normal).

Se debe primero definir el n£mero de {<regi¢n>} rectangular que se va a copiar
de la pantalla (de la imagen anterior del programa), estas regiones se definen
con la funci¢n {#106,define_region()}. La {regi¢n n£mero 0} siempre se refiere
a la pantalla completa.

Despu‚s se deber  indicar el gr fico al que se debe transferir la imagen, con
los par metros {<fichero>} y {<gr fico>} (el fichero ser  el n£mero 0, si el
gr fico pertenece al primer FPG cargado, o bien si se ha cargado de forma
separada).

Por £ltimo se indicar  {la zona dentro del gr fico} a la cual debe transferirse
la imagen. Esta se definir  como {<x>}, {<y>}, {<ancho>} y {<alto>}, referidos
a las coordenadas dentro del gr fico (siendo las coordenadas [0,0] su esquina
superior izquierda).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_screen_copy;

GLOBAL
     ngulo;
     ngulo2;

BEGIN
    load_fpg("help\help.fpg");
    graph=2;
    x=160;
    y=100;
    put(0,graph,x,y);
    LOOP

        // Copia la pantalla (regi¢n 0) al gr fico 2

        screen_copy(0,0,2,0,0,320,200);

         ngulo+=1000;
         ngulo2+=1971;
        angle=get_distx( ngulo,25000);
        size=95+get_disty( ngulo2,30);
        FRAME;
    END
END
{-}

Este ejemplo carga el fichero de gr ficos, en el que el {gr fico n£mero 2} es
una cuadr¡cula de diferentes colores, para ponerlo en pantalla y definirlo
como gr fico del proceso principal, que ir  rot ndo y cambiando de tama¤o
(en funci¢n de { ngulo} y { ngulo2}, respectivamente).

Es entonces cuando se utiliza la funci¢n {screen_copy()} para reenviar la
imagen de pantalla a este gr fico, con lo que se produce dicho efecto.

{/}

{Nota:} El {tama¤o} de la regi¢n de pantalla (la zona transferida) y el de la
regi¢n del gr fico (donde se transfiere) {no tiene que coincidir}. La funci¢n
{screen_copy()} realizar  una {reducci¢n} o {ampliaci¢n} cuando sea necesario,
para ajustar el tama¤o de la zona transferida.

{/}Ver: {#106,define_region()} - {#103,clear_screen()} - {#1126,graph}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.213,qsort()}

{qsort(}<nombre estructura>{,} <nombre campo>{,} <modo>{)}

{Descripci¢n:}

Ordena o desordena una estructura del programa por uno de sus campos.

Se trata de una simple pero vers til funci¢n que posibilita la r pida
ordenaci¢n y desordenaci¢n de estructuras de datos.

Su uso es muy simple, se requiere £nicamente el {<nombre de la estructura>},
el del {<campo que se va a utilizar como ¡ndice>}, y el {<modo de ordenaci¢n>};
uno de los indicados a continuaci¢n:

{0} - Ordenaci¢n ascendente (de menor a mayor).

{1} - Ordenaci¢n descendente (de mayor a menor).

{2} - Desordenaci¢n aleatoria.

Se puede utilizar como campo ¡ndice cualquiera de los datos contenidos en la
estructura, bien se trate de un dato num‚rico, o de una cadena de texto (en
cuyo caso se ordenar  alfab‚ticamente).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_qsort;

GLOBAL

  STRUCT miestructura[9];
    STRING nombre[32];
    puntos;
    x,y;
  END

BEGIN

  //...

  // Ordena los registros de miestructura, de forma que se sit£en los de
  // mayor puntuaci¢n al principio

  qsort(miestructura,puntos,1);

  //...

END
{-}

Este ejemplo muestra la f cil utilizaci¢n de la funci¢n {qsort()} para ordenar
una estructura, que puede representar cualquier tipo de objeto dentro de un
programa.

No es necesario que el campo utilizado como ¡ndice ({puntos} en este caso)
sea el primero de la estructura.

{/}

{Nota:} La desordenaci¢n de una estructura requiere igualmente un campo que
diferencie a los distintos registros de la misma. Esta operaci¢n puede ser
£til para dotar de "aleatoriedad" a un programa (por ejemplo, para "barajar"
un conjunto de cartas).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.214,load_song()}

{load_song(}<nombre de archivo>{,} <repetici¢n>{)}

{Retorna:}

Identificador de la canci¢n cargada, o -1 si se produce un error.

{Descripci¢n:}

Carga una canci¢n de un archivo MOD, S3M o XM, para su posterior reproducci¢n.

La funci¢n requiere el nombre del archivo que contiene el m¢dulo musical, y
si este debe reproducirse una s¢la vez (indicando {0} en {<repetici¢n>}) o
indefinidamente (indicando {1}).

Estos m¢dulos musicales se pueden componer con m£ltiples programas shareware
o de libre uso. En DIV Games Studio se pueden reproducir, tanto en el entorno
como en los programas creados, pero no se pueden crear nuevos m¢dulos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_song;

GLOBAL
    id_canci¢n;

BEGIN

    load_song("help\help.xm",1); // Carga un m¢dulo XM, con repetici¢n

    song(id_canci¢n);
    write(0,0,0,0,"Pulse ESC para terminar");
    REPEAT
        FRAME;
    UNTIL (key(_ESC));
    unload_song(id_canci¢n);
END
{-}

Este ejemplo carga el m¢dulo contenido en el archivo {help.xm} con la
funci¢n {load_song()}, indicando que este debe reproducirse indefinidamente.
La reproducci¢n del archivo se inicia con una llamada a la funci¢n {#216,song()}.

Para descargar una canci¢n de memoria se debe utilizar la funci¢n
{#215,unload_song()}, si bien todos los programas creados en DIV Games Studio
liberar n toda la memoria ocupada de forma autom tica al finalizar.

El volumen de reproducci¢n puede controlarse mediante la funci¢n
{#178,set_volume()} y los datos contenidos en la {#1104,estructura setup}.

{/}

{Nota:} Con esta versi¢n de DIV Games Studio se incluyen varios archivos con
m¢dulos musicales de libre utilizaci¢n, en el directorio {MOD}.

{/}

{Nota:} Para reproducir canciones contenidas en una pista de CD-Audio se deben
utilzar las funciones {#144,play_cd()} y {#164,stop_cd()}.

{/}Ver: {#215,unload_song()} - {#216,song()} - {#144,play_cd()} - {#1104,Estructura setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.215,unload_song()}

{unload_song(}<identificador del m¢dulo>{)}

{Descripci¢n:}

Descarga de memoria el m¢dulo musical cuyo identificador se pasa como par metro.
Este {<identificador del m¢dulo>} es el valor que retorna la funci¢n
{#214,load_song()} al cargarlo en memoria.

Tras descargarse un m¢dulo {se deben extremar las precauciones}
para no continuar utiliz ndolo en el programa, en cuyo caso el
programa correr¡a el riesgo de bloquearse.

{No es necesario descargar los m¢dulos} antes de finalizar el
programa, ya que el sistema lo har  de forma autom tica.
Luego, solamente deben descargarse de memoria cuando ya no se
vayan a utilizar durante un tiempo determinado y se quiera liberar el espacio
ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros
de gr ficos, sonidos, fuentes, etc.).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_unload_song;

GLOBAL
    id_canci¢n;

BEGIN
    load_song("help\help.xm",1);
    song(id_canci¢n);
    write(0,0,0,0,"Pulse ESC para terminar");
    REPEAT
        FRAME;
    UNTIL (key(_ESC));

    unload_song(id_canci¢n); // Libera la memoria ocupada por el m¢dulo

END
{-}

Este ejemplo carga el m¢dulo contenido en el archivo {help.xm} con la
funci¢n {#214,load_song()}. La reproducci¢n del archivo se inicia con una
llamada a la funci¢n {#216,song()}.

El programa permanecer  reproduciendo este m¢dulo hasta que se pulse la
tecla {ESC}, momento en el que se finalizar  el bucle principal y se
descargar  el m¢dulo de memoria con la funci¢n {unload_song()}, indicando
como par metro {id_canci¢n} que es contiene el {identificador del m¢dulo}
devuelto al cargarlo.

{/}

{Nota:} Las m£sicas contenidas en pistas de CD-Audio, cuya reproducci¢n
se inicia con la funci¢n {#144,play_cd()}, no ocupan memoria en el ordenador,
por lo que no pueden descargarse con la funci¢n {unload_song()}.

{/}Ver: {#214,load_song()} - {#216,song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.216,song()}

{song(}<indentificador del m¢dulo>{)}

{Descripci¢n:}

Inicia la reproducci¢n de un m¢dulo musical cargado previamente con la funci¢n
{#214,load_song()}. La funci¢n debe recibir como £nico par metro el {<identificador
del m¢dulo>} a reproducir.

Tan s¢lo puede reproducirse un m¢dulo a la vez, si se inicia la reproducci¢n
de un m¢dulo cuando otro est‚ sonando, se detendr  el anterior. No obstante
se pueden reproducir simult neamente un m¢dulo musical, una pista de CD-Audio
(ver {#144,play_cd()}) y m£ltiples efectos de sonido (ver {#159,sound()}).

La reproducci¢n siempre se realizar  a partir del inicio del m¢dulo (el comienzo
de la canci¢n). Para reproducir cualquier parte de un m¢dulo se debe llamar
a la funci¢n {#218,set_song_pos()}, que fija la posici¢n a partir de la cual
debe reproducirse un m¢dulo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_song;

GLOBAL
    id_canci¢n;

BEGIN
    load_song("help\help.xm",1);

    song(id_canci¢n); // Inicia la reproducci¢n del m¢dulo musical

    write(0,0,0,0,"Pulse ESC para terminar");
    REPEAT
        FRAME;
    UNTIL (key(_ESC));
    unload_song(id_canci¢n);
END
{-}

Este ejemplo carga el m¢dulo contenido en el archivo {help.xm} con la
funci¢n {#214,load_song()}, indicando que este debe reproducirse
indefinidamente (esto se indica en la misma carga del archivo).

Entonces se inicia la reproducci¢n del archivo con la funci¢n {song()}.

El programa entrar  entonces en un bucle en el que continuar  sonando
este m¢dulo, hasta que una pulsaci¢n de la tecla {ESC} desemboque en la
finalizaci¢n del programa.

El volumen de reproducci¢n puede controlarse mediante la funci¢n
{#178,set_volume()} y los datos contenidos en la {#1104,estructura setup}.

{/}

{Nota:} Para finalizar la reproducci¢n de un m¢dulo musical se debe emplear la
funci¢n {#217,stop_song()}.

{/}

{Nota:} Se puede averiguar si un m¢dulo est  reproduci‚ndose llamando a la
funci¢n {#222,is_playing_song()}.

{/}Ver: {#214,load_song()} - {#217,stop_song()} - {#144,play_cd()} - {#159,sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.217,stop_song()}

{stop_song(}{)}

{Descripci¢n:}

Detiene la reproducci¢n del m¢dulo musical (MOD, S3M o XM) que este sonando.

Esta funci¢n no requiere ning£n par metro, ya que £nicamente puede reproducirse
£n m¢dulo musical a la vez.

No es imprescindible detener la reproducci¢n de un m¢dulo musical
antes de descargarlo de memoria (operaci¢n realizada con la funci¢n
{#215,unload_song()}), esta acci¢n se realiza de forma autom tica.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_stop_song;

GLOBAL
    id_canci¢n;

BEGIN
    load_song("help\help.xm",1);
    song(id_canci¢n);
    write(0,0,0,0,"Pulse SPACE para detener la canci¢n ...");
    LOOP
        IF (key(_space))

            stop_song(); // Detiene el m¢dulo

        END
        FRAME;
    END
    unload_song(id_canci¢n);
END
{-}

Este ejemplo carga el m¢dulo contenido en el archivo {help.xm} con la
funci¢n {#214,load_song()}. La reproducci¢n del archivo se inicia con una
llamada a la funci¢n {#216,song()}.

El programa entra entonces en un bucle en el que continuar  la reproducci¢n
de dicho m¢dulo, hasta que una pulsaci¢n de la tecla barra espaciadora provoque
una llamada a {stop_song()} y se detenga el m¢dulo.

Para descargar una canci¢n de memoria se debe utilizar la funci¢n
{#215,unload_song()}, si bien todos los programas creados en DIV Games Studio
liberar n toda la memoria ocupada de forma autom tica al finalizar.

{/}

{Nota:} Para detener una canci¢n de CD-Audio se utiliza la funci¢n {#164,stop_cd()}, y
hacerlo con un efecto de sonido, la funci¢n {#167,stop_sound()}.

{/}

{Nota:} Se puede averiguar si un m¢dulo est  reproduci‚ndose llamando a la
funci¢n {#222,is_playing_song()}.

{/}Ver: {#216,song()} - {#214,load_song()} - {#144,play_cd()} - {#159,sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.218,set_song_pos()}

{set_song_pos(}<posici¢n del m¢dulo>{)}

{Descripci¢n:}

Fija la posici¢n de reproducci¢n del m¢dulo musical (el n£mero de "pattern").

Esta {<posici¢n del m¢dulo>} es un n£mero entre 0 y el n£mero m ximo de
{pattern} (patrones) del m¢dulo. Este valor varia para cada m¢dulo, y se
define en los programas utilizados para componerlos. Los m¢dulos suelen
tener un n£mero muy variable de patrones, aunque la media puede situarse
entre 30 y 40.

Dentro de cada patr¢n los m¢dulos tienen un determinado n£mero de l¡neas
(normalmente 64), en las cuales aparecen las notas musicales, por lo que se
podr¡a definir cada patr¢n como una peque¤a secci¢n del m¢dulo musical.

Para obtener la posici¢n actual de un m¢dulo que se est  reproduciendo se
utiliza la funci¢n {#219,get_song_pos()}.

Se puede variar la posici¢n del m¢dulo tanto si este est  parado, como si se
est  reproduciendo. Esta funci¢n puede utilizarse para avanzar o retroceder
en la reproducci¢n del m¢dulo, para implementar diversos bucles repetitivos
de ciertas partes de un m¢dulo, etc.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_set_song_pos;

GLOBAL
    id_canci¢n;
    posici¢n_m¢dulo;

BEGIN
    load_song("help\help.xm",1);
    song(id_canci¢n);
    write(0,0,0,0,"Pulse SPACE cambiar la posici¢n del m¢dulo ...");
    write(0,0,20,0,"Posici¢n:");
    write_int(0,0,30,0,OFFSET posici¢n_m¢dulo);
    LOOP
        IF (key(_space))
            posici¢n_m¢dulo=rand(0,19);

            set_song_pos(posici¢n_m¢dulo); // Cambia la posici¢n del m¢dulo

        END
        posici¢n_m¢dulo=get_song_pos();
        FRAME;
    END
END
{-}

Este programa carga el m¢dulo contenido en el archivo {help.xm} y entonces
inicia su reproducci¢n con la funci¢n {#216,song()}.

A partir de este momento se mostrar  la posici¢n actual de m¢dulo en pantalla,
y se podr  cambiar la misma pulsando la barra espaciadora (se asignar  una
posici¢n al azar, entre 0 y 19, ya que este m¢dulo tiene 20 patrones).

{/}

{Nota:} No se puede fijar la l¡nea de reproducci¢n de un m¢dulo (dentro de
cada patr¢n), pero si que se puede obtener este valor con la funci¢n
{#220,get_song_line()}.

{/}Ver: {#219,get_song_pos()} - {#216,song()} - {#214,load_song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.219,get_song_pos()}

{get_song_pos(}{)}

{Retorna:}

La posici¢n actual del m¢dulo musical que se est‚ reproduciendo.

{Descripci¢n:}

Devuelve la posici¢n actual de reproducci¢n del m¢dulo musical, esta
posici¢n puede fijarse con la funci¢n {#218,set_song_pos()}.

Esta {<posici¢n del m¢dulo>} es un n£mero entre 0 y el n£mero m ximo de
{pattern} (patrones) del m¢dulo. Este valor varia para cada m¢dulo, y se
define en los programas utilizados para componerlos. Los m¢dulos suelen
tener un n£mero muy variable de patrones, aunque la media puede situarse
entre 30 y 40.

Dentro de cada patr¢n los m¢dulos tienen un determinado n£mero de l¡neas
(normalmente 64), en las cuales aparecen las notas musicales, por lo que se
podr¡a definir cada patr¢n como una peque¤a secci¢n del m¢dulo musical.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_song_pos;

GLOBAL
    id_canci¢n;
    posici¢n_m¢dulo;

BEGIN
    load_song("help\help.xm",1);
    song(id_canci¢n);
    write(0,0,0,0,"Posici¢n del m¢dulo:");
    write_int(0,0,10,0,OFFSET posici¢n_m¢dulo);
    LOOP

        posici¢n_m¢dulo=get_song_pos(); // Obtiene la posici¢n

        FRAME;
    END
END
{-}

Este programa carga el m¢dulo contenido en el archivo {help.xm} y entonces
inicia su reproducci¢n con la funci¢n {#216,song()}.

A partir de este momento se mostrar  la posici¢n actual del m¢dulo en pantalla,
obtenida mediante la funci¢n {get_song_pos()}.

{/}

{Nota:} Se puede obtener el n£mero de l¡nea que se est  reproduciendo, dentro
del patr¢n, con la funci¢n {#220,get_song_line()}.

{/}Ver: {#220,get_song_line()} - {#218,set_song_pos()} - {#216,song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.220,get_song_line()}

{get_song_line(}{)}

{Retorna:}

El n£mero de l¡nea del m¢dulo musical.

{Descripci¢n:}

Con esta funci¢n se puede obtener el n£mero de l¡nea del m¢dulo musical
que se est  reproduciendo (dentro de la posici¢n, o patr¢n actual).

Esta posici¢n actual, o patr¢n (pattern), puede obtenerse con la funci¢n
{#219,get_song_pos()}.

Dentro de cada patr¢n los m¢dulos tienen un determinado n£mero de l¡neas
(normalmente 64), en las cuales aparecen las notas musicales. Los m¢dulos
suelen tener un n£mero muy variable de patrones, aunque la media puede
situarse entre 30 y 40.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_song_line;

GLOBAL
    id_canci¢n;
    l¡nea_m¢dulo;

BEGIN
    load_song("help\help.xm",1);
    song(id_canci¢n);
    write(0,0,0,0,"L¡nea del m¢dulo:");
    write_int(0,0,10,0,OFFSET l¡nea_m¢dulo);
    LOOP

        l¡nea_m¢dulo=get_song_line(); // Obtiene el n£mero de l¡nea

        FRAME;
    END
END
{-}

Este programa carga el m¢dulo contenido en el archivo {help.xm} y entonces
inicia su reproducci¢n con la funci¢n {#216,song()}.

A partir de este momento se mostrar  la l¡nea actual del m¢dulo en pantalla,
obtenida mediante la funci¢n {get_song_line()}.

{/}

{Nota:} No se puede fijar la l¡nea del m¢dulo musical, aunque si se puede
fijar la posici¢n a partir de la que debe reproducirse con la funci¢n
{#218,set_song_pos()} (siempre se comenzar  en la l¡nea 0 del patr¢n).

{/}Ver: #219,get_song_pos()} - {#218,set_song_pos()} - {#216,song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.221,is_playing_sound()}

{is_playing_sound(}<n£mero de canal>{)}

{Retorna:}

{0} - Si el canal est  parado.ú
{1} - Si est  sonando un sonido por el canal.

{Descripci¢n:}

Esta funci¢n permite saber si uno de los {canales de sonido} esta reproduciendo
sonido, o si est  disponible.

Se requiere como par metro el {<n£mero de canal>}, este valor se obtiene como
retorno de la funci¢n {#159,sound()} al iniciarse la reproducci¢n de un efecto
de sonido.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_is_playing_sound;

GLOBAL
    sonido;
    canal;

BEGIN
    write(0,0,0,0,"Pulse ESC para finalizar.");
    sonido = load_pcm("help\help.pcm",0);
    canal  = sound(sonido, 256, rand(100,400));
    REPEAT

        // Si finaliz¢ la reproducci¢n, vuelve a lanzar el sonido

        IF (NOT is_playing_sound(canal))

            canal = sound(sonido, 256, rand(100,400));
        END
        FRAME;
    UNTIL (key(_ESC));
END
{-}

Este ejemplo utiliza una funci¢n para tocar un sonido continuamente, de forma
controlada por el programa, en lugar de autom ticamente (lo que se suele hacer
indicando en la carga del sonido que ‚ste es c¡clico, en las funciones
{#134,load_pcm()} o {#134,load_wav()}).

Se inicia la reproducci¢n de nuevo siempre que el canal del sonido haya quedado
libre, es decir, cada vez que acabe de reproducirse el efecto.

El programa aprovecha esta circunstancia (controlar manualmente la repetici¢n)
para emitir el sonido a una frecuencia diferente en cada ocasi¢n, lo que no
podr¡a hacerse con una repetici¢n autom tica. Esta frecuencia se obtiene como
un valor al azar entre 100 y 400 con la funci¢n {#149,rand()}.

{/}

{Nota:} Un mismo sonido puede reproducirse por diferentes canales cada vez,
por ello es necesario guardar el n£mero de canal cada vez que se inicia la
reproducci¢n.

{/}Ver: {#159,sound()} - {#102,change_sound()} - {#222,is_playing_song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.222,is_playing_song()}

{is_playing_song(}{)}

{Retorna:}

{0} - No est  sonando ning£n m¢dulo.ú
{1} - Si est  sonando un m¢dulo musical.

{Descripci¢n:}

Esta funci¢n permite determinar si se est  reproduciendo un m¢dulo de m£sica
digital de un archivo MOD, S3M o XM.

Estos m¢dulos se deben cargar con la funci¢n {#214,load_song()} y su
reproducci¢n se inicia con una llamada a {#216,song()}.

Unicamente puede reproducirse un m¢dulo a la vez, por lo que esta funci¢n
no requiere ning£n par metro, simplemente devuelve {1} si hay alg£n m¢dulo
reproduci‚ndose.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_is_playing_song;

GLOBAL
    id_canci¢n;
    sonando;

BEGIN
    load_song("help\help.xm",1);
    song(id_canci¢n);
    write(0,0,0,0,"ENTER iniciar el m¢dulo / SPACE para detenerlo");
    write_int(0,0,10,0,OFFSET sonando);
    LOOP
        IF (key(_enter)) song(id_canci¢n); END
        IF (key(_space)) stop_song(); END

        sonando = is_playing_song(); // Determina si est  sonando

        FRAME;
    END
END
{-}

Este ejemplo carga el m¢dulo musical contenido en el archivo {help.xm} y
permite, dentro de un bucle, iniciarlo con la tecla {ENTER} y detenerlo con
la barra espaciadora.

Dentro de este mismo bucle se utiliza la funci¢n {is_playing_song()} para
determinar si este est  sonando en cada momento.

{/}

{Nota:} Para finalizar la reproducci¢n de un m¢dulo musical se debe emplear la
funci¢n {#217,stop_song()}.

{/}Ver: {#214,load_song()} - {#216,song()} - {#221,is_playing_sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.223,fopen()}

{fopen(}<nombre de archivo>{,} <modo>{)}

{Retorna:}

El {handle} o identificador de archivo abierto, o bien {0} si se produjo un
error.

{Descripci¢n:}

Abre un archivo del disco para lectura o escritura, utilizando el sistema
de acceso a trav‚s de un {handle} o {identificador de archivo} que esta funci¢n
retorna del archivo abierto o creado.

Se requiere el {<nombre del archivo>} a abrir o crear, y el {<modo>} de apertura,
que debe ser un literal (texto entre comillas) dentro de los siguientes:

 "{r}" - Abre el archivo para lectura de los datos contenidos en el mismo.

 "{w}" - Crea el archivo para escritura (si existe, se perder  su
contenido anterior).

 "{a}" - Abre el archivo para escribir al final del mismo, o lo crea en caso
de no existir a£n.

 "{r+}" - Abre un archivo existente para actualizarlo, permitiendo tanto
lectura como escritura.

 "{w+}" - Crea un fichero (o trunca el existente) para escritura, permitiendo
tambi‚n lectura del mismo.

 "{a+}" - Abre un archivo para leer del mismo en cualquier posici¢n y escribir
al final del mismo.

Una vez abierto un archivo, pueden utilizarse todas las funciones de archivos
basadas en {handles}, pero una vez se hayan realizado las operaciones
necesarias en el fichero {se debe cerrar}, utilizando para ello la funci¢n
{#224,fclose()}.

Las funciones principales son {#225,fread()} para la lectura de datos dentro
del archivo y {#226,fwrite()} para escritura de datos; es importante haber
abierto el archivo en un {modo} apropiado para las operaciones realizadas.
Es decir, que por ejemplo no se podr  escribir en el fichero si se ha abierto
exclusivamente para lectura.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fopen;

GLOBAL
    tabla1[3]=11,22,33,44;
    tabla2[3];
    mihandle;

BEGIN

    mihandle=fopen("help\help.dat","w"); // Abre archivo para escritura

    fwrite(OFFSET tabla1,4,mihandle);
    fclose(mihandle);

    mihandle=fopen("help\help.dat","r"); // Abre archivo para lectura

    fread(OFFSET tabla2,4,mihandle);
    fclose(mihandle);
END
{-}

Este programa ejemplo tiene definidas dos tablas globales; {tabla1} con cuatro
valores inicializados a 11, 22, 33 y 44, y {tabla2} con cuatro sin incializar
(a cero).

Se utilizan las funciones de archivos para escribir en un archivo el contenido
de la {tabla1} y despu‚s cargarlo sobre la {tabla2}. Al finalizar el programa,
se habr n copiado los datos de la primera tabla en la segunda.

Se llama a la funci¢n {fopen()} en dos ocasiones, la primera para {crearlo y
escribir} en ‚l, y la segunda para {abrirlo y leer} su contenido.

Es importante resaltar que cada vez que se abra o cree un archivo, se tiene que
cerrar despu‚s con la funci¢n {#224,fclose()} (se puede ver como, en el
ejemplo, se cierra el archivo en dos ocasiones).

{/}

La funci¢n {#227,fseek()} permite situar el {puntero de lectura/escritura}
en cualquier posici¢n del archivo. De esta forma, se pueden leer o escribir
datos de cualquier punto del archivo.

{/}

La funci¢n {#230,flush()} vac¡a los buffers de escritura y permite adem s
averiguar cuantos archivos hay abiertos en cada momento.

{/}

{Nota:} Las funciones {#155,save()} y {#130,load()} permiten igualmente
salvar datos en archivos del disco y recuperarlos. Estas funciones son
mas simples y con menos funcionalidad, pero su uso es mucho m s
sencillo que las funciones basadas en {handles} aqu¡ descritas.

{/}Ver: {#224,fclose()} {#225,fread()} - {#226,fwrite()} - {#155,save()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.224,fclose()}

{fclose(}<handle>{)}

{Retorna:}

N£mero de archivos que se han cerrado.

{Descripci¢n:}

Cierra un archivo abierto con la funci¢n {#223,fopen()}, para ello debe
recibir como par metro el {handle} o {identificador de archivo} devuelto
por dicha funci¢n.

En una segunda modalidad, la funci¢n {fclose()} puede {cerrar todos los
archivos abiertos} de una vez, para ello se debe indicar simplemente {0}
(cero) como par metro, en lugar de un {handle}.

En cualquier caso, la funci¢n retornar  el n£mero de archivos que se han
cerrado, si se devuelve {0} puede deberse a uno de estos casos:

{ -} No hab¡a ning£n archivo abierto.ú
{ -} El {handle} pasado no se corresponde con ning£n archivo abierto.
{ -} El archivo correspondiente a dicho {handle} ya habia sido cerrado.

Todos los archivos abiertos deben cerrarse antes de que el programa finalice
su ejecuci¢n.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fclose;

GLOBAL
    tabla1[3]=11,22,33,44;
    tabla2[3];
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET tabla1,4,mihandle);

    fclose(mihandle); // Se cierra el archivo para abrirlo en otro modo

    mihandle=fopen("help\help.dat","r");
    fread(OFFSET tabla2,4,mihandle);

    fclose(mihandle); // Se cierra el archivo definitivamente
END
{-}

Se utilizan las funciones de archivos para escribir en un archivo el contenido
de la {tabla1} y despu‚s cargarlo sobre la {tabla2}. Al finalizar el programa,
se habr n copiado los datos de la primera tabla en la segunda.

Si un archivo abierto en un modo (con la funci¢n {#223,fopen()}) quiere
accederse en otro modo diferente, se debe primero cerrar para entonces
volver a abrirlo en el nuevo modo; como sucede en el ejemplo, se cierra el
archivo de escritura para abrirlo entonces en modo lectura.

{/}

La funci¢n {#230,flush()} vac¡a los buffers de escritura y permite adem s
averiguar cuantos archivos hay abiertos en cada momento.

{/}Ver: {#223,fopen()} {#225,fread()} - {#226,fwrite()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.225,fread()}

{fread(}<OFFSET datos>{,} <longitud>{,} <handle>{)}

{Retorna:}

{0} - Se produjo un error, o no se leyeron todos los datos pedidos.ú
{1} - Si se pudieron leer todos los datos.

{Descripci¢n:}

Esta funci¢n permite leer datos de un archivo abierto con la funci¢n
{#223,fopen()}, a partir de la posici¢n indicada por el {puntero de
lectura/escritura}.

El archivo se debe haber abierto en un {modo de lectura}, o que la permita.

El {puntero} se situa inicialmente al comienzo del archivo, al abrirse el
mismo, y avanza secuencialmente seg£n se vayan leyendo datos. No obst nte
puede situarse este puntero del archivo en cualquier posici¢n,
utilizando la funci¢n {#227,fseek()} y la funci¢n {#228,ftell()} permite
obtener la posici¢n actual del puntero de un archivo.

La funci¢n {fread()} requiere como primer par metro el {<}{#1085,OFFSET}
{de los datos>} en los que deben leerse los datos del archivo, es decir,
la direcci¢n de memoria a partir de la cual se deben colocar los datos que
se vayan leyendo del archivo.

Como segundo par metro se requiere la {<longitud>} o tama¤o total de los
datos que se quieren leer, es decir, el n£mero de posiciones de memoria
que ocupan dichos datos. La longitud de un dato se puede obtener con la
funci¢n {#1094,sizeof()}.

El £ltimo par metro debe ser el {handle} o {identificador de archivo} que
se obtuvo al abrir el archivo como valor de retorno de {#223,fopen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fread;

GLOBAL
    tabla1[3]=11,22,33,44;
    tabla2[3];
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET tabla1,4,mihandle);
    fclose(mihandle);
    mihandle=fopen("help\help.dat","r");

    fread(OFFSET tabla2,4,mihandle); // Lee el archivo sobre <tabla2>

    fclose(mihandle);
END
{-}

Este programa ejemplo tiene definidas dos tablas globales; {tabla1} con cuatro
valores inicializados a 11, 22, 33 y 44, y {tabla2} con cuatro sin incializar
(a cero).

Se utilizan las funciones de archivos para escribir en un archivo el contenido
de la {tabla1} y despu‚s cargarlo sobre la {tabla2}. Al finalizar el programa,
se habr n copiado los datos de la primera tabla en la segunda.

Se llama a la funci¢n {#223,fopen()} en dos ocasiones, la primera para {crearlo y
escribir} en ‚l, y la segunda para {abrirlo y leer} su contenido.

Es importante resaltar que cada vez que se abra o cree un archivo, se tiene que
cerrar despu‚s con la funci¢n {#224,fclose()} (se puede ver como, en el
ejemplo, se cierra el archivo en dos ocasiones).

{/}

La funci¢n inversa a {fopen()}, es decir, la que permite escribir datos en un
archivo en lugar de leerlos, es {#226,fwrite()}. La forma de utilizar esta
funci¢n y sus par metros son id‚nticos a los de {fread()}.

{/}

{Nota:} Por defecto, la {<longitud>} se especifica como el n£mero de datos
simples, teniendo en cuenta que un dato simple (una variable) ocupa {4
bytes}. Es decir, que si por ejemplo, se leen diez datos (indicando 10 como
longitud), se estar n leyendo cuarenta bytes.

Se puede cambiar esta relaci¢n modificando la variable global {#1420,unit_size},
que por defecto vale {4} en todos los programas.

{/}Ver: {#223,fopen()} - {#226,fwrite()} - {#227,fseek()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.226,fwrite()}

{fwrite(}<OFFSET datos>{,} <longitud>{,} <handle>{)}

{Retorna:}

{0} - Se produjo un error, o no se escribieron todos los datos.ú
{1} - Si se pudieron escribir todos los datos.

{Descripci¢n:}

Esta funci¢n permite escribir datos en un archivo abierto con la funci¢n
{#223,fopen()}, a partir de la posici¢n indicada por el {puntero de
lectura/escritura}.

El archivo se debe haber abierto en un {modo de escritura}, o que la permita.

El {puntero} se situa inicialmente al comienzo del archivo, al abrirse o
crearse el mismo, y avanza secuencialmente seg£n se vayan escribiendo datos.
No obst nte puede situarse este puntero del archivo en cualquier posici¢n,
utilizando la funci¢n {#227,fseek()} y la funci¢n {#228,ftell()} permite
obtener la posici¢n actual del puntero de un archivo.

La funci¢n {fwrite()} requiere como primer par metro el {<}{#1085,OFFSET}
{de los datos>} que deben escribirse en el archivo, es decir,
la direcci¢n de memoria.

Como segundo par metro se requiere la {<longitud>} o tama¤o total de los
datos que se quieren escribir, es decir, el n£mero de posiciones de memoria
que ocupan dichos datos. La longitud de un dato se puede obtener con la
funci¢n {#1094,sizeof()}.

El £ltimo par metro debe ser el {handle} o {identificador de archivo} que
se obtuvo al abrir el archivo como valor de retorno de {#223,fopen()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fwrite;

GLOBAL
    mitabla[3]=11,22,33,44;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");

    fwrite(OFFSET tabla1,4,mihandle); // Escribe <mitabla> en el archivo

    fclose(mihandle);
END
{-}

Este programa ejemplo escribe los datos contenidos en {<mitabla>} en el archivo
{help.dat} del disco.

Se llama a la funci¢n {#223,fopen()} para crearlo y a la funci¢n {#224,fclose()}
para cerrarlo una vez se han escrito los datos.

{/}

La funci¢n inversa a {fwrite()}, es decir, la que permite escribir datos en un
archivo en lugar de leerlos, es {#225,fread()}. La forma de utilizar esta
funci¢n y sus par metros son id‚nticos a los de {fwrite()}.

{/}

{Nota:} Por defecto, la {<longitud>} se especifica como el n£mero de datos
simples, teniendo en cuenta que un dato simple (una variable) ocupa {4
bytes}. Es decir, que si por ejemplo, se escriben diez datos (indicando 10
como longitud), se estar n escribiendo cuarenta bytes.

Se puede cambiar esta relaci¢n modificando la variable global {#1420,unit_size},
que por defecto vale {4} en todos los programas.

{/}Ver: {#223,fopen()} - {#225,fread()} - {#227,fseek()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.227,fseek()}

{fseek(}<handle>{,} <posici¢n puntero>{,} <modo>{)}

{Descripci¢n:}

Sit£a el {puntero de lectura/escritura} de un archivo en la posici¢n indicada.

La funci¢n requiere, en primer lugar, el {<handle>} o {identificador de archivo}
devuelto por la funci¢n {#223,fopen()} al abrirlo.

En segundo lugar se especifica la nueva posici¢n en la que debe situarse el
{<puntero>} del archivo. Tras llamar a esta funci¢n, todas las operaciones
de lectura o escritura que se efect£en, lo har n a partir de esta posici¢n.

Como £ltimo par metro se debe indicar el {<modo>} en el que se especifica
la nueva posici¢n del puntero, puede ser uno de estos tres:

 {seek_set} - Posici¢n respecto al inicio del archivo (0).ú
 {seek_cur} - Incremento relativo a la posici¢n actual (1).ú
 {seek_end} - Posici¢n respecto al final del archivo (2).ú

Para obtener la situaci¢n actual del puntero de un archivo, se debe
utilizar la funci¢n {#228,ftell()}.

Todas las operaciones de lectura o escritura sobre un archivo avanzan
autom ticamente el puntero del mismo, de forma que todos estos accesos se
realicen de forma secuencial (leyendo o escribiendo los datos unos a
continuaci¢n de otros).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_fseek;

GLOBAL
    mitabla[3]=11,22,33,44;
    midato;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET mitabla,4,mihandle);
    fclose(mihandle);
    mihandle=fopen("help\help.dat","r");

    // Sit£a el puntero para leer el cuarto dato del archivo (44)

    fseek(mihandle,3,seek_set);

    fread(OFFSET midato,1,mihandle);
    fclose(mihandle);
END
{-}

Este ejemplo escribe los cuatro datos contenidos en {mitabla} (11,22,33 y 44)
en el archivo {help.dat}, tras esto, abre el archivo para lectura y utiliza
la funci¢n {fseek()} para situar el puntero en la {posici¢n 3} a partir del
inicio del archivo (con {seek_set}).

A partir de este momento, se podr  leer a partir del cuarto dato del archivo,
por ello, cuando se lee un valor en la variable {midato} este ser  {44}, es
decir, el cuarto valor de la tabla.

{/}

{Nota:} Por defecto, la {<posici¢n del puntero>} se especifica como un
n£mero de datos simples, teniendo en cuenta que un dato simple (una variable)
ocupa {4 bytes}. Es decir, que si por ejemplo, se sit£a el puntero en la
posici¢n diez a partir del inicio del fichero, se podr  entonces acceder
a los datos contenidos en el archivo a partir del byte cuarenta.

Se puede cambiar esta relaci¢n modificando la variable global {#1420,unit_size},
que por defecto vale {4} en todos los programas.

{/}Ver: {#228,ftell()} - {#225,fread()} - {#226,fwrite()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.228,ftell()}

{ftell(}<handle>{)}

{Retorna:}

La posici¢n actual del puntero de lectura/escritura de un archivo.

{Descripci¢n:}

Retorna la posici¢n del {puntero de lectura/escritura} de un archivo, para ello
requiere £nicamente el {<handle>} o {identificador de archivo} devuelto por
la funci¢n {#223,fopen()} al abrirlo.

Para establecer una nueva posici¢n del puntero de un archivo, se debe
utilizar la funci¢n {#227,fseek()}. A diferencia de esta £ltima funci¢n,
{ftell()} siempre retorna la posici¢n del puntero respecto al inicio del
archivo.

Todas las operaciones de lectura o escritura sobre un archivo avanzan
autom ticamente el puntero del mismo, de forma que todos estos accesos se
realicen de forma secuencial (leyendo o escribiendo los datos unos a
continuaci¢n de otros).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_ftell;

GLOBAL
    mitabla[3]=11,22,33,44;
    midato1;
    midato2;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");

    midato1=ftell(mihandle); // Posici¢n del puntero antes de escribir

    fwrite(OFFSET mitabla,4,mihandle);

    midato2=ftell(mihandle); // Posici¢n del puntero tras escribir los datos

    fclose(mihandle);
END
{-}

Este ejemplo escribe los cuatro datos contenidos en {mitabla} (11,22,33 y 44)
en el archivo {help.dat}.

Tras abrir el archivo con {#223,fopen()}, se obtiene la posici¢n del puntero
y se guarda en {midato1} (esta ser  0, al inicio del archivo).

Entonces se escriben en el archivo los cuatro valores contenidos en la tabla
y se vuelve a obtener la posici¢n del puntero, que ahora se guarda en {midato2}
(ser  4, al final del archivo, tras los cuatro valores escritos).

Finalmente, se cierra el archivo con {#224,fclose()} antes de finalizar.

{/}

{Nota:} Por defecto, la {<posici¢n del puntero>} se especifica como un
n£mero de datos simples, teniendo en cuenta que un dato simple (una variable)
ocupa {4 bytes}. Es decir, que si por ejemplo, el puntero se encuentra en la
posici¢n diez (siempre a partir del inicio del fichero), se podr  entonces
acceder a los datos contenidos en el archivo a partir del byte cuarenta.

Se puede cambiar esta relaci¢n modificando la variable global {#1420,unit_size},
que por defecto vale {4} en todos los programas.

{/}

{Nota:} La funci¢n {#229,filelength()} permite averiguar la longitud de un
archivo, para ello se debe abrir previamente el mismo.

{/}Ver: {#227,fseek()} - {#225,fread()} - {#226,fwrite()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.229,filelength()}

{filelength(}<handle>{)}

{Retorna:}

La longitud del archivo.

{Descripci¢n:}

Esta funci¢n permite obtener la longitud de un archivo previamente abierto
con {#223,fopen()}, para ello requiere como par metro el {<handle>} o
{identificador de archivo} devuelto por dicha funci¢n.

Esta funci¢n no modifica la posici¢n actual del puntero de
lectura/escritura del archivo, simplemente devuelve el n£mero de datos
contenidos actualmente en el mismo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_filelength;

GLOBAL
    mitabla[3]=11,22,33,44;
    longitud;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET mitabla,4,mihandle);
    fclose(mihandle);
    mihandle=fopen("help\help.dat","r");

    longitud=filelength(mihandle); // Obtiene la longitud del archivo (4)

    fclose(mihandle);
END
{-}

Este programa ejemplo crea primeramente un archivo denominado {help.dat},
escribiendo en el los cuatro valores contenidos en {mitabla}.

Una vez creado el archivo en disco, se abrir  para obtener su {longitud}.

{/}

{Nota:} Por defecto, la {longitud del archivo} se obtiene como el n£mero de
datos simples que contiene, teniendo en cuenta que un dato simple (una variable)
ocupa {4 bytes}. Es decir, que si por ejemplo, la longitud de un archivo
es diez, ocupar  cuarenta bytes en el disco.

Se puede cambiar esta relaci¢n modificando la variable global {#1420,unit_size},
que por defecto vale {4} en todos los programas.

{/}

{Nota:} Las funciones {#231,get_dirinfo()} y {#232,get_fileinfo()} permiten
obtener mucha m s informaci¢n sobre la estructura de directorios (carpetas)
del disco y sobre los archivos contenidos en ella.

{/}Ver: {#223,fopen()} - {#231,get_dirinfo()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.230,flush()}

{flush(}{)}

{Retorna:}

El n£mero de archivos abiertos.

{Descripci¢n:}

Vacia los buffers de escritura, es decir, hace que todos los datos escritos
a un archivo de disco que est‚n a£n en la cach‚ de escritura se graben
f¡sicamente en su archivo correspondiente.

Esta operaci¢n no suele ser necesaria nunca, ya que la administraci¢n de la
cach‚ que realiza el sistema operativo es muy efectiva, y no van a perderse
nunca datos por que no se escriban directamente al disco.

No obstante, esta funci¢n tiene otra utilidad, y es que devuelve el {numero
de archivos abiertos con} {#223,fopen()} dentro de un programa.

El sistema de archivos permite £nicamente un m ximo de archivos abiertos, que
depende de la configuraci¢n del sistema operativo.

Deber n cerrarse con {#224,fclose()} todos los archivos una vez se haya
realizado con ellos la operaci¢n oportuna. Esta £ltima funci¢n permite
cerrar un s¢lo archivo, o todos los que est‚n abiertos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_flush;

GLOBAL
    midato1;
    midato2;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");

    midato1=flush(); // Obtiene el n£mero de archivos abiertos (1)

    fclose(mihandle);

    midato2=flush(); // Obtiene el n£mero de archivos abiertos (0)

END
{-}

Este ejemplo obtiene en dos ocasiones el n£mero de archivos abiertos
con la funci¢n {flush()}. Tras aberse abierto el archivo {help.dat} la
funci¢n determina que hay abierto uno y, una vez cerrado el mismo,
se podr  comprobar como ya no hay ninguno.

{/}Ver: {#223,fopen()} - {#224,fclose()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.231,get_dirinfo()}

{get_dirinfo(}<m scara de directorio>{,} <tipos de archivo>{)}

{Retorna:}

N£mero de archivos del directorio que coinciden con la m scara y el tipo
seleccionado.

{Descripci¢n:}

Esta funci¢n permite obtener la lista de archivos de un directorio (carpeta)
del disco.

Se requiere la {<m scara del directorio>} para seleccionar los archivos
que deben listarse. Esta {<m scara>} no es m s que un nombre de archivo
parcial, utilizando comodines; por ejemplo, la m scara {"*.*"} (se debe
indicar como un texto entre comillas) seleccionar  todos los archivos del
directorio.

Tambi‚n se puede incluir en la m scara la {ruta de acceso} del directorio (en
caso contrario se listar n los archivos del directorio actual). Por ejemplo,
la m scara {"C:\WINDOWS\SYS*.??E"} seleccionar¡a todos los archivos del
directorio {"C:\WINDOWS"} cuyo nombre comenzara por {"SYS"} y su extensi¢n
acabara en {"E"}.

Como segundo par metro se debe indicar los {<tipos de archivos>} que deben
incluirse en la lista, estos son los siguientes:

{ _normal} - Listar s¢lo los archivos normales.ú
{ _hidden} - Incluir tambi‚n los archivos ocultos.ú
{ _system} - Incluir tambi‚n los archivos del sistema.ú
{ _subdir} - Incluir tambi‚n los subdirectorios.ú
{ _volid}  - Listar s¢lo la etiqueta del volumen.ú

Lo m s usual es indicar {_normal} como {<tipo de archivos>}, este tipo
engloba a la gran mayor¡a de archivos que aparecen en un disco, tanto de
lectura/escritura, como de s¢lo lectura (£nicamente no se incluyen algunos
archivos especiales, que normalmente son archivos internos del sistema
operativo).

Si se indican {_hidden}, {_system} o {_subdir}, se incluir n estos tipos
de archivos adem s de los normales (no es necesario especificar {_normal}).
Adem s pueden sumarse estos tipos; por ejemplo, indicando {_hidden+_system}
se listar n todos los archivos normales, los ocultos y los del sistema.

Cuando se indique {_volid}, £nicamente se listar  el nombre de la etiqueta
de volumen del disco, no se incluir  ning£n archivo ni subdirectorio en la
lista (no se pueden sumar otros tipos a este).

{/}

La funci¢n {get_dirinfo()} simplemente retorna el {n£mero total} de archivos
listados; los nombres de estos archivos se guardan en la estructura global
{#1413,dirinfo} (el primer nombre de archivo se guarda en {dirinfo.name[0]}, el
segundo en {dirinfo.name[1]}, etc.).

El {n£mero total} de archivos listados que retorna esta funci¢n se guarda
adem s en {dirinfo.files}.

La lista de nombres de archivos se guarda siempre en orden alfab‚tico, no
obstante se puede utilizar la funci¢n {#213,qsort()} para ordenar la estructura
global {#1413,dirinfo} por cualquier otro criterio.

{/}

Esta funci¢n £nicamente permite obtener los {nombres} de los archivos, para
obtener m s informaci¢n de los mismos (los atributos, el tama¤o, la fecha,
etc.) se debe utilizar la funci¢n {#232,get_fileinfo()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_dirinfo;

GLOBAL
    contador;

BEGIN
    write(0,0,0,0,"Listado de archivos - Pulse ESC para terminar");

    get_dirinfo("C:\WINDOWS\*.EXE",_normal); // Obtiene el listado de archivos

    FOR (contador=0;contador<dirinfo.files;contador++)
       x=(contador%4)*80;
       y=16+(contador/4)*8;
       write(0,x,y,0,dirinfo.name[contador]);
    END

    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa ejemplo lista todos los archivos {EXE} normales del directorio
C:\WINDOWS, y entonces los muestra en pantalla.

El bucle {#1025,FOR} es el encargado de mostrar en pantalla la lista de
archivos de la estructura {#1413,dirinfo} a cuatro columnas, ya que la funci¢n
{get_dirinfo()} no muestra ninguna informaci¢n en pantalla, £nicamente
rellena la estructura con los nombres de los archivos encontrados en
el directorio.

{/}

Para abrir o crear un archivo se puede utilizar la funci¢n {#223,fopen()}.

Para cambiar de directorio se debe utilizar {#235,chdir()}, y
{#236,mkdir()} para crear uno nuevo.

La funci¢n {#238,disk_free()} permite averiguar el espacio libre que queda
en una unidad de disco.

{/}Ver: {#232,get_fileinfo()} - {#223,fopen()} - {#235,chdir()} - {#236,mkdir()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.232,get_fileinfo()}

{get_fileinfo(}<nombre de archivo>{)}

{Retorna:}

{0} - No se pudo obtener informaci¢n sobre el archivo.ú
{1} - La informaci¢n del archivo se guard¢ correctamente.ú

{Descripci¢n:}

Obtiene informaci¢n sobre un archivo o directorio del disco, para ello,
la funci¢n requiere el {<nombre del archivo>} como par metro (entre comillas).
Se puede indicar £nicamente el nombre, o incluir adem s la ruta de acceso
al mismo.

Si la funci¢n encuentra dicho archivo en el directorio especificado (o en
el actual, en caso de no especificar ninguno), retornar  {1} y guardar 
toda la informaci¢n sobre el archivo en la estructura global {#1414,fileinfo},
que contiene los siguientes campos:

{ fullpath} - Nombre completo (incluyendo la ruta).ú
{ drive}    - Unidad de disco (1-A:, 2-B:, 3-C:, ...).ú
{ dir}      - Directorio del archivo.ú
{ name}     - Nombre del archivo.ú
{ ext}      - Extensi¢n del archivo.ú
{ size}     - Tama¤o (en datos simples, ver {#1420,unit_size}).ú
{ day}      - D¡a (fecha de £ltima actualizaci¢n).ú
{ month}    - Mes (fecha de £ltima actualizaci¢n).ú
{ year}     - A¤o (fecha de £ltima actualizaci¢n).ú
{ hour}     - Hora (hora de £ltima actualizaci¢n).ú
{ min}      - Minuto (hora de £ltima actualizaci¢n).ú
{ sec}      - Segundo (hora de £ltima actualizaci¢n).ú
{ attrib}   - Atributos del archivo.ú

La ruta de acceso al archivo se puede especificar completa (a partir del
directorio raiz de la unidad, como "C:\WINDOWS\...") o relativa al directorio
actual (a partir de donde se ejecute el juego, como "MAP\MIOS\...").
En cualquier caso, en {fileinfo.fullpath} siempre se devolver  la ruta
completa a partir del directorio raiz, incluyendo la letra de la unidad.

{/}

La funci¢n {get_fileinfo()} £nicamente obtiene informaci¢n sobre un archivo,
para obtener la lista completa de archivos de un directorio, se debe
utilizar la funci¢n {#231,get_dirinfo()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_get_fileinfo;
BEGIN
    // ...

    get_fileinfo("HELP\HELP.FPG");

    // ...
END
{-}

Este peque¤o ejemplo solicita informaci¢n sobre el fichero {help.fpg}
contenido en el directorio {help}. Se puede extraer y trazar (con {F12})
para observar como, tras llamar a la funci¢n, la estructura global
predefinida {#1413,fileinfo} se ha rellenado con todos los datos del archivo.

{/}

Para abrir o crear un archivo se puede utilizar la funci¢n {#223,fopen()},
y para borrar un archivo existente en el disco se utiliza {#237,remove()}.

La funci¢n {#238,disk_free()} permite averiguar el espacio libre que queda
en una unidad de disco.

{/}Ver: {#231,get_dirinfo()} - {#223,fopen()} - {#237,remove()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.233,getdrive()}

{getdrive(}{)}

{Retorna:}

El n£mero de la unidad de disco actual.

{Descripci¢n:}

Esta funci¢n permite determinar cual es la unidad de disco que esta siendo
utilizada actualmente, esta se devuelve como un n£mero, correspondi‚ndose
el {1} con la unidad {A:}, el {2} con {B:}, {3} con {C:}, etc. No se requieren
par metros en la llamada.

La funci¢n {#234,setdrive()} permite establecer la unidad de disco actual;
todos los accesos a disco (lectura y escritura de archivos) se efect£an
siempre dentro de una unidad seleccionada que, por defecto, ser  la unidad
en la que se ejecute el programa.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_getdrive;

GLOBAL
    unidad;

BEGIN
    write(0,0,0,0,"Unidad de disco actual:");

    unidad=getdrive();

    write_int(0,0,20,0,OFFSET unidad);
    LOOP
        FRAME;
    END
END
{-}

Este programa muestra en pantalla el n£mero de unidad actual obtenido
con la funci¢n {getdrive()}.

{/}

Para cambiar de directorio se debe utilizar {#235,chdir()}, y
{#236,mkdir()} para crear uno nuevo.

La funci¢n {#238,disk_free()} permite averiguar el espacio libre que queda
en una unidad de disco.

{/}Ver: {#234,setdrive()} - {#235,chdir()} - {#236,mkdir()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.234,setdrive()}

{setdrive(}<unidad>{)}

{Descripci¢n:}

Esta funci¢n permite establecer la unidad de disco actual;
todos los accesos a disco (lectura y escritura de archivos) se efect£an
siempre dentro de una unidad seleccionada que, por defecto, ser  la unidad
en la que se ejecute el programa.

La {<unidad>} se debe indicar con un n£mero, correspondi‚ndose
el {1} con la unidad {A:}, el {2} con {B:}, {3} con {C:}, etc. No se retorna
ning£n valor.

La funci¢n {#233,getdrive()} permite obtener el n£mero de unidad actual.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_setdrive;

GLOBAL
    unidad;

BEGIN
    // ...

    unidad=getdrive();

    setdrive(1);      // Se sit£a en la unidad A:

    // ...

    setdrive(unidad); // Recupera la unidad anterior

    // ...
END
{-}

Este programa obtiene primero la unidad actual con la funci¢n {#233,getdrive()}
y la guarda en la variable {unidad}, entonces se situa en la unidad {1} (A:)
para, finalmente, volver a la unidad en la que se est‚ ejecutando el programa.

{/}

{Nota:} Al cambiar a otra unidad con {setdrive()} no se retorna ning£n valor,
pero se puede llamar despu‚s a {#233,getdrive()} para comprobar que el programa
se ha situado en la unidad solicitada.

{/}

Para cambiar de directorio se debe utilizar {#235,chdir()}, y
{#236,mkdir()} para crear uno nuevo.

La funci¢n {#238,disk_free()} permite averiguar el espacio libre que queda
en una unidad de disco.

{/}Ver: {#233,getdrive()} - {#235,chdir()} - {#236,mkdir()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.235,chdir()}

{chdir(}<directorio>{)}

{Retorna:}

{1} - Se cambi¢ al directorio indicado.ú
{0} - No se pudo acceder a dicho directorio.

{Descripci¢n:}

Cambia el directorio actual, dentro de la unidad seleccionada.

El directorio se debe indicar como un literal (un texto entre comillas), y
puede ser una ruta relativa (a partir del directorio actual) o una ruta
absoluta (a partir del directorio raiz).

La forma de utilizaci¢n y posibilidades de esta funci¢n son las mismas
que las del comando {CD} de la l¡nea de comandos del sistema operativo.

Todos los programas se sit£an inicialmente en el directorio en el que
se encuentra su ejecutable principal.

Se pueden crear nuevos directorios (o carpetas) en la estructura de un
disco con la funci¢n {#236,mkdir()}, y con la funci¢n {#237,remove()} se
pueden eliminar los existentes.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_chdir;
BEGIN
    chdir("MAP"); // Se sit£a en el directorio MAP\

    // ...

    chdir("..");  // Vuelve al directorio anterior
END
{-}

Este peque¤o ejemplo muestra como debe utilizarse la funci¢n {chdir()} para
cambiar de directorio.

{/}

La funci¢n {#234,setdrive()} permite establecer la unidad de disco actual
y la funci¢n {#233,getdrive()} averiguarlo; todos los accesos a disco
(lectura y escritura de archivos) se efect£an siempre dentro de una unidad
seleccionada que, por defecto, ser  la unidad en la que se ejecute el
programa.

{/}

{Nota:} Se puede obtener la lista de archivos de un directorio con la
funci¢n {#231,get_dirinfo()}.

{/}Ver: {#236,mkdir()} - {#237,remove()} - {#234,setdrive()} - {#233,getdrive()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.236,mkdir()}

{mkdir(}<directorio>{)}

{Descripci¢n:}

Crea un directorio nuevo (dentro del directorio o carpeta actual).

Se debe indicar el nombre del directorio a crear como un literal (un texto
entre comillas).

La forma de utilizaci¢n y posibilidades de esta funci¢n son las mismas
que las del comando {MD} de la l¡nea de comandos del sistema operativo.

Todos los programas se sit£an inicialmente en el directorio en el que
se encuentra su ejecutable principal.

Se pueden cambiar el directorio en el que est  situado un programa (en el
que realizar  sus operaciones de archivos) con la funci¢n {#235,chdir()}, y
con la funci¢n {#237,remove()} se pueden eliminar los directorios existentes.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_mkdir;
BEGIN
    mkdir("temporal"); // Crea un nuevo directorio

    // ...
    remove("temporal");
END
{-}

Este peque¤o ejemplo muestra como debe utilizarse la funci¢n {mkdir()} para
crear un directorio, y despu‚s lo elimina con la funci¢n {#237,remove()}.

{/}

La funci¢n {#234,setdrive()} permite establecer la unidad de disco actual
y la funci¢n {#233,getdrive()} averiguarlo; todos los accesos a disco
(lectura y escritura de archivos) se efect£an siempre dentro de una unidad
seleccionada que, por defecto, ser  la unidad en la que se ejecute el
programa.

{/}

{Nota:} Se puede obtener la lista de archivos de un directorio con la
funci¢n {#231,get_dirinfo()}.

{/}Ver: {#235,chdir()} - {#237,remove()} - {#234,setdrive()} - {#233,getdrive()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.237,remove()}

{remove(}<nombre de archivo o directorio>{)}

{Descripci¢n:}

Borra archivos o subdirectorios contenidos dentro del directorio actual
en el que se ejecuta el programa.

Se debe indicar el {<nombre de archivo o directorio>} en un literal (un texto
entre comillas), tambi‚n se aceptan los car cteres comod¡n "?" y "*" (como
por ejemplo "*.bak" para eliminar todos los archivos con extensi¢n BAK).

Se eliminar n siempre los archivos dentro del directorio actual (ver {#235,chdir()}
para cambiar de directorio) y de la unidad actual (ver {#234,setdrive()} para
cambiar de unidad).

Con esta funci¢n tambi‚n se pueden eliminar directorios, pero £nicamente
si est n vacios (si no contienen archivos u otros subdirectorios dentro).

{/}

{Nota:} Esta funci¢n debe utilizarse con precauci¢n, ya que los archivos
borrados no podr n recuperarse, y puede perderse informaci¢n o programas
contenidos en el disco.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_remove;
BEGIN
    mkdir("temporal");
    // ...

    remove("temporal"); // Elimina un directorio
END
{-}

Este peque¤o ejemplo crea un directorio con la funci¢n {#236,mkdir()} y despu‚s
lo elimina con la funci¢n {remove()}.

{/}

{Nota:} Se puede obtener la lista de archivos de un directorio con la
funci¢n {#231,get_dirinfo()}.

{/}Ver: {#235,chdir()} - {#234,setdrive()} - {#231,get_dirinfo()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.238,disk_free()}

{disk_free(}<unidad>{)}

{Retorna:}

El espacio libre de la unidad de disco.

{Descripci¢n:}

Esta funci¢n permite determinar el espacio libre de cualquier unidad de disco.

Se requiere el n£mero de {<unidad>} como £nico par metro, correspondi‚ndose
el {1} con la unidad {A:}, el {2} con {B:}, {3} con {C:}, etc.

El espacio disponible en la unidad se retorna en {Kbs} (en kilobytes,
siendo cada uno un total de 1024 bytes).

Se puede averiguar cual es la unidad de disco actual (en la que se est‚
ejecutando el programo) gracias a la funci¢n {#233,getdrive()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_disk_free;

GLOBAL
    unidad;
    espacio_libre;

BEGIN
    // ...

    unidad=getdrive();
    espacio_libre=disk_free(unidad);

    // ...
END
{-}

Este programa utiliza primeramente la funci¢n {#233,getdrive()} para
determinar en que unidad de disco se est  ejecutando el programa (que
se almacena en la variable {unidad}), y entonces determina el espacio
libre disponible en la misma con {disk_free()}.

{/}

Para obtener el tama¤o de los archivos del disco se deben utilizar
conjuntamente las funciones {#231,get_dirinfo()} y {#232,get_fileinfo()}.

{/}

{Nota:} La funci¢n {#239,memory_free()} permite determinar la memoria libre,
es decir, la cantidad de memoria que queda disponible para el programa.

{/}Ver: {#233,getdrive()} - {#239,memory_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.239,memory_free()}

{memory_free(}{)}

{Retorna:}

La memoria libre disponible para el programa.

{Descripci¢n:}

Esta funci¢n permite determinar la cantidad de memoria RAM del ordenador
que queda disponible para uso del programa.

No se requiere ning£n par metro, y el total de memoria se retorna en Kbs
(en kilobytes, siendo cada uno un total de 1024 bytes).

Esta cantidad de memoria ser  la que el programa dispone para cargar
todos sus recursos (gr ficos, sonidos, etc.), por ello es conveniente
comprobar con esta funci¢n, al inicio de los programas, que el ordenador
dispone de memoria suficiente para cargar todos los recursos necesarios.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_memory_free;

GLOBAL
    memoria_libre;

BEGIN
    // ...

    memoria_libre=memory_free();

    // ...
END
{-}

Este peque¤o ejemplo utiliza la funci¢n {memory_free()} para guardar
en la variable global denominada {memoria_libre} la cantidad de RAM que
queda disponible para el programa.

{/}

{Nota:} La funci¢n {#238,disk_free()} permite determinar el espacio libre
de una de las unidades de disco del ordenador.

{/}Ver: {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.240,ignore_error()}

{ignore_error(}<n£mero de error>{)}

{Descripci¢n:}

Esta funci¢n permite ignorar un error de ejecuci¢n determinado, para
ello se requiere como par metro el {<n£mero de error>}; este es el n£mero
presente en la ventana informativa de un error que aparece en ocasiones
cuando un programa se est  ejecutando.

En un principio, no es recomendable ignorar los errores de ejecuci¢n,
ya que el programa se comportar  anormalmente cuando suceda un error,
sin dar ninguna informaci¢n relativa al error que ha sucedido.

Cuando un programa produce un error de ejecuci¢n, siempre es por una
causa que puede solucionarse; e ignorar el error no solucionar  el problema.

{/}

{Nota:} No todos los errores pueden ser ignorados, hay algunos errores que
imposiblitan que el programa contin£e ejecut ndose de ninguna forma;
estos son los errores denominados "graves", que siempre abortar n el
programa en el caso de darse.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_ignore_error;
BEGIN

    ignore_error(145); // Ignorar las divisiones entre cero

    x=x/0;
END
{-}

En este ejemplo se llama a la funci¢n {ignore_error()} para advertir
al sistema de que, en adelante, debe ignorar las divisiones por cero
(estas dar n un resultado indeterminado).

A continuaci¢n se realiza una divisi¢n por cero, para que se pueda
comprobar como no se emite ninguna ventana informativa de dicho error.

Este error es el n£mero {145}, se puede observar el mismo comentando la
llamada a la funci¢n {ignore_error()} del ejemplo anterior.

{/}

{Lista de c¢digos de los errores de ejecuci¢n:}

{100} No hay memoria suficiente para ejecutar el programa.ú
{101} Llamada a key() con un c¢digo de tecla inexistente.ú
{102} No se pudo cargar la paleta, archivo no encontrado.ú
{103} Se intent¢ cargar un archivo de paleta inv lido.ú
{104} Demasiados ficheros FPG abiertos a la vez.ú
{105} No se pudo cargar el fichero, archivo no encontrado.ú
{106} Se intent¢ cargar un fichero FPG no v lido.ú
{107} N£mero de scroll inv lido (debe estar entre 0 y 9).ú
{108} N£mero de regi¢n inv lido (fuera de rango).ú
{109} C¢digo de fichero inv lido.ú
{110} C¢digo de gr fico inv lido.ú
{111} Se intent¢ usar un fichero FPG antes de cargarlo.ú
{112} Se necesita un c¢digo de gr fico para el scroll.ú
{113} Se han cargado demasiados fuentes de letras.ú
{114} No se pudo cargar el fuente, archivo no encontrado.ú
{115} Se intent¢ cargar un archivo de fuente no v lido.ú
{116} C¢digo identificador de fuente de letras inv lido.ú
{117} C¢digo de centrado de texto inv lido.ú
{118} Hay demasiados textos activos en el programa.ú
{119} Indentificador de texto no v lido.ú
{120} Regi¢n de pantalla definida incorrectamente.ú
{121} Se intent¢ utilizar un gr fico que no existe.ú
{122} Se intent¢ escribir un bloque fuera de la memoria.ú
{123} No se pudo abrir el archivo para escritura.ú
{124} No se pudo escribir el archivo (ver espacio en disco).ú
{125} Se intent¢ leer un bloque fuera de la memoria.ú
{126} No se pudo abrir el archivo para lectura.ú
{127} No se pudo leer el archivo.ú
{128} No se pudo cargar el efecto de sonido.ú
{129} No se pudo tocar el efecto de sonido solicitado.ú
{130} No se pudo iniciar la animaci¢n solicitada.ú
{131} N£mero de modo 7 inv lido (debe estar entre 0 y 9).ú
{132} Se necesita un c¢digo de gr fico para el modo 7.ú
{133} N£mero de punto de control inv lido.ú
{134} N£mero de bot¢n incorrecto (debe estar entre 0 y 3).ú
{135} N£mero de eje incorrecto (debe estar entre 0 y 3).ú
{136} Direcci¢n de la tabla de paleta fuera de la memoria.ú
{137} No se pueden comprobar regiones en gr ficos de m-7.ú
{138} C¢digo de informaci¢n gr fica incorrecto.ú
{139} No se pueden comprobar colisiones en gr ficos de m-7.ú
{140} Acceso fuera de rango.ú
{141} Se intent¢ acceder a un proceso inv lido.ú
{142} El proceso parece bloqueado, esperando FRAME.ú
{143} No se pudo cargar el mapa, archivo no encontrado.ú
{144} Se intent¢ cargar un archivo de mapa inv lido.ú
{145} Se ha intentado hacer una divisi¢n entre cero.ú
{146} El tama¤o de la regi¢n es incorrecto.ú
{147} No se pudo cargar FLI/FLC, archivo no encontrado.ú
{148} Valor de timeout incorrecto (debe ser entre 1 y 60).ú
{149} N£mero de jugadores incorrecto (debe ser entre 2 y 8).ú
{150} S¢lo se pueden enviar datos globales.ú
{151} Tama¤o de casilla inv lido (debe ser entre 1 y 256).ú
{152} Mapa de b£squeda no v lido (desde 1x1 hasta 128x128).ú
{153} Tama¤o de mapa incorrecto (de 1x1 a 32768x32768).ú
{154} N£mero de color incorrecto (debe ser de 0 a 255).ú
{155} El centro est  fuera de los l¡mites del gr fico.ú
{156} El objeto se encuentra fuera del mapa y sera eliminado.ú
{157} Textura del mapa no encontrada.ú
{158} El tama¤o de la textura es incorrecto.ú
{159} No se pudo cargar el mundo, archivo no encontrado.ú
{160} No se pudo cargar el mundo, archivo no v lido.ú
{161} El n£mero de bandera no es v lido.ú
{162} Dispositivo inv lido (s¢lo 1-IPX,2-SERIAL,3-MODEM).ú
{163} Tama¤o de paquete inv lido (s¢lo de 1 a 199).ú
{164} La cadena de texto destino no es v lida.ú
{165} Se intent¢ acceder a un puntero nulo.ú
{166} El modo de acceso al archivo no es v lido.ú
{167} No se pudo cargar el m¢dulo.ú
{168} Demasiados errores ignorados.ú
{169} Demasiados archivos abiertos.ú
{170} Identificador de archivo (handle) no v lido.ú
{171} Valor fuera de rango.ú
{172} Demasiados objetos gr ficos visualizados.ú
{173} Tipo de objeto gr fico no conocido.ú
{174} Porcentaje de tinta fuera de rango (0..15).ú
{175} N£mero de objeto gr fico no v lido.ú
{176} Error variable de vpe: Textura de mapa [a] no encontrada en fichero [b].ú
{177} Textura de mapa.ú
{178} no encontrada en fichero.ú
{179} Se realizaron demasiadas peticiones de memoria din mica.ú
{180} El puntero no se corresponde con ninguno de los bloques reservados.ú
{181} No se pueden reservar bloques de menos de una posici¢n.ú
{182} Se intent¢ (des)encriptar un bloque fuera de la memoria.ú
{183} No se puede cargar otra paleta cuando est  forzada la actual.ú
{200} Archivo con datos corrompidos, no se pudo cargar.ú

{/}

{Nota:} Mediante las opciones de compilaci¢n (ver {#1400,Compiler_options}) se
pueden ignorar todos los errores de ejecuci¢n "no-graves", no obstante,
esta pr ctica es m s que poco recomendable.

{/}Ver: {#1400,Compiler_options}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.241,save_map() / save_pcx()}

{save_map(}<fichero>{,} <gr fico>{,} <nombre del archivo>{)}

{save_pcx(}<fichero>{,} <gr fico>{,} <nombre del archivo>{)}

{Retorna:}

{1} - Si el archivo se grab¢ con ‚xito.ú
{0} - Se produjo un error al guardar el archivo.

{Descripci¢n:}

Crea un archivo MAP o PCX a partir de un gr fico cargado en memoria.

La funci¢n requiere los c¢digos de {<fichero>} y {<gr fico>} que identifican
al gr fico, y el {<nombre del archivo> MAP} o {PCX} que debe crearse en
el disco conteniendo dicha imagen. El nombre de archivo se debe especificar
como un literal (un texto entre comillas, como "imagen.pcx").

Los gr ficos cargados con las funciones {#174,load_map()} o {#174,load_pcx()}
(o creados con {#188,new_map()}) se utilizar n como
si pertenecieran al primer fichero (el fichero con el c¢digo 0).

La funci¢n {save_map()} siempre crear  archivos {MAP}, as¡ como {save_pcx()}
crear  s¢lo archivos {PCX}, {independientemente de la extensi¢n indicada} en el
{<nombre de archivo>}. Si no se produce ning£n error, la funci¢n crear  el archivo
con la imagen y retornar  {1}.

{/}

Estos mapas podr n despu‚s cargarse dentro del entorno gr fico de
DIV Games Studio o en los programas, utilizando las funciones
{#174,load_map()} o {#174,load_pcx()}.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_save_map;
BEGIN
    load_fpg("help\help.fpg");

    save_pcx(0,1,"help\help.pcx"); // Crea un archivo PCX

END
{-}

En este ejemplo utiliza la funci¢n {save_pcx()} para crear un archivo
PCX conteniendo una imagen previamente cargada dentro del fichero
{help.fpg} con la funci¢n {#132,load_fpg()}.

{/}

Se puede crear un gr fico con la funci¢n {#188,new_map()}, y para
modificar un gr fico se deben utilizar las siguientes funciones:

{#135,map_block_copy()} - Transfiere un bloque de un gr fico a otro.ú
{#136,map_get_pixel()} - Obtiene el color de un punto de un gr fico.ú
{#137,map_put()} - Pone un gr fico en otro.ú
{#138,map_put_pixel()} - Fija el color de un punto en un gr fico.ú
{#139,map_xput()} - Pone un gr fico en otro, con efectos.ú

{/}

{Nota:} La funci¢n {#253,write_map()} permite escribir un texto en
un gr fico creado en memoria (en lugar de escribir en la pantalla).

{/}Ver: {#174,load_map/pcx()} - {#176,unload_map/pcx()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.242,sin()}

{sin(}< ngulo>{)}

{Retorna:}

El seno de un  ngulo dado.

{Descripci¢n:}

Calcula el seno en mil‚simas del  ngulo pasado como par metro.

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), y el seno se devolver  igualmente
en mil‚simas (como un valor de -1000 a 1000).

Por ejemplo, {sin(90000)} devolver  {1000}, ya que el seno de 90 grados es 1.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_sin;

GLOBAL
     ngulo[15];
    seno[15];
    n;

BEGIN
    write(0,0,0,0,"Angulos");
    write(0,160,0,0,"Senos");
    FROM n=0 TO 15;
         ngulo[n] = rand(0, 360000);

        seno[n] = sin( ngulo[n]); // Se calcula el seno del  ngulo

        write_int(0, 0,   20+n*10, 0, offset  ngulo[n]);
        write_int(0, 160, 20+n*10, 0, offset seno[n]);
    END
    write(0,0,192,0,"Pulse ESC para terminar ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa imprimir  en pantalla una lista de  ngulos, aleatoriamente
escogidos entre 0 y 360000 (de 0 a 360 grados), y utilizar  la funci¢n
{sin()} para calcular el seno de los mismos.

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.243,cos()}

{cos(}< ngulo>{)}

{Retorna:}

El coseno de un  ngulo dado.

{Descripci¢n:}

Calcula el coseno en mil‚simas del  ngulo pasado como par metro.

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), y el coseno se devolver  igualmente
en mil‚simas (como un valor de -1000 a 1000).

Por ejemplo, {cos(0)} devolver  {1000}, ya que el coseno de 0 grados es 1.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_cos;

GLOBAL
     ngulo[15];
    coseno[15];
    n;

BEGIN
    write(0,0,0,0,"Angulos");
    write(0,160,0,0,"Cosenos");
    FROM n=0 TO 15;
         ngulo[n] = rand(0, 360000);

        coseno[n] = cos( ngulo[n]); // Se calcula el coseno del  ngulo

        write_int(0, 0,   20+n*10, 0, offset  ngulo[n]);
        write_int(0, 160, 20+n*10, 0, offset coseno[n]);
    END
    write(0,0,192,0,"Pulse ESC para terminar ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa imprimir  en pantalla una lista de  ngulos, aleatoriamente
escogidos entre 0 y 360000 (de 0 a 360 grados), y utilizar  la funci¢n
{cos()} para calcular el coseno de los mismos.

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.244,tan()}

{tan(}< ngulo>{)}

{Retorna:}

La tangente de un  ngulo dado.

{Descripci¢n:}

Calcula la tangente en mil‚simas del  ngulo pasado como par metro.

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), y la tangente se devolver  igualmente
en mil‚simas (como un valor dentro del rango {#1177,min_int} ... {#1178,max_int}).

Por ejemplo, {tan(45000)} devolver  {1000}, ya que la tangente de 45 grados
es 1.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_tan;

GLOBAL
     ngulo[15];
    tangente[15];
    n;

BEGIN
    write(0,0,0,0,"Angulos");
    write(0,160,0,0,"Tangentes");
    FROM n=0 TO 15;
         ngulo[n] = rand(0, 360000);

        tangente[n] = tan( ngulo[n]); // Se calcula la tangente del  ngulo

        write_int(0, 0,   20+n*10, 0, offset  ngulo[n]);
        write_int(0, 160, 20+n*10, 0, offset tangente[n]);
    END
    write(0,0,192,0,"Pulse ESC para terminar ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa imprimir  en pantalla una lista de  ngulos, aleatoriamente
escogidos entre 0 y 360000 (de 0 a 360 grados), y utilizar  la funci¢n
{tan()} para calcular la tangente de los mismos.

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.245,asin()}

{asin(}<seno>{)}

{Retorna:}

El arcoseno de un seno dado.

{Descripci¢n:}

Calcula el arcoseno del seno pasado como par metro en mil‚simas, es decir,
se obtiene el  ngulo correspondiente a un seno (operaci¢n inversa
al seno, que se puede obtener con la funci¢n {#242,sin()}).

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), por ello el arcoseno se devuelve
tambi‚n en mil‚simas.

El {<seno>} se requiere como un valor de{ -1000} a {1000} (de -1.0 a +1.0),
y el resultado se devuelve como un  ngulo entre{ -90000} y {90000} (de -90
a +90 grados).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_asin;

GLOBAL
    seno[15];
     ngulo[15];
    n;

BEGIN
    write(0,0,0,0,"Seno");
    write(0,160,0,0,"Arcoseno( ngulo)");
    FROM n=0 TO 15;
        seno[n] = rand(-1000, 1000);

         ngulo[n] = asin(seno[n]); // Se calcula el arcoseno de un seno

        write_int(0, 0,   20+n*10, 0, offset seno[n]);
        write_int(0, 160, 20+n*10, 0, offset  ngulo[n]);
    END
    write(0,0,192,0,"Pulse ESC para terminar ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa imprimir  en pantalla una lista de senos, aleatoriamente
escogidos entre -1000 y 1000 (se representan en mil‚simas), y utilizar  la
funci¢n {asin()} para calcular el arcoseno de los mismos.

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.246,acos()}

{acos(}<coseno>{)}

{Retorna:}

El arcocoseno de un coseno dado.

{Descripci¢n:}

Calcula el arcocoseno del coseno pasado como par metro en mil‚simas, es decir,
se obtiene el  ngulo correspondiente a un coseno (operaci¢n inversa
al coseno, que se puede obtener con la funci¢n {#243,cos()}).

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), por ello el arcocoseno se devuelve
tambi‚n en mil‚simas.

El {<coseno>} se requiere como un valor de{ -1000} a {1000} (de -1.0 a +1.0),
y el resultado se devuelve como un  ngulo entre{ 0} y {180000} (de 0
a 180 grados).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_acos;

GLOBAL
    coseno[15];
     ngulo[15];
    n;

BEGIN
    write(0,0,0,0,"Coseno");
    write(0,160,0,0,"Arcocoseno( ngulo)");
    FROM n=0 TO 15;
        coseno[n] = rand(-1000, 1000);

         ngulo[n] = acos(coseno[n]); // Se calcula el arcocoseno de un coseno

        write_int(0, 0,   20+n*10, 0, offset coseno[n]);
        write_int(0, 160, 20+n*10, 0, offset  ngulo[n]);
    END
    write(0,0,192,0,"Pulse ESC para terminar ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa imprimir  en pantalla una lista de cosenos, aleatoriamente
escogidos entre -1000 y 1000 (se representan en mil‚simas), y utilizar  la
funci¢n {acos()} para calcular el arcocoseno de los mismos.

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.247,atan()}

{atan(}<tangente>{)}

{Retorna:}

La arcotangente de una tangente dada.

{Descripci¢n:}

Calcula la arcotangente de la tangente pasada como par metro en mil‚simas, es decir,
se obtiene el  ngulo correspondiente a una tangente (operaci¢n inversa
a la tangente, que se puede obtener con la funci¢n {#244,tan()}).

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), por ello la arcotangente se devuelve
tambi‚n en mil‚simas.

La {<tangente>} se requiere como un valor dentro del rango {#1177,min_int}
... {#1178,max_int} (de -inf a +inf), y el resultado se devuelve como un  ngulo
entre{ -90000} y {90000} (de -90 a +90 grados).

{/}

{Nota:} Existe otra funci¢n para calcular la arcotangente llamada {#248,atan2()},
dicha funci¢n toma como par metros {<x>} e {<y>} y devuelve la arcotangente
de {y/x} entre -180000 y 180000 (de -180 a 180 grados).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_atan;

GLOBAL
    tangente[15];
     ngulo[15];
    n;

BEGIN
    write(0,0,0,0,"Tangente");
    write(0,160,0,0,"Arcotangente( ngulo)");
    FROM n=0 TO 15;
        tangente[n] = rand(-1000, 1000);

         ngulo[n] = atan(tangente[n]); // Se calcula la arcotangente de una tangente

        write_int(0, 0,   20+n*10, 0, offset tangente[n]);
        write_int(0, 160, 20+n*10, 0, offset  ngulo[n]);
    END
    write(0,0,192,0,"Pulse ESC para terminar ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa imprimir  en pantalla una lista de tangentes, aleatoriamente
escogidas entre -1000 y 1000 (-1.0 y 1.0), y utilizar  la funci¢n {atan()}
para calcular la arcotangente de las mismas (entre -45 y 45 grados).

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.248,atan2()}

{atan2(}<x>{,} <y>{)}

{Retorna:}

La arcotangente de {<y>}/{<x>}.

{Descripci¢n:}

Calcula la arcotangente de la tangente obtenida de dividir los dos
valores pasados como par metro ({<y>}/{<x>}), es decir,
se obtiene el  ngulo correspondiente a una tangente (operaci¢n inversa
a la tangente, que se puede obtener con la funci¢n {#244,tan()}).

Los  ngulos se manipulan siempre en mil‚simas de grado (ver el
{#1044,uso de  ngulos en el lenguaje}), por ello la arcotangente se devuelve
tambi‚n en mil‚simas como un valor entre{ -180000} y {180000} (de -180 a +180
grados).

{/}

{Nota 1:} Existe otra funci¢n para calcular la arcotangente llamada
simplemente {#248,atan()}, dicha funci¢n toma como £nico par metro la
propia tangente y devuelve su arcotangente entre -90000 y 90000 (de -90
a 90 grados).

{/}

{Nota 2:} Tambi‚n se puede encontrar una versi¢n de {atan2()}, adaptada a los
conceptos geom‚tricos m s simples; se trata de la funci¢n denominada
{#113,fget_angle()} que obtiene directamente el  ngulo entre dos puntos.

{/}Ver: {#1035,Expresi¢n} - Ver: {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.249,draw()}

{draw(}<tipo>{,} <color>{,} <opacidad>{,} <regi¢n>{,} <x0>{,} <y0>{,} <x1>{,} <y1>{,}{)}

{Retorna:}

El {identificador de la primitiva gr fica} pintada.

{Descripci¢n:}

Se trata de una funci¢n gen‚rica capaz de representar varias primitivas
gr ficas en pantalla (como l¡neas, cajas y c¡rculos). Se deben indicar
los siguientes par metros:

{<tipo>} - Tipo de primitiva, dentro de los siguientes:

  {1} - L¡nea recta.ú
  {2} - Rect ngulo.ú
  {3} - Rect ngulo relleno.ú
  {4} - Elipse.ú
  {5} - Elipse rellena.ú

{<color>} - Color de tinta para la primitiva (de {0} a {255}, como un color
de la paleta).

{<opacidad>} - Nivel de opacidad de la primitiva, de {0} a {15} (para permitir
efectos de transparencia).

{<regi¢n>} - N£mero de regi¢n (ventana dentro de la pantalla) en la que
se debe pintar la primitiva; normalmente este valor ser  {0} para poder
imprimir la primitiva en cualquier posici¢n de la pantalla. Para definir
una regi¢n se debe utilizar la funci¢n {#106,define_region()}.

{<x0>}, {<y0>} - Punto inicial de la recta, o la esquina superior izquierda
de la caja que contiene al rect ngulo o elipse.

{<x1>}, {<y1>} - Punto final de la recta, o la esquina inferior derecha
de la caja que contiene al rect ngulo o elipse.

{/}

Cuando se pinta una primitiva con {draw()} esta permanecer  fija en
pantalla hasta que se mueva con {#251,move_draw()}, o se elimine con
{#250,delete_draw()}.

El {identificador de la primitiva} devuelto por la funci¢n {draw()} ser 
necesario para mover o borrar dicha primitiva.

El sistema de representaci¢n de estas primitivas gr ficas es muy similar
al sistema de textos; se pintan con {#171,write()} y permanecen hasta que
se muevan con {#141,move_text()} o se eliminen con {#107,delete_text()}.

{/}

{Nota:} Se puede controlar la prioridad de impresi¢n de las primitivas gr ficas
mediante la variable global predefinida {#1418,draw_z}.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_draw;

GLOBAL
    contador;
    tipo;
    color;
    opacidad;
    x0,y0;
    x1,y1;

BEGIN
    write(0,0,0,0,"Pulse ESC para terminar ...");
    REPEAT
        FROM contador=1 TO 10;
            tipo=rand(1,5);
            color=rand(0,255);
            opacidad=rand(0,15);
            x0=rand(0,319);
            y0=rand(0,199);
            x1=rand(0,319);
            y1=rand(0,199);

            // Pinta una primitiva gr fica

            draw(tipo,color,opacidad,0,x0,y0,x1,y1);

        END
        FRAME;
        delete_draw(all_drawing);
    UNTIL (key(_esc));
END
{-}

Este programa ejemplo representa en pantalla 10 primitivas gr ficas
cuyas caracter¡sticas son seleccionadas al azar mediante la funci¢n
{#149,rand()}, y tras dar una imagen con {#1029,FRAME}, las borra con
la funci¢n {#250,delete_draw()}.

El proceso se repite hasta que se detecta la tecla ESC.

{/}

{Nota:} Pueden representarse en pantalla un m ximo de {256} primitivas
gr ficas simult neamente.

{/}Ver: {#251,move_draw()} - {#250,delete_draw()} - {#1418,draw_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.250,delete_draw()}

{delete_draw(}<identificador de la primitiva gr fica>{)}

{Descripci¢n:}

Borra una primitiva gr fica que se ha pintado con la funci¢n {#249,draw()},
para ello se requiere como par metro el {<identificador de la primitiva>},
que es el c¢digo num‚rico que se retorn¢ al pintarla.

Si se especifica como par metro {all_drawing} se borrar n todas las
primitivas gr ficas representadas en pantalla, es decir, que el {identificador}
ser  necesario s¢lo en el caso de querer eliminar una primitiva concreta.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_delete_draw;

PRIVATE
    id_draw;
    tipo;
    color;
    opacidad;
    x0,y0;
    x1,y1;

BEGIN
    write(0, 160, 8, 1, "[ENTER] Mostrar una primitiva / [ESPACIO] borrarla");
    draw(2,127,15,0,0,0,319,199);
    LOOP
        tipo=rand(1,5);
        color=rand(0,255);
        opacidad=rand(0,15);
        x0=rand(0,319);
        y0=rand(0,199);
        x1=rand(0,319);
        y1=rand(0,199);

        id_draw=draw(tipo,color,opacidad,0,x0,y0,x1,y1);

        WHILE (NOT key(_space))
            FRAME;
        END

        delete_draw(id_draw); // Borramos el texto

        WHILE (NOT key(_enter))
            FRAME;
        END
    END
END
{-}

En el ejemplo anterior, se imprime una primitiva en pantalla, entonces se espera
hasta que se pulse la {barra espaciadora}, momento en el que se borra la primitiva
y se espera a la tecla {ENTER} antes de volver a repetir el bucle.

Se puede observar como s¢lo se borra la segunda primitiva, cuyo identificador
se ha guardado en la variable {id_draw} (la primera es el rect ngulo que
abarca toda la pantalla y se pinta con la primera llamada a {#249,draw()} del
programa).

Para borrar todas las primitivas se deber¡a haber llamado a la funci¢n
como {delete_draw(all_drawing);}, lo que tambi‚n habr¡a eliminado al rect ngulo.

{/}

{Nota:} Con la funci¢n {#251,move_draw()} se pueden modificar las
caracter¡sticas de una primitiva gr fica presente en pantalla (posici¢n,
color, opacidad y tama¤o).

{/}Ver: {#249,draw()} - {#251,move_draw()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.251,move_draw()}

{move_draw(}<identificador de la primitiva>{,} <color>{,} <opacidad>{,} <x0>{,} <y0>{,} <x1>{,} <y1>{)}

{Descripci¢n:}

Modifica una primitiva gr fica que se ha pintado con la funci¢n {#249,draw()},
para ello se requieren los siguientes par metros:

{<identificador de la primitiva>} - Es el c¢digo num‚rico que devolvi¢ la
funci¢n {#249,draw()} cuando se pint¢ la primitiva que ahora se prentende
modificar.

{<color>} - Color de tinta para la primitiva (de {0} a {255}, como un color
de la paleta).

{<opacidad>} - Nivel de opacidad de la primitiva, de {0} a {15} (para permitir
efectos de transparencia).

{<x0>}, {<y0>} - Punto inicial de la recta, o la esquina superior izquierda
de la caja que contiene al rect ngulo o elipse.

{<x1>}, {<y1>} - Punto final de la recta, o la esquina inferior derecha
de la caja que contiene al rect ngulo o elipse.
y las coordenadas ({x}, {y}) de pantalla a las que se debe mover.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_move_draw;

PRIVATE
    id_draw;
    color;
    opacidad;

BEGIN
    write(0, 0, 0, 0, "Mueva el rat¢n ...");
    id_draw=draw(4, 127, 15, 0, 0, 0, 32, 32);
    LOOP
        color=rand(0,255);
        opacidad=rand(0,15);

        // Se mueve la primitiva gr fica a las coordenadas del rat¢n

        move_draw(id_draw, color, opacidad, mouse.x-16, mouse.y-16, mouse.x+16, mouse.y+16);

        FRAME;
    END
END
{-}

En el ejemplo se pinta, con la funci¢n {#249,draw()}, una primitiva gr fica
circular, y se guarda su {identificador de primitiva gr fica} en la variable
global {id_draw}.

Entonces es cuando, dentro de un bucle, se utilizar  la funci¢n {move_draw()}
para situar dicho c¡rculo en las coordenadas del rat¢n, y asignarle un
color y opacidad escogidos al azar en cada imagen.

{/}

{Nota:} Para eliminar (borrar) una primitiva gr fica se utiliza la funci¢n
{#250,delete_draw()}, y con la variable global predefinida {#1418,draw_z} se
puede controlar la prioridad de impresi¢n de las mismas.

{/}Ver: {#249,draw()} - {#250,delete_draw()} - {#1418,draw_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.253,write_in_map()}

{write_in_map(}<fuente>{,} <texto>{,} <c¢digo de centrado>{)}

{Retorna:}

El {c¢digo del gr fico} creado conteniendo al texto.

{Descripci¢n:}

Crea un nuevo mapa en memoria (sin cargarlo de un archivo del disco, al igual
que la funci¢n {#188,new_map()}) y escribe en el mismo un texto cuyas
caracter¡sticas se describen con los siguientes par metros:

{<fuente>} - El {c¢digo de la fuente} o {tipo de letra} que se va a utilizar.
Aqu¡ se debe poner un 0 cuando se quiera utilizar la fuente del sistema
(fuente de color blanco, peque¤a, de 6 por 8 puntos), o bien el {c¢digo de
fuente} devuelto por la funci¢n {#131,load_fnt()} cuando se carga una nueva
fuente en el programa.

{<texto>} - En segundo lugar se especificar  texto a escribir como un
literal, es decir, un texto entre comillas (ver los
{#1047,s¡mbolos delimitadores de literales}).

{<c¢digo de centrado>} - Es un c¢digo que determina la posici¢n del texto
en la que situar  el {centro} o {#1136,punto de control} del mapa creado. Sus
posibles valores son:

  {0}-Arriba izquierda {1}-Arriba {2}-Arriba derechaú
  {3}-Izquierda        {4}-Centro {5}-Derechaú
  {6}-Abajo izquierda  {7}-Abajo  {8}-Abajo derechaú

El texto siempre estar  encajado en un mapa nuevo de sus mismas dimensiones, pero
este {#1136,punto de control} especificar  que punto de dicho mapa se centrar  en
las coordenadas en las que posteriormente se sit£e el mismo.

{/}

Esta funci¢n se comporta practicam‚nte igual que {#174,load_map()}, salvo que
no se lee un archivo en disco con el gr fico, sino que se crea como un gr fico
que contiene un mensaje escrito con una fuente de letras determinada.

Se devuelve como valor de retorno el {c¢digo del gr fico}, que es un valor
num‚rico que debe especificarse para utilizar el gr fico, en la variable
{#1126,graph} o, en general, en todas las funciones que requieran un {c¢digo
de gr fico} entre sus par metros.

Cuando se requiera dentro de una funci¢n el {c¢digo de fichero} al que
pertenece dicho gr fico, se debe indicar el c¢digo {0} (que es el c¢digo
del primer {fichero FPG} que se cargue en el programa).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_write_in_map;

GLOBAL
    mi_fuente;

BEGIN
    mi_fuente=load_fnt("help\help.fnt");

    // Se crea un mapa nuevo con el texto "MOUSE"
    // con el punto de control en el centro, y se
    // asigna como gr fico del puntero del rat¢n.

    mouse.graph = write_in_map(mi_fuente,"MOUSE",4);

    REPEAT
        FRAME;
    UNTIL (key(_esc));
    unload_map(mouse.graph);
END
{-}

En el ejemplo se carga una fuente de letras con la funci¢n {#131,load_fnt()},
y entonces se crea un mapa con la funci¢n {write_in_map()} guardando
el {c¢digo del gr fico} que retorna en la variable {#1100,mouse.graph}, de
forma que aparezca como puntero del rat¢n.

El nuevo mapa se crea con el mensaje {"MOUSE"} escrito con la fuente {help.fnt},
y su {#1136,punto de control} principal se sit£a en el centro (con el c¢digo {4}).

Pulsando la tecla {ESC} se saldr  del bucle de visualizaci¢n del programa y
se descargar  el gr fico con la funci¢n {#176,unload_map()} (exactamente igual
que si se hubiera cargado de un archivo del disco).

No obstante, {no es necesario descargar el gr fico de memoria} antes de
finalizar el programa, ya que el sistema lo har  de forma autom tica.

{/}

La principal ventaja que proporciona la funci¢n {write_in_map()} es
el poder tratar los textos como si se tratara de gr ficos, con lo que se
podr n rotar, escalar, imprimir con transparencia, etc.

{Nota:} Para que {write_in_map()} pueda mostrar un valor num‚rico se
debe utilizar la funci¢n {#255,itoa()}, que permite convertir un valor
num‚rico en una cadena de texto.

{/}Ver: {#171,write()} - {#176,unload_map/pcx()} - {#1126,graph} - {#255,itoa()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.254,calculate()}

{calculate(}<texto con una expresi¢n num‚rica>{)}

{Retorna:}

El resultado de la expresi¢n num‚rica.

{Descripci¢n:}

Permite convertir un literal (o texto entre comillas), que contenga un
n£mero o expresi¢n num‚rica, en un valor constante que puede asignarse
a cualquier dato.

Es decir, que permite convertir un texto en n£mero; por ejemplo, la
sentencia {x=calculate("234");} asignar  el valor {234} a la variable
{x} (exactamente igual que la sentencia {x=234;}). La funci¢n {#255,itoa()}
permite la operaci¢n contraria, es decir, convertir un n£mero en un texto.

Pero adem s, la funci¢n {calculate()} puede evaluar una expresi¢n contenida
en el texto con diversos operadores, que pueden ser los siguientes (se indican
todos los sin¢nimos aceptados de cada operador):

{ + -}      Suma y Resta.ú
{ * /}      Multiplicaci¢n y divisi¢n.ú
{ % MOD}    M¢dulo, o resto de una divisi¢n entera.ú
{ < <<}     Rotaci¢n binaria a la izquierda.ú
{ > >>}     Rotaci¢n a la derecha.ú
{ ^ ^^ XOR} OR exclusivo binario.ú
{ | || OR}  OR binario.ú
{ & && AND} AND binario.ú
{ ! NOT}    Negaci¢n binaria.ú
{ SQRT}     Raiz cuadrada.ú

Tambi‚n se pueden utilizar los par‚ntesis {( )} para indicar prioridades
dentro del c lculo de la expresi¢n. Por ejemplo, {calculate(}"(2+3)*4"{)}
devolver¡a {20} como resultado.

{/}

{Nota:} La operatividad de esta funci¢n es muy similar a la ventana
de la {#1301,calculadora} ({Sistema\Calculadora}) del entorno de ventanas.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_calculate;

GLOBAL
    STRING c lculo;
    resultado;

BEGIN
    write(0,0,0,0,"Introduzca una expresi¢n:");
    write(0,0,10,0,c lculo);
    write(0,0,30,0,"Resultado:");
    write_int(0,0,40,0,OFFSET resultado);
    LOOP
        SWITCH(ascii)
            CASE 8:
                c lculo--;
            END
            CASE 27:
                c lculo="";
            END
            CASE 0..31:
            END
            DEFAULT:
                c lculo+=ascii;
            END
        END

        resultado = calculate(c lculo); // Eval£a el c lculo

        IF (timer MOD 100>50)
            c lculo+="_";
        ELSE
            c lculo+=" ";
        END
        FRAME;
        c lculo--;
    END
END
{-}

Este programa ejemplo permite al usuario introducir una expresi¢n en
una cadena de texto (ver {#1406,STRING}) y la eval£a con la funci¢n
{calculate()} para mostrar el resultado de la misma.

{/}

{Nota:} Si se produce un error en la evaluaci¢n de la expresi¢n (por ejemplo,
que exista alg£n par‚ntesis sin cerrar), la funci¢n devolver  {0} como
resultado.

{/}Ver: {#255,itoa()} - {#171,write()} - {#1406,STRING}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.255,itoa()}

{itoa(}<expresi¢n>{)}

{Retorna:}

Una cadena de texto conteniendo el resutado.

{Descripci¢n:}

Esta funci¢n se utiliza para convertir un valor num‚rico o {<expresi¢n>} en
una cadena de texto, es decir, que permite convertir un n£mero en un texto.
La cadena contendr  tantos car cteres como d¡gitos tenga el resultado.

La funci¢n {#254,calculate()} permite la operaci¢n contraria;
convertir un literal o cadena de texto en un valor num‚rico.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_itoa;

GLOBAL
    STRING mensaje;

BEGIN
    load_fpg("help\help.fpg");
    mouse.graph=200;
    write(0,0,0,0,mensaje);
    REPEAT

        // Compone un mensaje con texto y n£meros utilizando itoa()

        mensaje = "Cursor del rat¢n en (" + itoa(mouse.x) +
                  "," + itoa(mouse.y) + ").";

        FRAME;
    UNTIL (key(_esc));
END
{-}

Este programa ejemplo compone en una cadena de texto denominada {mensaje}
(ver {#1406,STRING}) letras y valores num‚ricos (las coordenadas
del rat¢n, ver {#1100,mouse}), y lo representa en pantalla con la
funci¢n {#171,write()}.

El programa carga el archivo {help.fpg} con {#132,load_fpg()} y asigna
el gr fico {200} como cursor del rat¢n. El programa continuar  hasta que
se detecte la pulsaci¢n de la tecla {ESC}.

{/}

{Nota:} El nombre de la funci¢n {itoa()}, hom¢nima del lenguaje C, viene
de la expresi¢n "integer to ascii", del ingl‚s. Y la funci¢n que realiza
la operaci¢n contraria, "ascii to integer" es {#254,calculate()}.

{/}Ver: {#254,calculate()} - {#1035,Expresiones aritm‚ticas} - {#171,write()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.256,change_channel()}

{change_channel(}<canal>{,} <volumen>{,} <balance>{)}

{Descripci¢n:}

Se trata de una funci¢n complementaria a {#102,change_sound()}, que modifica
las propiedades de uno de los canales de sonido que reproducen los efectos
digitales (ver {#159,sound()}) o m¢dulos musicales (ver {#216,song()}).

Se debe indicar el n£mero de {<canal>} que quiere ajustarse, (normalmente
el n£mero de canal devuelto por la funci¢n {#159,sound()}), y los siguientes
dos valores:

{<volumen>} - Se trata del volumen propio del canal, entre {0} y {512},
independiente del volumen del propio sonido y del volumen general.

Cuando los volumenes de los diferentes canales son demasiado altos se
producen efectos de distorsi¢n, por ello se recomienda modificar el volumen
de los efectos de sonido mediante la funci¢n {#102,change_sound()} que,
adem s, permite ajustar la frecuencia de los mismos.

{<balance>} - Es el "panning" o diferencia de volumen entre el atavoz izquierdo
y derecho, debe ser un valor entre {0} y {255}.

{/}

{Nota:} Los niveles generales de volumen se pueden ajustar mediante la
estructura global {#1104,setup} (sonido digital, cd-audio y volumen
general).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_change_channel;

PRIVATE
    balance=128;     // Valor medio (0..256)

    id_sonido;
    canal;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    id_sonido = load_pcm("help\help.pcm", 1);
    canal = sound(id_sonido, 256, 256);

    write(0, 160, 0, 1, "Presione derecha o izquierda para cambiar el balance.");
    write_int(0, 160, 10, 1, offset balance);
    LOOP

        // Cambia el balance del canal

        change_channel(canal, 50, balance);

        IF (key(_right) AND balance<255) balance++; END
        IF (key(_left) AND balance>0) balance--; END
        FRAME;
    END

END
{-}

En el ejemplo se carga y se emite un sonido (contenido en el archivo
{help.pcm}). Dentro del bucle principal del programa se puede cambiar
el balance del canal por el que est  sonando dicho sonido con la funci¢n
{change_channel()}, utilizando las teclas de los cursores.

{/}

{Nota:} Ver tambi‚n la tabla global predefinida {#1416,channel}, que indica
cuales de los canales de sonido est n siendo utilizados.

{/}Ver: {#102,change_sound()} - {#159,sound()} - {#216,song()} {#1104,STRUCT setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.257,malloc()}

{malloc(}<longitud>{)}

{Retorna:}

El {OFFSET} del bloque de memoria solicitado, o {0} si la memoria disponible
no es sufuciente.

{Descripci¢n:}

Esta funci¢n asigna memoria din mica, es decir, se solicita un nuevo bloque de
memoria libre del ordenador para el programa.

Se requiere como par metro la {<longitud>} del bloque de memoria que desea
ocuparse. Esta longitud se especifica como un n£mero de datos simples, ocupando
cada uno de ellos 4 bytes; por ejemplo, si se solicita un bloque de longitud
{100} se reservar n 400 bytes de memoria.

Dentro de un programa pueden solicitarse un m ximo de {256 bloques},
independientemente de su tama¤o. La funci¢n {#258,free()} permite liberar
estos bloques de memoria.

{/}

Normalmente el {OFFSET} (direcci¢n de memoria) retornado por la funci¢n
{malloc()} se asigna a un dato de tipo puntero (ver {#1405,POINTER}).

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_malloc;

GLOBAL
    POINTER mitabla[1000];  // Puntero a una tabla de 1000 datos

BEGIN

    mitabla = malloc(1000); // Solicita 1000 posiciones de memoria

    FOR (contador=0;contador<1000;contador++) // Accede a los datos
        mitabla[contador]=-1;
    END

    free(mitabla);          // Libera la memoria ocupada por la tabla
END
{-}

Este peque¤o ejemplo muestra como se puede definir un puntero a una tabla
(con el puntero no se reserva espacio para los datos de la tabla), y como
solicitar memoria para esta con la funci¢n {malloc()}.

Una vez solicitada la memoria para la tabla de datos se accede a los mismos
(se inicializan a -1, como un ejemplo), y se libera la memoria.

Los bloques de memoria que no se liberen con la funci¢n {#258,free()}, ser n
liberados autom ticamente por el sistema al finalizar el programa.

{/}

{Nota:} La cantidad de memoria disponible para los datos de los procesos del
programa (datos locales y privados) se puede controlar mediante las opciones
de compilaci¢n (ver {#1400,Compiler_options}).

{/}Ver: {#258,free()} - {#1405,POINTER}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.258,free()}

{free(}<OFFSET del bloque de memoria>{)}

{Descripci¢n:}

Libera un bloque de memoria din mica que ha sido reservado anteriormente con
la funci¢n {#257,malloc()}

Se requiere como par metro el {OFFSET} o direcci¢n de memoria en la que comienza
el bloque, que es el valor que se obtiene al reservarlo.

Los bloques de memoria que no se liberen con la funci¢n {free()}, ser n
liberados autom ticamente por el sistema al finalizar el programa.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_free;

GLOBAL
    POINTER mitabla[1000];  // Puntero a una tabla de 1000 datos

BEGIN

    mitabla = malloc(1000); // Solicita 1000 posiciones de memoria

    FOR (contador=0;contador<1000;contador++) // Accede a los datos
        mitabla[contador]=-1;
    END

    free(mitabla);          // Libera la memoria ocupada por la tabla
END
{-}

Este peque¤o ejemplo muestra como se puede definir un puntero a una tabla
(con el puntero no se reserva espacio para los datos de la tabla), y como
solicitar memoria para esta con la funci¢n {#257,malloc()}.

Una vez solicitada la memoria para la tabla de datos se accede a los mismos
(se inicializan a -1, como un ejemplo), y se libera la memoria.

{/}Ver: {#248,free()} - {#1405,POINTER}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.259,encode()}

{encode(}<OFFSET de los datos>{,} <longitud>{,} <clave>{)}

{Descripci¢n:}

Encripta o desencripta un bloque de datos en memoria con una clave
determinada. Los par metros necesarios son los siguientes:

{<OFFSET de los datos>} - Direcci¢n de memoria en la que comienza el bloque
que debe comprimirse, para obtener la esta direcci¢n se debe utilizar el
operador {#1085,OFFSET}.

{<longitud>} - Longitud de los datos a comprimir, es decir, el n£mero de
posiciones de memoria ocupadas por los mismos, la longitud de cualquier
dato se puede obtener con {#1094,SIZEOF()}.

{<clave>} - Un literal (texto entre comillas) con la clave de encriptaci¢n
o desencriptaci¢n de los datos.

El algoritmo es reversible por lo que, para desencriptar los datos,
simplemente se tienen que volver a encriptar con la misma clave.

El algoritmo de encriptaci¢n es muy complejo, por lo que cualquier dato
encriptado con una clave £nicamente se podr  recuperar aplic ndole la misma
clave de nuevo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_encode;

CONST
    clave="miclave";

GLOBAL
    tabla_original[14]  =0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;
    tabla_encriptada[14]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;
    contador;

BEGIN
    write(0,0,  0,0,"Valores originales");
    write(0,160,0,0,"Valores encriptados");
    write(0,0,190,0,"[ESPACIO] para encriptar/desencriptar los valores");

    // Encripta los valores de la segunda tabla

    encode(OFFSET tabla_encriptada,sizeof(tabla_encriptada),clave);

    FOR (contador=0;contador<15;contador++)
        write_int(0,0,  20+contador*8,0,OFFSET tabla_original[contador]);
        write_int(0,160,20+contador*8,0,OFFSET tabla_encriptada[contador]);
    END

    LOOP
        IF (scan_code==_space)

            // Encripta y desencripta los valores de la segunda tabla

            encode(OFFSET tabla_encriptada,sizeof(tabla_encriptada),clave);

        END
        FRAME;
    END
END
{-}

Este programa tiene definidas dos tablas de datos globales, ambas con los
mismos valores y permite, pulsando la {barra espaciadora}, encriptar y
desencriptar una de las dos tablas (la denominada {tabla_encriptada[]}).

Se puede observar como, al encriptar por segunda vez los datos, se recuperan
en su estado original. Si se utiliza una clave distinta, el resultado ser 
totalmente diferente.

{/}

{Nota:} Existen otras dos funciones que permiten encriptar y desencriptar
archivos de cualquier tipo, en este caso se debe utilizar una funci¢n para
cada operaci¢n: {#260,encode_file()} para encriptar y {#261,decode_file()}
para desencriptar.

{/}Ver: {#260,encode_file()} - {#261,decode_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.260,encode_file()}

{encode_file(}<nombre de archivo>{,} <clave>{)}

{Descripci¢n:}

Encripta uno o varios archivos del disco con una clave determinada.
Los par metros necesarios son los siguientes:

{<nombre de archivo>} - Descripci¢n del archivo que debe encriptarse,
un literal (texto entre comillas) con el nombre del mismo. Pueden utilizarse
los car cteres comod¡n "?" y "*" para especificar varios archivos (por ejemplo,
"*.BAK" para encriptar todos los archivos con extensi¢n BAK).

{<clave>} - Otro literal con la clave de encriptaci¢n del archivo o archivos.

El algoritmo de encriptaci¢n es muy complejo, por lo que cualquier archivo
encriptado con una clave £nicamente se podr  recuperar aplic ndole la misma
mediante la funci¢n {#261,decode_file()}. De no realizarse dicha operaci¢n,
el archivo resultante ser  totalmente in£til, siendo imposible recuperar
los datos contenidos en ‚l.

No podr n encriptarse por segunda vez los archivos que ya est n encriptados.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_encode_file;

CONST
    clave="miclave";

GLOBAL
    mitabla[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;

BEGIN
    save("help\help.enc",OFFSET mitabla,sizeof(mitabla));

    encode_file("help\help.enc",clave); // Encripta el archivo
END
{-}

Este peque¤o programa utiliza la funci¢n {#155,save()} para crear un archivo
llamado {help.enc} con los datos contenidos en {mitabla}, y entonces lo
encripta con la funci¢n {encode_file()}.

Puede observarse como el contenido del archivo creado (dentro del directorio
{help\}) no guarda ninguna relaci¢n con los datos originales (sea cual sea
la clave de encriptaci¢n).

{/}

Existe otra funci¢n denominada {#259,encode()} que permite encriptar
y desencriptar datos en memoria, en este caso la operaci¢n es reversible, por
lo que se utiliza la misma funci¢n para ambas operaciones.

{/}

{Nota:} Las funciones {#262,compress_file()} y {#263,uncompress_file()}
permiten comprimir y descomprimir archivos del disco. Los archivos encriptados
{no podr n comprimirse} con dichas funciones (debido a que su contenido es
completamente aleatorio).

{/}Ver: {#259,encode()} - {#261,decode_file()} - {#262,compress_file()} - {#263,uncompress_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.261,decode_file()}

{decode_file(}<nombre de archivo>{,} <clave>{)}

{Descripci¢n:}

Desencripta uno o varios archivos del disco, con la misma clave con la que
fueron encriptados con la funci¢n {#260,encode_file()}. Los par metros
necesarios son los siguientes:

{<nombre de archivo>} - Descripci¢n del archivo que debe desencriptarse,
un literal (texto entre comillas) con el nombre del mismo. Pueden utilizarse
los car cteres comod¡n "?" y "*" para especificar varios archivos (por ejemplo,
"*.BAK" para desencriptar todos los archivos con extensi¢n BAK).

{<clave>} - Otro literal con la clave de desencriptaci¢n del archivo o archivos.
Esta clave debe ser {exacta} a la clave con la que fueron encriptados
originalmente los archivos, si {se desencriptan con una clave diferente los
archivos quedar n inservibles}.

No podr n desencriptarse los archivos que no est n encriptados.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_decode_file;

CONST
    clave="miclave";

GLOBAL
    mitabla[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;

BEGIN
    save("help\help.enc",OFFSET mitabla,sizeof(mitabla));
    encode_file("help\help.enc",clave);
    // ...

    decode_file("help\help.enc",clave); // Desencripta el archivo

END
{-}

Este peque¤o programa utiliza la funci¢n {#155,save()} para crear un archivo
llamado {help.enc} con los datos contenidos en {mitabla}, y lo encripta con
la funci¢n {encode_file()}.

Antes de finalizar el programa, se vuelve a recuperar el contenido del archivo
al desencriptarlo con la funci¢n {decode_file()}. El archivo quedar  finalmente
con los datos contenidos en {mitabla}, en su forma original.

{/}

Existe otra funci¢n denominada {#259,encode()} que permite encriptar
y desencriptar datos en memoria, en este caso la operaci¢n es reversible, por
lo que se utiliza la misma funci¢n para ambas operaciones.

{/}

{Nota:} Las funciones {#262,compress_file()} y {#263,uncompress_file()}
permiten comprimir y descomprimir archivos del disco. Los archivos encriptados
{no podr n comprimirse} con dichas funciones (debido a que su contenido es
completamente aleatorio).

{/}Ver: {#260,encode_file()} - {#259,encode()} - {#262,compress_file()} - {#263,uncompress_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.262,compress_file()}

{compress_file(}<nombre de archivo>{)}

{Descripci¢n:}

Comprime uno o varios archivos del disco, como £nico par metro se requiere
el {<nombre de archivo>} que debe comprimirse, como un literal (texto entre
comillas). Pueden utilizarse los car cteres comod¡n "?" y "*" para especificar
varios archivos (por ejemplo, "*.BAK" para comprimir todos los archivos con
extensi¢n BAK).

Para descomprimir estos archivos se debe utilizar la funci¢n {#263,uncompress_file()}.
El formato de archivo encriptado es un formato propio de DIV Games Studio,
por lo que no se podr n descomprimir con ninguna utilidad externa.

El archivo se guarda comprimido con el mismo nombre y extensi¢n que ten¡a
el original. No se podr n comprimir por segunda vez los archivos que ya est n
comprimidos.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_compress_file;

GLOBAL
    contador;
    mitabla[999];

BEGIN
    FOR (contador=0;contador<1000;contador++)
        mitabla[contador]=contador;
    END

    save("help\help.cmp",OFFSET mitabla,sizeof(mitabla));

    compress_file("help\help.cmp"); // Comprime el archivo
END
{-}

Este peque¤o programa utiliza la funci¢n {#155,save()} para crear un archivo
llamado {help.cmp} con los datos contenidos en {mitabla}, siendo estos una
serie de n£meros consecutivos del 0 al 1000.

Una vez creado el archivo, se comprime con la funci¢n {compress_file()}.

En este caso, el tama¤o original del archivo es de 4000 bytes (1000 datos),
y el tama¤o del archivo comprimido es de 1441 bytes (un 36% del tama¤o
original).

{/}

{Nota:} Las funciones {#260,encode_file()} y {#261,decode_file()}
permiten encriptar y desencriptar archivos del disco.

Los archivos encriptados generados con estas funciones {no podr n comprimirse}
debido a que su contenido es completamente aleatorio. No obstante, {los archivos
comprimidos si que pueden encriptarse}.

{/}Ver: {#263,uncompress_file()} - {#260,encode_file()} - {#261,decode_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.263,uncompress_file()}

{uncompress_file(}<nombre de archivo>{)}

{Descripci¢n:}

Descomprime uno o varios archivos del disco que hubieran sido anteriormente
comprimidos con la funci¢n {#262,compress_file()}, como £nico par metro se
requiere el {<nombre de archivo>} que debe descomprimirse, como un literal
(texto entre comillas). Pueden utilizarse los car cteres comod¡n "?" y "*"
para especificar varios archivos (por ejemplo, "*.BAK" para descomprimir todos
los archivos con extensi¢n BAK).

El formato de archivo encriptado es un formato propio de DIV Games Studio,
por lo que no se podr n descomprimir con ninguna utilidad externa.

El archivo se descomprime con el mismo nombre y extensi¢n que ten¡a
comprimido. No se podr n descomprimir archivos que no est n comprimidos
con la funci¢n {#262,compress_file()} del lenguaje.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_uncompress_file;

GLOBAL
    contador;
    mitabla[999];

BEGIN
    FOR (contador=0;contador<1000;contador++)
        mitabla[contador]=contador;
    END

    save("help\help.cmp",OFFSET mitabla,sizeof(mitabla));

    compress_file("help\help.cmp"); // Comprime el archivo

    // ...

    uncompress_file("help\help.cmp"); // Descomprime el archivo

    load("help\help.cmp",OFFSET mitabla);
END
{-}

Este peque¤o programa utiliza la funci¢n {#155,save()} para crear un archivo
llamado {help.cmp} con los datos contenidos en {mitabla}, siendo estos una
serie de n£meros consecutivos del 0 al 1000, entonces se comprime el archivo
con la funci¢n {#262,compress_file()}.

Una vez creado el archivo comprido en disco, se descomprime con la funci¢n
{uncompress_file()} y se vuelve a cargar sobre la tabla original con la
funci¢n {#130,load()}.

{/}

{Nota:} Las funciones {#260,encode_file()} y {#261,decode_file()}
permiten encriptar y desencriptar archivos del disco.

Los archivos encriptados generados con estas funciones {no podr n comprimirse}
debido a que su contenido es completamente aleatorio. No obstante, {los archivos
comprimidos si que pueden encriptarse}.

{/}Ver: {#262,compress_file()} - {#260,encode_file()} - {#261,decode_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.264,find_color()}

{find_color(}<red>{,} <green>{,} <blue>{)}

{Retorna:}

El {n£mero de color} dentro de la paleta.

{Descripci¢n:}

Busca el color de la paleta actual m s cercano al color indicado.

Se requieren las tres componentes que con componen el color que se desea
localizar dentro de la paleta, como {<red>} (rojo), {<green>} (verde) y
{<blue>} (azul), todas ellas como valores entre 0 y 63.

Como valor de retorno se devolver  el {n£mero de color} de la paleta que
m s se acerca a las componentes indicadas.

Por ejemplo, si se llama a la funci¢n como {find_color(63,63,0)}, devolver 
el n£mero del color de la paleta que m s se acerca o parece al {amarillo}.

{/}

{Nota:} La funci¢n {find_color()} {no modifica la paleta actual}, £nicamente
busca colores determinados dentro de la misma, para modificar un color de la
paleta se debe emplear la funci¢n {#179,set_color()}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_find_color;

GLOBAL;
    azul;
    verde;
    amarillo;
    rojo;

BEGIN

    azul=find_color(0,0,63);      // Busca el color azul
    verde=find_color(0,63,0);     // Busca el color verde
    amarillo=find_color(63,63,0); // Busca el color amarillo
    rojo=find_color(63,0,0);      // Busca el color rojo

    draw(2,azul,15,0,0,0,79,79);
    draw(2,verde,15,0,80,0,159,79);
    draw(2,amarillo,15,0,160,0,239,79);
    draw(2,rojo,15,0,240,0,319,79);

    LOOP
        FRAME;
    END
END
{-}

Este ejemplo utiliza la funci¢n {find_color()} para localizar los colores
{azul}, {verde}, {amarillo} y {rojo} dentro de la paleta (sea cual sea esta),
y entonces, mediante la funci¢n {#249,draw()}, muestra cuatro cuadrados
de estos colores.

La ventaja de utilizar este sistema es que no importa que el programa cambie
de paleta, ya que siempre se podr n localizar los colores dentro de la misma.

{/}

Para modificar toda la paleta, se suele cargar la misma de un archivo del
disco mediante al funci¢n {#133,load_pal()}.

Para realizar otros efectos de paleta, se puede utilizar la funci¢n {#154,roll_palette()}
que permite realizar ciclos de color, o la funci¢n {#110,fade()} que permite
realizar m£ltiples fundidos y saturaciones de color a diferentes velocidades.

{/}Ver: {#179,set_color()} - {#154,roll_palette()} - {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.265,load_screen()}

{load_screen(}<nombre de archivo>{)}

{Descripci¢n:}

Carga la imagen de fondo de la pantalla de un archivo {MAP} o {PCX}.

Si el gr fico es de un tama¤o (en puntos) diferente al de la pantalla
simplemente se imprimir  centrado en la misma.

Para borrar el fondo de la pantalla se debe utilizar la funci¢n
{#103,clear_screen()}.

{/}

En realidad, se trata de una funci¢n que resume tres acciones en una:

{1 -} Cargar un archivo que contiene un mapa con la imagen de fondo (con la
funci¢n {#174,load_map()} o {#174,load_pcx()}).

{2 -} Establecer dicha imagen como fondo de pantalla (con {#148,put_screen()}).

{3 -} Descargar el archivo con la imagen de memoria (con {#176,unload_map()} o
{#176,unload_pcx()})

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_load_screen;
BEGIN
    load_screen("help\help.map");
    LOOP
        FRAME;
    END
END
{-}

En el ejemplo se carga la imagen de fondo contenida en el archivo {help.map}
con la funci¢n {load_screen()}.

{/}

{Nota:} Si se quiere imprimir un gr fico en una parte concreta de la pantalla
o un gr fico {que no aparezca centrado}, se puede utilizar para ello la funci¢n
{#146,put()}. La funci¢n {#173,xput()} permite, adem s, imprimir gr ficos
rotados, escalados, espejados y/o transparentes en cualquier regi¢n de
pantalla.

{/}Ver: {#174,load_map/pcx()} - {#148,put_screen()} - {#176,unload_map/pcx()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.266,force_pal()}

{force_pal(}<nombre de archivo>{)}

{Descripci¢n:}

Carga una paleta de color de disco (de un archivo PAL, FPG, MAP, PCX o FNT) y
{la establece como paleta obligatoria} para todos los gr ficos y fuentes que
sean cargados en adelante.

Es decir, el funcionamiento es muy similar a {#133,load_pal()} (que simplemente
carga y activa una paleta) pero, una vez cargada la paleta con {force_pal()},
{todos los mapas, ficheros y fuentes} cargados {se adaptar n autom ticamente a
la paleta activa}.

Los {gr ficos que ya estuvieran cargados} antes de llamar a {force_pal()} {no
ser n adaptados}, por ello, si se quiere que todos los gr ficos se puedan
visualizar con una paleta £nica, se debe llamar a esta funci¢n
al inicio del programa.

Es {importante} resaltar que los mapas, ficheros y fuentes £nicamente se
adaptar n en la memoria del ordenador, los archivos originales permanecer n
inalterados, cada uno con su paleta.

{/}

{Nota:} Para que no se continuen adaptando los gr ficos cargados a la paleta,
se debe llamar a la funci¢n como {force_pal(0)} (indicando un {0} como
par metro, en lugar de un nombre de archivo.

{/}

{#9999,Programa ejemplo:}
PROGRAM ejemplo_force_pal;
BEGIN

    force_pal("help\help.pal");

    // Ahora se pueden cargar todos los ficheros, mapas y fuentes
    // que se quiera, sea cual sea su paleta, todos se adaptar n
    // autom ticamente a la paleta activa

    // ...

END
{-}

Este peque¤o ejemplo muestra como se pueden forzar todos los gr ficos a una
sola paleta dentro de un programa, llamando a {force_pal()} al inicio del
mismo.

{/}

Una paleta no se puede descargar de la memoria del ordenador, ya que ‚sta
no ocupa espacio en la memoria.

{/}Ver: {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Informaci¢n extendida sobre los mensajes de error del compilador
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.500,Memoria insuficiente}

No se dispone de {memoria suficiente} para compilar el programa.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.501,No se encontro ltobj.def}

El archivo <LTLEX.DEF> no se ha encontrado en el directorio de DIV; este
archivo resulta imprescindible para la compilaci¢n de los programas.

Recupere el archivo original si dispone de una copia, en caso contrario
deber  volver a instalar la aplicaci¢n.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.502,Archivo ltlex.def err¢neo}

Los cambios efectuados en el archivo <LTLEX.DEF> {no son v lidos}; recupere
el archivo original si dispone de una copia, en caso contrario deber  volver
a instalar la aplicaci¢n.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.503,Archivo ltlex.def err¢neo}

Se han definido {demasiados s¡mbolos} en el archivo <LTLEX.DEF>; recupere
el archivo original si dispone de una copia, en caso contrario deber  volver
a instalar la aplicaci¢n.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.504,Archivo ltlex.def err¢neo}

Se ha definido un {s¡mbolo no v lido} en el archivo <LTLEX.DEF>; recupere
el archivo original si dispone de una copia, si no deber  volver
a instalar la aplicaci¢n.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.506,No se encontro ltobj.def}

El archivo <LTOBJ.DEF> no se ha encontrado en el directorio de DIV; este
archivo resulta imprescindible para la compilaci¢n de los programas.

Recupere el archivo original si dispone de una copia, en caso contrario
deber  volver a instalar la aplicaci¢n.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.507,Archivo ltobj.def err¢neo}

Los cambios efectuados en el archivo <LTOBJ.DEF> {no s¢n v lidos}; por ello, tendr  que recuperar
el archivo original si dispone de una copia, en caso contrario deber  volver
a instalar la aplicaci¢n.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.510,Car cter no reconocido}

Se encontr¢ en el programa un car cter que no forma parte de ning£n s¡mbolo
del lenguaje y que, adem s, {no es v lido} para construir un nuevo nombre.

Si se trata de un {#1002,comentario} debe indicarlo correctamente con un s¡mbolo
// al comienzo de los comentarios de una l¡nea, o los s¡mbolos /* y */ para
indicar el inicio y fin, respectivamente, de comentarios que ocupen m s de una
l¡nea.

En caso de que se pretenda construir un {#1001,nombre} debe sustituir dicho
car cter por otro dentro de los que se permiten en el lenguaje.

{/}Ver: {#1000,Sintaxis} - {#1002,Comentarios}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.511,Literal sin cerrar}

Los literales son los {textos entre comillas}. En la posici¢n indicada del
programa comienza un literal y no se cierra.

Todos los literales deben cerrarse en la misma l¡nea en la que comenzaron, no
pudi‚ndose definir literales de m s de una l¡nea.

Los literales pueden comenzar y terminar con el car cter [{#1047,'}] o bien con el
car cter [{#1047,"}] (pero deben comenzar y terminar con el mismo). Si se quiere
incluir el car cter [{#1047,"}] en un literal se puede hacer de dos formas;
sup¢ngase que se quiere definir un literal que contenga el texto: a"B"c

 - Duplicar el car cter: "a""B""c"

 - Definirlo con la comilla simple: 'a"B"c'

Lo mismo sucede con el car cter [{#1047,'}], que se puede incluir en un literal
si se duplica, o bien si el literal se delimita con el car cter [{#1047,"}].

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.512,S¡mbolo no reconocido}

En la posici¢n indicada del programa se encuentra un s¡mbolo no perteneciente
al lenguaje; revise los s¡mbolos que hay disponibles en el lenguaje para
construir correctamente la expresi¢n.

Probablemente se trate de un error tipogr fico; revise la sintaxis.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.520,Esperando [PROGRAM]}

Todos los programas deben comenzar con la palabra reservada {PROGRAM} seguida
del nombre del programa; antes de dicha palabra s¢lo pueden aparecer
{#1002,comentarios} o las {#1400,opciones de compilaci¢n}.

Compruebe si ha escrito la palabra correctamente, ya que no se diferencia entre may£sculas
y min£sculas, por lo que son v lidas {PROGRAM}, {program}, {Program}, ...

{#9999,Ejemplo:}
// -------------------
// Listado de mi juego
// -------------------

PROGRAM mi_juego;
BEGIN
    LOOP
        FRAME;
    END
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1002,Comentarios} - {#1003,Cabecera de programa}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.521,Esperando el nombre del programa}

Tras la palabra reservada {PROGRAM} se espera que venga el nombre del programa.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
BEGIN
    //...
END
{-}

El nombre de este programa es {nombre_del_programa}.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1003,Cabecera de programa}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.522,El nombre no es nuevo}

Como nombre de la estructura se ha utilizado uno que ya estaba
relacionado con otro objeto anteriormente definido. Puede tratarse de un nombre,
de una constante, una variable, una tabla, una estructura, un proceso o una funci¢n del programa.

Tambi‚n puede que se haya pretendido utilizar el mismo nombre dentro del
programa para identificar dos objetos diferentes, o bien {que se
haya utilizado un nombre predefinido para otro uso dentro del lenguaje}.
En dicho caso, se puede acceder al glosario para ver a qu‚ objeto se refiere
dicho nombre.

De todas formas, {debe sustituir dicho nombre por otro similar}.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
GLOBAL
    posicion=0;
    STRUCT posicion[9] // Error: El nombre no es nuevo.
        x, y;
    END
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.523,Esperando [=]}

Para definir una tabla se suele indicar entre corchetes la longitud de la
misma; en caso de no especificar entre los corchetes el n£mero de elementos
de la tabla se espera que a continuaci¢n se inicialice para que el compilador
pueda determinar su longitud.

Se ha encontrado una tabla sin longitud definida, por lo que el compilador
esperaba que, tras cerrarse los corchetes ({#1079,[]}), viniera el s¡mbolo
{#1073,=} precediendo a la inicializaci¢n de la tabla.

Indique la longitud de la tabla entre los corchetes, o as¡gnele valores
a las diferentes posiciones de la tabla.

Cuando una tabla no se inicializa todas sus posiciones ser n incializadas
a cero.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
GLOBAL
    tabla1[3];
    tabla2[]=2, 4, 6, 8;
    tabla3[]; // Error: Esperando [=].
BEGIN
    //...
END
{-}

En el ejemplo se han definido dos tablas de cuatro posiciones (0..3), tabla1
inicializada a (0, 0, 0, 0) y tabla2 inicializada a (2, 4, 6, 8).

{/}Ver: {#1000,Sintaxis} - {#1011,Declaracion de tabla}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.525,Esperando [)]}

El compilador esperaba que en la posici¢n indicada se cerrara un par‚ntesis
anteriormente abierto con el s¡mbolo {#1053,)}.

Este error se suele producir por uno de estos dos motivos:

- En una expresi¢n se han abierto varios par‚ntesis y despu‚s no se han cerrado todos;
en este caso debe cerrar los que falten.

- Dentro de una expresi¢n entre par‚ntesis se ha omitido alg£n operador apareciendo,
entonces, dos operandos seguidos, por ejemplo {(2*3 4)}, debiendo, en este caso, indicar el
operador que falte.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.526,Esperando []]}

El compilador esperaba que en la posici¢n indicada se cerrara un corchete
anteriormente abierto, con el s¡mbolo {#1079,]}.

Este error se suele producir por uno de estos dos motivos:

- En una tabla o estructura se ha indicado la apertura de corchete ({[})
y despu‚s de indicar la longitud o ¡ndice de la misma no se ha cerrado;
en este caso se debe a¤adir en la posici¢n indicada el s¡mbolo {]}.

- Al se¤alar el ¡ndice de una tabla o estructura se ha omitido alg£n operador apareciendo,
entonces, dos operandos seguidos, por ejemplo {tabla[2*3 4]}, debiendo indicar, ahora, el
operador que falte.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.527,Se esperaba un operando}

La posici¢n indicada en el programa est  dentro del contexto de una expresi¢n,
y en ese punto de la expresi¢n se esperaba un operando (un valor sobre el que
se puedan realizar c lculos) pero, en su lugar, ha venido otro elemento diferente
sobre el que no se pueden realizar c lculos.

Hay varias causas que pueden provocar este error; las m s comunes son:

- Se ha utilizado una palabra reservada del lenguaje como si fuera una variable,
por ejemplo {x=global*2;}. En este caso se puede comprobar si se trata de una
palabra reservada accediendo al glosario.

- Se ha omitido un operando dentro de una expresi¢n, por ejemplo {x=2+ /y;}.

- Se ha cerrado dentro de una expresi¢n un corchete o par‚ntesis que no
habia sido abierto anteriormente, por ejemplo {x=);}.

En cualquier caso debe revisar la {#1000,sintaxis} de la expresi¢n indicada
para construirla de forma correcta.

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.528,Nombre desconocido}

En la posici¢n indicada del programa se utiliza una constante, una variable,
una tabla o una estructura con el fin de acceder a ella antes de haberla declarado.

El compilador no puede resolver el problema dado que no conoce de qu‚ tipo
de objeto se trata.

Todas las constantes se deben definir al comienzo del programa, dentro de
la secci¢n {#1004,CONST}.

Las variables, tablas y estructuras se pueden definir dentro de las secciones
{#1006,GLOBAL}, {#1007,LOCAL} o {#1008,PRIVATE} seg£n su alcance, pero
siempre tienen que estar definidas antes de ser usadas.

Los casos m s frecuentes en los que se da este error son:

- Se ha tecleado incorrectamente un nombre, por ejemplo;

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    centro=160;
BEGIN
    x=cenrto; // Error: Nombre desconocido.
    //...
END
{-}

- Un objeto se usa antes y se declara despu‚s, por ejemplo:

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    doble=simple*2; // Error: Nombre desconocido.
    simple=1;
BEGIN
    //...
END
{-}

  En este caso se deber¡an intercambiar las dos declaraciones anteriores.

- Al inicializar una tabla o estructura, se ha colocado una coma accidentalmente
tras la lista de valores.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla[]=0, 1, 2, 3,
    a=0; // Error: Nombre desconocido.
BEGIN
    //...
END
{-}

  En este caso el compilador avisar  de este error en la variable {a}, ya
que interpreta que es el siguiente valor en la lista de inicializaci¢n de
tabla, y es un nombre que todav¡a se ha definido.

{/}Ver: {#1000,Sintaxis} - {#1004,Declaraci¢n de constantes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.529,Esperando [BEGIN]}

Este error se produce cuando se realiza una declaraci¢n incorrecta dentro
de las secciones {#1004,CONST}, {#1006,GLOBAL}, {#1007,LOCAL} o
{#1008,PRIVATE}.

Tras la sentencia inicial {#1003,PROGRAM nombre_de_programa;} se espera que
aparezca alguna de las secciones anteriormente citadas (siempre en ese mismo orden)
y al final la palabra {#1086,BEGIN}.

Tras el inicio de un proceso ({#1016,PROCESS} {nombre_de_proceso(}...{)}) o
funci¢n ({#1408,FUNCTION} {nombre_de_funci¢n(}...{)})
que se muestre la secci¢n {#1008,PRIVATE} o la palabra {#1086,BEGIN}.

El error puede producirse bajo las siguientes circunstancias:

- Se ha escrito incorrectamente el nombre de alguna secci¢n.

- Se han puesto varias secciones en un orden incorrecto:

{#9999,Ejemplo:}
PROGRAM mi_juego;
LOCAL
    a=0;
GLOBAL // Error: Esperando [BEGIN]
    b=0;
BEGIN
    //...
END
{-}

  Se recuerda que las secciones deben ir en el siguiente orden:

    {CONST}ú
    {#1006,GLOBAL}ú
    {#1007,LOCAL}ú
    {#1008,PRIVATE}ú

- Dentro de cualquiera de las secciones antes mencionadas ha venido un
elemento que no es una declaraci¢n v lida dentro de dicha secci¢n.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    +variable=0; // Error: Esperando [BEGIN]
BEGIN
    //...
END
{-}

  En este ejemplo, al llegar al s¡mbolo {#1056,+} el compilador determina
que la secci¢n {#1006,GLOBAL} ya ha finalizado y, por lo tanto, como el
siguiente elemento no es el inicio de las secciones {#1007,LOCAL} ni
{#1008,PRIVATE}, espera que venga la palabra reservada {#1086,BEGIN}
marcando el inicio del c¢digo del programa.

- Al comienzo del programa o al definir un proceso se ha omitido la
palabra {BEGIN}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
END

PROCESS mi_proceso()
    FRAME; // Error: Esperando [BEGIN]
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1086,BEGIN}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.530,Se esperaba una expresi¢n constante}

Para inicializar {#1004,constantes}, variables, tablas
y estructuras se deben utilizar valores num‚ricos o expresiones
cuyo valor pueda ser determinado cuando se compila el programa.

En la posici¢n indicada comienza una expresi¢n cuyo valor no ha podido ser
resuelto en tiempo de compilaci¢n, probablemente porque use algun dato
global, local o privado, o bien porque se llame a
alguna funci¢n.

En las expresiones constantes se pueden utilizar £nicamente:

    - {#1004,Constantes} definidas con anterioridad.ú
    - {Valores num‚ricos}.ú
    - {Operadores} aritm‚ticos o l¢gicos.ú
    - {Literales} (textos entre comillas).ú
    - La funci¢n {#1094,sizeof()}.ú

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    mi_variable=4;
    posici¢n=2*mi_variable; // Error: Se esperaba una expresi¢n constante.
BEGIN
    //...
END
{-}

En este ejemplo no se puede inicializar {posici¢n}, ya que se est  utilizando
para ello la variable local {x}.

{/}Ver: {#1000,Sintaxis} - {#1005,Definici¢n de constantes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.531,Se excedi¢ la tabla}

La expresi¢n constante que comienza en la posici¢n indicada del programa
no puede ser calculada, pues en ella se accede a una tabla
o estructura fuera de su rango de posiciones.

Revise el rango de la tabla o estructura en su definici¢n.
Se recuerda que una tabla definida, por ejemplo, como {tabla[10]}
tiene {11} posiciones (desde tabla[0] hasta tabla[10]).

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla[]=1, 3, 5;
    valor=tabla[3]; // Error: Se excedi¢ la tabla.
BEGIN
    //...
END
{-}

En este ejemplo no se puede inicializar la variable {valor}
dado que se est  utilizando, para ello, una posici¢n de tabla
inexistente.

{/}Ver: {#1000,Sintaxis} - {#1011,Declaraci¢n de tabla}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.532,No se puede calcular el offset}

En la expresi¢n indicada en el programa se utiliza el operador {#1085,offset}
(o el s¡mbolo sin¢nimo {#1085,&}) con el fin de obtener la direcci¢n
(desplazamiento) de un objeto. Dicho objeto no tiene direcci¢n, pues
no es una variable, una tabla o una estructura,
por lo que el compilador no puede resolver la expresi¢n.

Probablemente se haya pretendido obtener la direcci¢n de una expresi¢n constante o una que
involucre varios operandos.

A continuaci¢n se muestra un programa con varios ejemplos
de uso v lido del operador {#1085,offset}, y otros tantos inv lidos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    mi_constante=0;
GLOBAL
    mi_offset=0;
    mi_variable=0;
    mi_tabla[10];
    STRUCT mi_estructura[10]
        variable;
    END
BEGIN
    // Ejemplos correctos
    mi_offset=offset mi_variable;
    mi_offset=offset mi_tabla;
    mi_offset=offset mi_tabla[mi_variable];
    mi_offset=offset mi_estructura[0].variable;
    mi_offset=offset id.x;

    // Ejemplos err¢neos
    mi_offset=offset (mi_variable*2);
    mi_offset=offset mi_constante;
    mi_offset=offset 0;
    write_int(0, 0, 0, 0, offset (mi_variable+1));
END
{-}

No hay ninguna diferencia entre el uso de la palabra reservada {#1085,offset}
o el s¡mbolo {&}.

Las {#1005,constantes} como {mi_constante} no tiene una direcci¢n pues son
simples sin¢nimos del valor num‚rico que representan.

La sentencia {mi_offset=offset (mi_variable*2);} es err¢nea debido a que
la multiplicaci¢n se realiza en primer lugar y, una vez realizada,
el valor {mi_variable*2} se convierte en un resultado num‚rico que
no tiene ninguna direcci¢n asignada.

En cambio, la expresi¢n {offset mi_variable*2} s¡ es correcta pues, en este caso, se obtiene primero la
direcci¢n de {mi_variable} y luego ser  esta direcci¢n la que se multiplique por {2}.

{/}Ver: {#1000,Sintaxis} - {#1085,offset}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.533,Demasiados valores para la tabla}

Se ha inicializado una tabla con m s valores de los que
puede contener.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[3]=0, 1,2 , 3, 4; // Error: Demasiados valores para la tabla.
BEGIN
    //...
END
{-}

Para inicializar una tabla se debe tener en cuenta que, como
m ximo, puede tener tantos valores como indique el n£mero que va
entre los corchetes m s 1.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[3]=2, 4, 6, 8;
BEGIN
    //...
END
{-}

En este caso la tabla {tabla1} puede contener cuatro valores (tabla1[0]=2,
tabla1[1]=4, tabla1[2]=6 y tabla1[3]=8).

Otra opci¢n es {no indicar el tama¤o de la tabla}, por lo que el
compilador lo deducir  a partir de su inicializaci¢n.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[]=2, 4, 6, 8;
BEGIN
    //...
END
{-}

En este caso, si dentro del programa se necesitase hacer referencia a la longitud de la tabla,
se deber¡a utilizar la expresi¢n {sizeof(tabla1)} que, en este ejemplo, valdr¡a {4}.

{/}Ver: {#1000,Sintaxis} - {#1011,Declaraci¢n de tabla} - {#1094,sizeof()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.534,Desbordamiento en divisi¢n}

En la posici¢n indicada del programa aparece una {#1005,expresi¢n constante} que no
ha podido ser resuelta por contener dentro de sus operaciones una divisi¢n
entre cero.

Al dividir un n£mero entre cero resulta ñ infinito y como en el lenguaje
de programaci¢n s¢lo se pueden manejar n£meros enteros, dentro del rango
({#1177,min_int} ... {#1178,max_int}) no es posible guardar el resultado
de dicha operaci¢n en ninguna variable o relacionarlo con una constante.

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    infinito=1/0; // Error: Desbordamiento en divisi¢n.
BEGIN
    //...
END
{-}

Probablemente se trate de un error involuntario, de ah¡ que deba evitarse que se realice
alguna divisi¢n por cero al evaluar la expresi¢n.

{/}Ver: {#1000,Sintaxis} - {#1019,Sentencia de asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.535,Tabla de longitud negativa}

Para definir una tabla indicando entre corchetes su longitud se
debe emplear un n£mero entero positivo (0, 1, 2, 3, ...), teniendo en cuenta
que todas las tablas comienzan en la posici¢n cero y terminan en
la posici¢n que indicada en el ¡ndice.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[9];
    tabla2[-9]; // Error: Tabla de longitud negativa.
BEGIN
    //...
END
{-}

El compilador ha detectado una tabla definida con una longitud
negativa como {tabla2}; en este ejemplo se debe definir la tabla como
{tabla1} que, en este caso, ser  una tabla de 10 posiciones (desde
tabla1[0] hasta tabla1[9]).

{/}Ver: {#1000,Sintaxis} - {#1011,Declaraci¢n de tabla}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.536,Esperando [(]}

El compilador espera que en la posici¢n del programa indicada se abra un
par‚ntesis con el s¡mbolo {#1053,(}.

Hay varios casos en los que es obligada la apertura de un {#1053,par‚ntesis}:

- {Tras un nombre de un proceso o una funci¢n} se deben
indicar siempre sus par metros de llamada entre par‚ntesis; incluso cuando
el proceso o la funci¢n no tengan par metros se debe abrir un par‚ntesis,
cerr ndolo a continuaci¢n.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    mi_proceso();
    //...
END
PROCESS mi_proceso()
BEGIN
  //...
END
{-}

- {En las sentencias de control que requieran una condici¢n}
para controlar el flujo del programa, se debe poner entre par‚ntesis dicha
condici¢n.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    IF (x<10)
        //...
    END

    WHILE (x<10)
        //...
    END

    REPEAT
        //...
    UNTIL (x<10)

    SWITCH (x)
        //...
    END

    FOR (x=0;x<10;x++)
        //...
    END
END
{-}

  En este ejemplo se puede ver c¢mo las diferentes sentecias de control indican
entre par‚ntesis la condici¢n. Hay dos excepciones:

  - La sentencia {#1021,SWITCH} no requiere una condici¢n sino una simple expresi¢n;
a£n as¡, la requiere entre par‚ntesis.

  - La sentencia {#1025,FOR} tiene tres partes dentro de los par‚ntesis, separadas
por puntos y coma, siendo estas partes las siguientes: inicializaci¢n ({x=0}),
condici¢n ({x<10}) e incremento ({x++}).

- {Tras el operador {#1089,DUP}} (utilizado para inicializar
tablas y estructuras) tambi‚n es obligada la apertura
de un par‚ntesis.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[]=10 dup (1, 2, 3);
BEGIN
    //...
END
{-}

  En este ejemplo, tabla1 ser¡a una tabla de 30 posiciones (desde tabla1[0]
hasta tabla1[29]) inicializada de la siguiente forma: 1, 2, 3, 1, 2, 3, ...

{/}Ver: {#1000,Sintaxis} - {#1053,( )}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.538,No se puede duplicar 0 o menos veces}

El operador {#1089,DUP} utilizado para inicializar tablas y
estructuras permite repetir (duplicar) una secuencia de
valores un determinado n£mero de veces: desde una sola vez (en cuyo
caso el operador no tiene n¡nguna utilidad) hasta un n£mero positivo
indeterminado de veces.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[]=10 dup (1, 2, 3);
    tabla2[]=-10 dup (1, 2, 3); // Error: No se puede duplicar 0 o menos veces.
BEGIN
    //...
END
{-}

En este ejemplo, tabla1 ser¡a una tabla de 30 posiciones (desde tabla1[0]
hasta tabla1[29]) inicializada de la siguiente forma: 1, 2, 3, 1, 2, 3, ...

Es posible, adem s, omitir el operador {#1089,DUP} quedando entonces la
declaraci¢n de tabla1 de la siguiente forma:

  {tabla1[]=10(1, 2, 3);}

El efecto es exactamente el mismo que en el ejemplo anterior, es decir,
cuando el compilador se encuentra en una inicializaci¢n de tabla la secuencia
{n£mero ( secuencia_de_valores ... )} interpreta que se pretende repetir
la {secuencia_de_valores} el {n£mero} de veces que se indica.

Por tanto, es imposible repetir una secuencia de valores cero o un n£mero
negativo de veces.

{/}Ver: {#1000,Sintaxis} - {#1089,DUP}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.539,Asignaci¢n incorrecta}

No se puede realizar la asignaci¢n indicada en esta posici¢n del programa.
En una sentencia de asignaci¢n s¢lo est  permitido asignar valores a
objetos tales como variables (sean del tipo que sean) a una
posici¢n de una tabla, o a un elemento de una estructura.

No es posible asignar un valor a una {#1004,constante}, a una
funci¢n o a un proceso, o, en general, a cualquier
expresi¢n num‚rica o l¢gica.

En el siguiente programa se muestran ejemplos de varios tipos de asignaciones
incorrectas:

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    mi_constante=0;
BEGIN
    mi_constante=1;  // Error: Asignaci¢n incorrecta.
    type mi_juego=2; // Error: Asignaci¢n incorrecta.
    sizeof(mouse)=3; // Error: Asignaci¢n incorrecta.
    4+5=6;           // Error: Asignaci¢n incorrecta.
    //...
END
{-}

Todas estas asignaciones no son v lidas porque no se puede modificar con
una asignaci¢n el resultado de una expresi¢n, que es s¢lo un valor num‚rico; por ello,
es como poner una sentencia del tipo {2=4;} que, por supuesto, es imposible de realizar.

{/}Ver: {#1000,Sintaxis} - {#1035,Definici¢n de expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.540,Esperando [END]}

Dentro de las palabras reservadas {#1086,BEGIN} y {#1091,END} se espera un
bloque de sentencias, as¡ como dentro de sentencias como las que siguen:

  {#1020,IF} ... {#1090,ELSE} ... {#1091,END}ú
  {#1024,LOOP} ... {#1091,END}ú
  {#1022,WHILE} ... {#1091,END}ú
  {#1025,FOR} ... {#1091,END}ú
  {#1043,FROM} ... {#1091,END}ú
  {#1021,SWITCH} ... {#1091,END}ú

Un bloque de sentencias acaba (y s¢lo puede acabar) con cualquiera de estas
tres palabras reservadas: {#1091,END}, {#1097,UNTIL} o {#1090,ELSE}.

En el programa hay un bloque que se esperaba que acabara con la palabra
reservada {#1091,END} pero finaliza con otra palabra; los dos casos m s probables son:

- Que se haya perdido un {#1023,REPEAT} o un {#1020,IF} acabando el bloque de
sentencias con un {#1097,UNTIL} o un {#1090,ELSE}; en este caso, se debe
buscar el {#1023,REPEAT} o {#1020,IF} asociado.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
//  REPEAT
    //...
    UNTIL (key(_esc)); // Error: Esperando [END].
END
{-}

  En este ejemplo el bloque de sentencias que comenz¢ con el {#1086,BEGIN}
del programa principal ha acabado con un {#1097,UNTIL} (puesto que se ha
comentado accidentalmente el {#1023,REPEAT}), y el compilador esperaba que
este bloque acabara con un {#1091,END}.

- Que se haya perdido un {#1091,END} de alguna sentencia y llegue el
siguiente {#1016,PROCESS}, {#1408,FUNCTION} o el final del programa esperando el END que
se ha perdido.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    IF (x<0) x++;
END
PROCESS mi_proceso() // Error: Esperando [END].
BEGIN
    //...
END
{-}

  En este caso no se ha puesto el {#1091,END} del {#1020,IF} interpretando
el compilador que el {#1020,IF} acaba al llegar el siguiente {#1091,END}
(el del {#1086,BEGIN}) y por tanto, al llegar el nuevo {#1016,PROCESS} o
{#1408,FUNCTION}, se sigue esperando el {#1091,END} del {#1086,BEGIN}.

{/}Ver: {#1000,Sintaxis} - {#1091,END}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.541,Expresi¢n incorrecta}

En la posici¢n indicada del programa hay una expresi¢n
incorrectamente construida, de forma que el compilador no puede
interpretarla.

- Revise la {#1000,sintaxis} de la expresi¢n.

- En caso de no encontrar el error, intente expresarla de otra forma.

- Intente dividir la expresi¢n en varias subexpresiones realizando
secuencialmente y de forma separada los distintos c lculos que se realizan
en la expresi¢n original. Por ejemplo, la expresi¢n:

  {x=(x*4+1)/2;}

  se puede expresar como tres expresiones diferentes, que son:

  {x=x*4;}ú
  {x=x+1;}ú
  {x=x/2;}ú

  De esta forma podr  localizar en qu‚ punto exacto del c lculo se haya la
operaci¢n que no es posible realizar.

{/}Ver: {#1000,Sintaxis} - {#1035,Definici¢n de Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.542,Esperando [UNTIL]}

Un bloque de sentencias que comenz¢ con la palabra reservada {#1023,REPEAT}
debe acabar necesariamente con la palabra {#1097,UNTIL}; en la posici¢n
indicada del programa se ha finalizado el bloque de sentencias con otra
palabra diferente, lo m s probable es:

- Que se ha finalizado un {#1023,REPEAT} con un {#1091,END} en cuyo caso,
si lo que se prentende es realizar un bucle indefinidamente, se debe utilizar
la sentencia {#1024,LOOP} ... {#1091,END}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    REPEAT
    //...
    END // Error: Esperando [UNTIL]
END
{-}

- Que dentro del bucle {#1023,REPEAT} ... {#1097,UNTIL} aparezca una palabra
como {#1091,END} o {#1090,ELSE} de m s y, por lo tanto, sin su correspondiente
inicio ({#1020,IF}, {#1022,WHILE}, ...).

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    REPEAT
        IF (x<0) x++; END
            y++;
        END // Error: Esperando [UNTIL]
    UNTIL (x>=0);
END
{-}

  En este caso, se ha puesto el {#1091,END} del {#1020,IF} dos veces,
interpretando el compilador que el segundo {#1091,END} pretende cerrar el
{#1023,REPEAT}.

- O, por £ltimo, que se haya olvidado poner el {#1097,UNTIL} del
{#1023,REPEAT}.

{/}Ver: {#1000,Sintaxis} - {#1023, Sentencia REPEAT} - {#1020,IF} - {#1022,WHILE}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.543,Local no se puede acceder}

En la posici¢n indicada en el programa se pretende acceder a un dato
de otro proceso, siendo imposible ya que dicho dato no es local
del otro proceso.

Debe comprobarse que el dato que se pretende acceder est 
definido dentro de la secci¢n {#1007,LOCAL} del programa, o bien un dato
local predefinido en el lenguaje (como {#1123,x}, {#1124,y}, {#1126,graph},
{#1128,size}, ...).

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    id_mi_proceso;
    puntos=0;
BEGIN
    id_mi_proceso=mi_proceso();
    id_mi_proceso.x=0;
    id_mi_proceso.puntos=0; // Error: Local no se puede acceder.
END
PROCESS mi_proceso()
BEGIN
    //...
END
{-}

En este caso se prentende acceder a los {puntos} de {mi_proceso}, pero
{puntos} es una £nica variable {#1006,GLOBAL} y no una variable {#1007,LOCAL}
de cada proceso. Esto tambi‚n puede suceder intentando acceder a una constante
(definida en {#1005,CONST}) o a una expresi¢n como:

  {x=id_mi_proceso.(x+1);}

En este £ltimo ejemplo la expresi¢n carece de sentido por completo;
probablemente fuera la siguiente expresi¢n la que se prentendiera formular:

  {x=id_mi_proceso.x+1;}

  (equivalente a {x=(id_mi_proceso.x)+1;}).

{/}Ver: {#1000,Sintaxis} - {#1007,Declaracion datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.544,Par metro no v lido}

Los procesos pueden recibir par metros en los siguientes tipos de datos:

- Un dato local predefinido (como {#1123,x}, {#1128,size}, {#1127,flags}, ...).

- Un dato local definido dentro de la secci¢n {#1007,LOCAL}.

- Un dato global definido dentro de la secci¢n {#1006,GLOBAL}.

- Un dato privado del proceso declarado dentro de la secci¢n {#1008,PRIVATE}
del propio proceso.

- Un dato privado que {no est‚ declarado} dentro de la secci¢n
{#1008,PRIVATE}.

Entendi‚ndose en todos estos casos que un dato puede referirse a una
variable, a una posici¢n concreta de una tabla o a
un elemento dentro de una estructura.

En la posici¢n indicada del programa se pretende recibir un par metro en
un objeto diferente de los arriba indicados, o bien indicar una
expresi¢n en lugar de un simple dato. Estos son algunos ejemplos de
declaraciones de par metros inv lidas:

  {PROCESS mi_proceso(mi_constante)}ú
  No se puede recibir un par metro en una constante.

  {PROCESS mi_proceso(x*2)}ú
  No se puede recibir un par metro en una expresi¢n.

  {PROCESS mi_proceso(x=0)}ú
  No se puede recibir un par metro en una asignaci¢n.

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.545,Se esperaba otro par metro}

En las llamadas a procesos o funciones se deben poner tantos
valores o expresiones como p rametros se requieran, todos dentro del
mismo {#1053,par‚ntesis} y separados por {#1059,comas (,)}. Este
error se produce cuando se cierra el par‚ntesis tras una {#1059,coma},
como en el siguiente ejemplo:

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    signal(id, ); // Error: Se esperaba otro par metro.
END
{-}

Puede haber pasado dos cosas; se ha puesto una coma accidentalmente tras
el £ltimo par metro, o bien se ha omitido el £ltimo par metro (como en el
ejemplo anterior).

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.546,N£mero de par metros incorrecto}

El proceso o funci¢n tiene un n£mero diferente de par metros a los que aparecen
en la posici¢n se¤alada en el programa.

Si se trata de una funci¢n, acceda al {glosario} para consultar los par metros
que requiere o bien sit£e el cursor sobre el nombre de la funci¢n en el
programa y entonces pulse {F1}.

Si se trata de un proceso, entonces puede que en la posici¢n se¤alada el
n£mero de par metros sea correcto pero haya aparecido una llamada a dicho
proceso anteriormente en el programa con un n£mero diferente de par metros.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    mi_proceso();
END
PROCESS mi_proceso(x, y) // Error: N£mero de par metros incorrecto.
BEGIN
    //...
END
{-}

En este ejemplo el error no est  en la definici¢n del proceso como se indica,
sino en la llamada anterior a dicho proceso ({mi_proceso();}); esto es as¡
porque el compilador, cuando se encuentra una llamada a un proceso que no
conoce, lo registra como un nuevo proceso y apunta su n£mero de par metros.
Si la pr¢xima vez que se encuentre dicho proceso no coincide el n£mero de
par metros con los que ten¡a registrados, entonces se emite el error.

Por tanto, en caso de ser correcta la llamada o definici¢n del proceso
se¤alada en el programa, utilice la opci¢n de b£squeda ({ALT-F}) para revisar
el n£mero de par metros en las anteriores llamadas a dicho proceso.

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.547,Esperando [;]}

La sentencia {#1024,FOR} tiene tres partes dentro de los par‚ntesis separadas
por puntos y coma, siendo estas partes las siguientes:

  FOR ({inicializaci¢n}; {condici¢n}; {incremento})

- La {inicializaci¢n} suele ser una {#1019,asignaci¢n} que fija el
valor de un dato cuando se comienza a ejecutar la sentencia {#1025,FOR}.

- La condici¢n que se establece en segundo lugar determina
la permanencia dentro del bucle; cada iteraci¢n se mirar  primero
si se cumple dicha condici¢n y, en caso contrario, se finalizar 
la ejecuci¢n de la sentencia {#1025,FOR}.

- El {incremento} actualiza el valor del dato que sirve como contador tras cada
iteraci¢n del bucle.

Ninguna de las tres partes son obligatorias, pero s¡ lo son los par‚ntesis
y los dos s¡mbolos {#1068,punto y coma (;)} que separan las partes.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FOR ( graph=10 ; graph<20 ; graph=graph+1 )
        //...
    END
    FOR ( graph=10 ; graph<20 graph=graph+1) // Error: Esperando [;]
        //...
    END
END
{-}

Dentro de cada una de las tres partes se pueden poner varias sentencias
siempre que se separen por {#1059,comas (,)} (varias inicializaciones, condiciones o
incrementos).

{/}Ver: {#1000,Sintaxis} - {#1068, Punto y coma (;)} - {#1025,Sentencia FOR}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.548,[BREAK] no aparece dentro de un bucle}

La sentencia {#1026,BREAK} provoca que el programa contin£e tras el bucle que se
est‚ ejecutando.

Esta sentencia sirve para salir de los siguientes bucles:

  {#1024,LOOP} ... {#1091,END}ú
  {#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
  {#1023,REPEAT} ... {#1097,UNTIL} {#1053,(} .. {#1053,)}ú
  {#1022,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
  {#1025,FOR} {#1053,(} .. {#1068,;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú

Un {#1026,BREAK} provocar  que el programa contin£e ejecut ndose
tras el {#1091,END} o {#1097,UNTIL} del bucle m s cercano a la sentencia.
{#1026,BREAK} s¢lo puede aparecer dentro de uno de estos bucles}.

En caso de haber varios bucles anidados (unos dentro de otros) la sentencia
{#1026,BREAK} saldr  unicamente del bucle m s interior de todos ellos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    LOOP
        REPEAT
            IF (key(_esc)) BREAK; END
            //...
        UNTIL (x==0);
        //...
    END
    BREAK; // Error: [BREAK] no aparece dentro de un bucle.
END
{-}

En este ejemplo la sentencia {#1026,BREAK} saldr  del
{#1023,REPEAT} ... {#1097,UNTIL} (cuando se pulse la tecla {ESC})
pero no del {#1024,LOOP} ... {#1091,END}.

{/}Ver: {#1000,Sintaxis} - {#1026,Sentencia BREAK}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.549,[CONTINUE] no aparece dentro de un bucle}

La sentencia {#1027,CONTINUE} provoca que el programa finalice la
iteraci¢n actual del bucle que se est‚ ejecutando.

Esta sentencia sirve para ir al inicio/final de los siguientes
bucles:

{#1024,LOOP} ... {#1091,END}ú
Un {#1027,CONTINUE} dentro de este bucle saltar  al {#1024,LOOP}.

{#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
Un {#1027,CONTINUE} dentro de este bucle realizar  el incremento
({#1095,STEP}) y, si no se ha pasado el valor indicado en el
{#1096,TO}, continuar  el programa al inicio del bucle.

{#1023,REPEAT} ... {#1097,UNTIL} {#1053,(} .. {#1053,)}ú
Un {#1027,CONTINUE} dentro de este bucle saltar  al {#1097,UNTIL}.

{#1022,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
Un {#1027,CONTINUE} dentro de este bucle saltar  al {#1022,WHILE}.

{#1025,FOR} {#1053,(} .. {#1068,;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú
Un {#1027,CONTINUE} dentro de este bucle realizar  el incremento
y la comparaci¢n; si ‚sta £ltima resulta cierta continuar  el
programa al inicio del bucle, pero si resulta falsa el programa
continuar  tras el {#1091,END} del {#1025,FOR}.

{#1027,CONTINUE} {debe aparecer obligatoriamente dentro de uno de estos bucles}.

En caso de haber varios bucles anidados (unos dentro de otros) la sentencia
{#1027,CONTINUE} tendr  efecto £nicamente en el bucle m s interior de ellos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FOR (x=0, y=0;x<10;x++)
        IF (x<5) CONTINUE; END
        y++;
    END
END
{-}

En este ejemplo tras ejecutarse el bucle completo {x} valdr  {10} e {y}
valdr  {5}, pues mientras {x} es menor que 5 la sentencia {#1027,CONTINUE}
impide que se ejecute la sentencia {y++;}.

{/}Ver: {#1000,Sintaxis} - {#1027,Sentencia CONTINUE}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.550,Esperando [CASE], [DEFAULT] o [END]}

La sintaxis de la sentencia {#1021,SWITCH} es, a grandes rasgos, como sigue:

    {#1021,SWITCH} {#1053,( }expresi¢n{#1053, )}ú
        {#1087,CASE} valor{#1067, :}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} valor{#1064, .. }valor{#1067, :}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} valor, valor, valor{#1067, :}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
        //...ú
        {#1088,DEFAULT} {#1067,:}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
    {#1091,END}

La posici¢n se¤alada en el programa est  dentro de una sentencia {#1021,SWITCH},
pero fuera de una secci¢n {#1087,CASE} o {#1088,DEFAULT}; por eso el compilador
esperaba que en dicha posici¢n apareciera una de estas tres sentencias:

- La palabra reservada {#1087,CASE} iniciando una nueva secci¢n a ejecutar
cuando la expresi¢n coincidiera con el valor indicado.

- La palabra reservada {#1088,DEFAULT} iniciando una secci¢n por defecto a
ejecutar cuando la expresi¢n no coincidiera con ninguno de los valores
indicados en las diferentes secciones {#1087,CASE}.

- La palabra reservada {#1091,END} dando por finalizada la sentencia
{#1021,SWITCH}.

Para ver una descripci¢n m s detallada de la sentencia {#1021,SWITCH}
consulte la sintaxis del lenguaje.

{/}Ver: {#1000,Sintaxis} - {#1021,Sentencia SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.551,Esperando [END]}

Se esperaba un {#1091,END} del {#1087,CASE} o {#1088,DEFAULT} dentro de la
sentencia {#1021,SWITCH}.

Dentro de las palabras reservadas {#1021,SWITCH} y {#1091,END} se espera una
o m s secciones del tipo:

  {#1087,CASE} ... {#1091,END}ú
  {#1088,DEFAULT} ... {#1091,END}ú

En el programa hay una de estas secciones que se esperaba que acabe con
la palabra reservada {#1091,END} pero acaba con otra palabra; el caso m s
probable es:

- Que se haya perdido un {#1023,REPEAT} o un {#1020,IF} acabando el bloque
de sentencias con un {#1097,UNTIL} o un {#1090,ELSE}; en este caso se debe
buscar el {#1023,REPEAT} o {#1020,IF} asociado.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    SWITCH (x)
        CASE 0:
            //REPEAT
            //...
            UNTIL (key(_esc)); // Error: Esperando [END]
        END
    END
END
{-}

En este ejemplo la secci¢n que comenz¢ con el {#1087,CASE} ha acabado con
un {#1097,UNTIL} (puesto que se ha comentado accidentalmente el
{#1023,REPEAT}), y el compilador esperaba que esta secci¢n acabara con un
{#1091,END}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.552,Esperando [PROCESS] o [FUNCTION]}

El compilador ha interpretado que, en la posici¢n se¤alada en el
programa, ha finalizado el programa principal
({#1015,PROGRAM} ... {#1086,BEGIN} ... {#1091,END}), o el £ltimo
proceso ({#1016,PROCESS}) o funci¢n ({#1408,FUNCTION}) y, a
continuaci¢n, se esperaba que continuara otro proceso o bien que
acabara el programa.

Lo m s frecuente es haber duplicado un {#1091,END} dentro del £ltimo bloque de
sentencias {#1086,BEGIN} ... {#1091,END}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    IF (x<0) x++; END
    END
    FRAME; // Error: Esperando [PROCESS] o [FUNCTION].
END
{-}

En este ejemplo se ha puesto accidentalmente dos veces el {#1091,END}
del {#1020,IF}, interpretando el compilador que el segundo es el {#1091,END}
del {#1086,BEGIN}, por lo tanto, tras este £ltimo {#1091,END} s¢lo
puede venir el final del programa o las palabras reservadas {#1016,PROCESS}
o {#1408,FUNCTION} marcando el inicio de un nuevo bloque. Al encontrarse en esa
posici¢n una sentencia {#1029,FRAME}, el compilador emite el error.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.553,No se puede especificar una tabla como par metro}

No es necesario declarar dentro de la secci¢n {#1008,PRIVATE} los
{#1018,par metros del proceso}, pues ‚stos se declaran de forma autom tica;
pero en caso de declararlos se deben declarar como variables
no como tablas o estructuras, y no se deben inicializar.

Lo m s probable es que se haya pretendido utilizar el mismo nombre para dos
objetos diferentes; por un lado, para uno de los par metros del proceso
y, por otro, para una tabla {#1008,PRIVATE} del mismo proceso.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
END
PROCESS mi_proceso(a)
PRIVATE
    a[9]; // Error: No se puede especificar una tabla como par metro.
BEGIN
    //...
END
{-}

El compilador interpreta que se est  tipificando el par metro {a} como
una tabla de 10 posiciones y como no se puede pasar una tabla como
par metro, emite el error.

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.554,No se puede inicializar un par metro}

No es necesario declarar dentro de la secci¢n {#1008,PRIVATE}
los {#1018,par metros del proceso}, ya que ‚stos se declaran
de forma autom tica, si bien en caso de declararlos se deben declarar
como variables no como tablas o estructuras, y no se deben inicializar.

Lo m s probable es que se haya pretendido utilizar el mismo nombre para dos
objetos diferentes, por un lado, para uno de los par metros del proceso y, por otro,
para una variable {#1008,PRIVATE} del mismo proceso.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
END
PROCESS mi_proceso(a)
PRIVATE
    a=0; // Error: No se puede inicializar un par metro.
BEGIN
    //...
END
{-}

El compilador interpreta que se est  inicializando el par metro {a} a {0},
y como no est  permitido inicializar un par metro (pues su valor lo tomar 
en funci¢n de la llamada al proceso), se emite el error.

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.555,Lleg¢ el final dentro de un comentario}

Ha llegado el final del programa dentro de un comentario de varias l¡neas
(los definidos entre los s¡mbolos{#1002, /*} y{#1002, */}).

Este error se debe a que alg£n comentario no se ha cerrado, por ello se debe revisar
que todos los comentarios abiertos con el s¡mbolo{#1002, /*} tengan su
correspondiente s¡mbolo{#1002, */} cerr ndolos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    /* Inicio del comentario
    FRAME;
END // Error: Lleg¢ el final dentro de un comentario.
{-}

{/}Ver: {#1000,Sintaxis} - {#1002,Definici¢n de comentarios}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.556,No se puede acceder a datos PRIVATE externos}

En la posici¢n indicada del programa se intenta acceder a un dato
de tipo {#1008,PRIVATE} de otro proceso; no est  permitido.

Si se quiere acceder desde un proceso a un dato de otro proceso, ‚ste se
debe declarar dentro de la secci¢n {#1007,LOCAL}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE n;
BEGIN
    mi_proceso();
    //...
END
PROCESS mi_proceso()
PRIVATE n;
BEGIN
    father.n=0; // No se puede acceder a datos PRIVATE externos.
END
{-}

Es imposible acceder a datos {#1008,PRIVATE} incluso cuando el proceso accedido
es del mismo tipo que el proceso que est  intentando acceder al dato.

La forma correcta en la que se debe declarar la variable {n} en el ejemplo
anterior es como se muestra a continuaci¢n:

{#9999,Ejemplo:}
PROGRAM mi_juego;
LOCAL n;
BEGIN
    mi_proceso();
    //...
END
PROCESS mi_proceso()
BEGIN
    father.n=0;
END
{-}

Se recuerda que los datos declarados dentro de la secci¢n {#1007,LOCAL}
los tendr n todos los procesos del programa (todos los procesos del ejemplo
anterior tendr n una variable propia de nombre {n}).

{/}Ver: {#1000,Sintaxis} - {#1008,Declaraci¢n de datos PRIVATE}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.557,Una estructura debe contener, al menos, un elemento}

En la posici¢n resaltada del programa se pretende cerrar con
{#1091,END} la declaraci¢n de una estructura sin
ning£n elemento (campo) definido en la misma.

Una estructura ({#1012,STRUCT}) es como una lista de fichas
(registros) con varias informaciones (campos) en cada ficha.

{STRUCT nombre_estructura[10]}ú
    {x, y;}ú
{END}

En este ejemplo la estructura (conjunto de fichas) se llama {nombre_estructura}
y tiene {10 registros} (diez fichas) con {2 campos} cada una (con dos
informaciones; {x} e {y}).

Por lo tanto, no tiene ning£n sentido definir una estructura
sin campos (ya que es como definir un conjunto de fichas sin ninguna
informaci¢n).

Para acceder despu‚s a la informaci¢n de las fichas se utiliza la estructura
como sigue (sup¢ngase que se quiere poner en la variable global {n} el valor
{y} de la ficha n£mero {5}).

{n=nombre_estructura[5].y;}

A continuaci¢n se muestra un programa err¢neo.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT mi_estructura[10]

    END // Error: Una estructura debe contener, al menos, un elemento.
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1012,Declaraci¢n de Estructura}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.558,Esperando un elemento de la estructura}

En la posici¢n se¤alada del programa se pretende declarar un elemento (campo)
de la estructura no v lido.

Una estructura puede tener £nicamente campos de los siguientes tipos:

- Una variable, en cuyo caso se deber  indicar en la declaraci¢n el
nombre de la misma, sin inicializar.

- Una tabla, indicando el nombre de la misma y, a continuaci¢n,
entre corchetes, la longitud de la misma (se recuerda que una tabla declarada
como {mi_tabla[9];} es una tabla de {10} posiciones, desde mi_tabla[0] hasta
mi_tabla[10]). Tampoco se deben inicializar.

- Otra estructura. Es posible incluir estructuras dentro de
otras estructuras, sin ning£n l¡mite de anidamiento, hasta donde sea
necesario. A continuaci¢n se muestra un ejemplo de anidamiento de estructuras.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT mi_estructura[9]
        elementos;
        STRUCT datos[9]
            x, y;
        END
    END
    a, b;
BEGIN
    FROM a=0 TO 9;
        mi_estructura[a].elementos=-1;
        FROM b=0 TO 9;
            mi_estructura[a].datos[b].x=-1;
            mi_estructura[a].datos[b].y=-1;
        END
    END
    //...
END
{-}

En este ejemplo, cada registro de {mi_estructura} tendr  una variable
denominada {elementos} y otra estructura con 10 elementos cada uno con dos
variables: {x} e {y}.

M s adelante, en el mismo ejemplo, se puede observar un ejemplo de acceso
a dicha estrucutra con dos bucles anidados que inicializan todos los
valores de la estructura a{ -1}.

Para ver c¢mo se debe inicializar en propia definici¢n los valores de
una estructura acceda al t¢pico {#1000,sintaxis}.

{/}Ver: {#1000,Sintaxis} - {#1012,Declaraci¢n de Estructura}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.560,No es un tipo de proceso}

El operador {#1042,TYPE} puede utilizarse £nicamente si precede a un
nombre de proceso del programa o a la palabra {#1100,mouse}
(para la detecci¢n de colisiones con el puntero del rat¢n).

En la posici¢n se¤alada del programa no est  precediendo a un nombre de
proceso; es probable que se haya escrito el nombre del proceso incorrectamente
o bien que se intente obtener el tipo de un proceso a partir de su {#1039,c¢digo identificador}.

Hay una forma de obtener el tipo de un proceso disponiendo de su {#1039,c¢digo identificador},
como se muestra a continuaci¢n (sup¢ngase que el identificador se tiene en
la variable {id2}).

    {id2.reserved.process_type}

En lugar de {TYPE id2} que no est  permitido (pues no hay ning£n proceso
con el nombre {id2}, ya que {id2} es una variable).

A continuaci¢n se muestra un ejemplo de uso correcto del operador {#1042,TYPE}
(con el fin de obtener el {#1039,c¢digo identificador} de un proceso).

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE
    id2;
BEGIN
    //...
    id2=get_id(TYPE mi_proceso);
    //...
    id2=get_id(TYPE id2); // Error: No es un tipo de proceso.
    //...
END
PROCESS mi_proceso()
BEGIN
    //...
END
{-}

Como se puede observar, el operador {#1042,TYPE} requiere el nombre de un
proceso del programa sin par‚ntesis ni par metros.

{/}Ver: {#1000,Sintaxis} - {#1042,Tipos de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.561,No se puede calcular el tama¤o}

La funci¢n {#1094,sizeof()} se puede utilizar para obtener el n£mero de
elementos de una tabla o de una estructura; para ello
requiere, entre {#1053,par‚ntesis}, el nombre de la tabla o
estructura (sin corchetes ni ¡ndice).

Tambi‚n se puede utilizar con el nombre de una variable pero, en este caso,
la funci¢n devolver  siempre 1.

Se puede utilizar indistintamente con datos globales, locales
o privados.

En la posici¢n se¤alada del programa se pretende obtener el tama¤o de un
objeto que no es una variable, tabla o estructura. Por ejemplo, este error
se producir  si se intenta obtener el tama¤o de una constante, funci¢n,
proceso, etc.

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    mi_constante=99;
GLOBAL
    a=sizeof(mi_constante); // Error: No se puede calcular el tama¤o.
BEGIN
    //...
END
{-}

Este ejemplo provocar  el error al intentar obtener el n£mero de elementos
de una {#1004,constante}, pues una constante no es un objeto que tenga un tama¤o
sino que, simplemente, es un s¡nonimo del valor num‚rico que representa.

{/}Ver: {#1000,Sintaxis} - {#1094,sizeof}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.562,Uso: IMPORT "nombre.dll"}

El compilador esperaba que, tras la palabra reservada {#1014,IMPORT}, apareciera
entre comillas el nombre del archivo.

Para declarar el uso de una librer¡a externa se debe poner una declaraci¢n
como en el siguiente ejemplo.

{#9999,Ejemplo:}
PROGRAM mi_juego;
IMPORT "libreria.dll";
BEGIN
    //...
END
{-}

Este programa declara el uso de la librer¡a denominada {libreria.dll}
(supuesto nombre de una hipot‚tica librer¡a de funciones externas).

La declaraci¢n debe hacerse justo {tras la cabecera del programa},
es decir, tras la declaraci¢n {PROGRAM nombre_de_programa;}. Pudiendo
hacerse varias declaraciones {#1014,IMPORT} seguidas, para declarar el
uso de m s de una librer¡a.

{/}Ver: {#1000,Sintaxis} - {#1014,Declaraci¢n de librer¡as}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.563,Uso de una DLL externa no v lida}

En la posici¢n indicada del programa se pretende cargar una {DLL} que no
es v lida; esto puede deberse a uno de estos motivos:

- El archivo con la {DLL} se ha corrompido al almacenarse en alg£n medio defectuoso.

- No se trata de una {DLL} espec¡ficamente dise¤ada para DIV Games Studio.

- No se encuetra el archivo con extensi¢n {DLL} en la ruta especificada por
la sentencia {#1014,IMPORT}.

No se pueden utilizar {DLL} de otros lenguajes, pues no son compatibles con
este lenguaje aunque los archivos tengan todos la extension {DLL}.

En caso de tratarse de una {DLL} preparada para este lenguaje, revise sus
instrucciones de instalaci¢n y compruebe que el archivo con extensi¢n
{DLL} se encuentra en el directorio de DIV Games Studio, o bien que la
sentencia {#1014,IMPORT} especifica la ruta completa de acceso a dicho archivo.

{/}Ver: {#1000,Sintaxis} - {#1014,Declaraci¢n de librer¡as}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.564,Expresi¢n sin sentido}

En la posici¢n se¤alada en el programa el compilador ha supuesto que comenzaba
una sentencia de uno de estos tipos:

    Asignaciones, ej.:ú
    <dato>{ = }<expresi¢n>{ ; }

    Incrementos o decrementos, ej.:ú
    <dato>{ ++ ;}

    Llamada a un proceso o funci¢n, ej.:ú
    <nombre_proceso>{ ( }...{ ) ;}

Pero, en su lugar, se ha encontrado con una expresi¢n que parece carecer de
sentido, ya que una vez efectuadas sus operaciones no se utiliza el resultado
de la misma con ning£n prop¢sito.

Es probable que se trate de alg£n operador suelto que se ha dejado fuera de
una sentencia, por ejemplo, por haberse perdido un operador.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x+1; // Error: Expresi¢n sin sentido.
    //...
END
{-}

En este ejemplo se advierte de este error, pues la sentencia {x+1;} carece
de utilidad, suma la variable {x} y la constante {1}, pero, desp£es, no se
utiliza este resultado para ning£n fin. Si lo que se quiere es sumarle {1}
a la variable {x} se debe hacer con la siguiente sentencia:

    {x=x+1;}

Aqu¡ se suma la variable {x} y la constante {1} y despu‚s se utiliza este
resultado para asign rselo a la variable {x}; esto tamb¡en se podr¡a haber
hecho con la sentencia {x++;} (incrementar x).

{/}Ver: {#1000,Sintaxis} - {#1019,Sentencia de asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.565,Esperando [:]}

La posici¢n se¤alada en el programa est  dentro de una sentencia {#1021,SWITCH},
tras el comienzo de una secci¢n con "{#1087,CASE} valor", por eso el compilador
esperaba que, en dicha posici¢n, apareciera el s¡mbolo{#1067, :} precediendo a
las sentencias de dicha secci¢n.

La sintaxis de la sentencia {#1021,SWITCH} es, a grandes rasgos, como sigue:

    {#1021,SWITCH} {#1053,( }expresi¢n{#1083, )}ú
        {#1087,CASE} valor{#1067, :}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} valor{#, .. }valor{#1067, :}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} valor, valor, valor{#1067, :}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
        //...ú
        {#1088,DEFAULT} {#1067,:}ú
            sentencias{#1068,;}ú
        {#1091,END}ú
    {#1091,END}

Para ver una descripci¢n m s detallada de la sentencia {#1021,SWITCH}
consulte la sintaxis del lenguaje.

{/}Ver: {#1000,Sintaxis} - {#1021,Sentencia SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.566,Esperando [;]}

El compilador espera un {#1068,punto y coma (;)} en la posici¢n indicada en
el programa.

En el lenguaje se deben indicar con puntos y coma los siguientes
puntos del programa:

- El final de las {#1400,opciones de compilaci¢n}.

- El final de la {#1003,declaraci¢n PROGRAM}.

- El final de una {#1009,declaraci¢n de un dato}.

- El final de una {#1014,declaraci¢n IMPORT}.

- El final de las siguientes sentencias:ú
    {#1019,Asignaciones o incrementos de datos}.ú
    {#1033,Llamadas a procesos}.ú
    {#1032,Llamadas a funciones}.ú
    {#1029,FRAME}, {#1028,RETURN}, {#1031,DEBUG}, {#1026,BREAK} y {#1027,CONTINUE}.ú

- El final de un inicio de bucle {#1043,FROM}.

- Y como separador de las diferentes partes de una sentencia {#1025,FOR}.

El compilador indicar  cu ndo falta el s¡mbolo {;} en cualquiera de estos
puntos.

Pudiendo, adem s, ponerse dicho s¡mbolo en otros puntos determinados de los
programas, como detr s de cualquier otro tipo de sentencia, aunque en este
caso ser  opcional y, por tanto, el compilador no advertir  de su ausencia.

{/}Ver: {#1000,Sintaxis} - {#1068, ; }

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.567,Esperando variable}

El compilador esperaba una variable global, local o
privada del proceso en la posici¢n indicada en el programa.

La sintaxis de la sentencia de bucle {#1043,FROM} es la siguiente:

{FROM} <variable>{=}{#1005,<constante>} {#1096,TO} {#1005,<constante>} {#1095,STEP} {#1005,<constante>}{;}ú
    {#1017,<sentencia>} {;}ú
    ...ú
{END}

Siendo la declaraci¢n {STEP <constante>} opcional.

Tras la palabra reservada {#1043,FROM} debe aparecer directamente el
{#1001,nombre} de una variable (normalmente local o privada del proceso).

Si se quiere utilizar como contador una variable de otro proceso,
una tabla o un elemento de una estructura, se debe utilizar la
sentencia {#1025,FOR} en lugar de {#1043,FROM}, ya que ‚sta permite mayor libertad
a la hora de definir las condiciones del bucle.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.568,Esperando [=]}

El compilador esperaba un s¡mbolo {#1073,=} (asignaci¢n) en la posici¢n indicada
en el programa.

La sintaxis de la sentencia de bucle {#1043,FROM} es la siguiente:

{FROM} <variable>{=}{#1005,<constante>} {#1096,TO} {#1005,<constante>} {#1095,STEP} {#1005,<constante>}{;}ú
    {#1017,<sentencia>} {;}ú
    ...ú
{END}

Siendo la declaraci¢n {#1095,STEP <constante>} opcional.

Tras la palabra reservada {#1043,FROM} debe aparecer directamente el
{nombre} de una variable (normalmente local o
privada del proceso) y, tras ‚ste, el s¡mbolo {#1073,=}
(asignaci¢n).

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    id2;
BEGIN
    //...
    FROM id2.x=0 TO 9; // Error: Esperando [=].
        //...
    END
END
{-}

En este ejemplo el error se produce al detectarse tras el {primer nombre}
que aparece ({id2}) el s¡mbolo{#1063, . (punto)} en lugar de {#1073,=}. Esto
sucede porque no se puede utilizar como contador de un bucle {#1043,FROM}
una variable de otro proceso.

Si se quiere utilizar como contador una variable de otro proceso,
una tabla o un elemento de una estructura, se debe utilizar la
sentencia {#1025,FOR}, en lugar de {#1043,FROM}, ya que ‚sta permite mayor
libertad a la hora de definir las condiciones del bucle.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.569,Esperando [TO]}

El compilador esperaba la palabra reservada {#1096,TO} de la sentencia
{#1043,FROM} en la posici¢n indicada en el programa.

La sintaxis de la sentencia de bucle {#1043,FROM} es la siguiente:

{#1043,FROM} <variable>{=}{#1005,<constante>} {#1096,TO} {#1005,<constante>}
{#1095,STEP} {#1005,<constante>}{;}ú
    {#1017,<sentencia>} {;}ú
    ...ú
{#1091,END}

Siendo la declaraci¢n {#1095,STEP <constante>} opcional.

Tras la palabra reservada {#1043,FROM} debe aparecer directamente el
{nombre} de una variable (normalmente local o privada
del proceso) y, tras ‚ste, el s¡mbolo {#1073,=} (asignaci¢n)
precediendo a una constante. {Tras este valor constante s¢lo puede aparecer
la palabra reservada {#1096,TO}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    id2;
BEGIN
    //...
    FROM id2.x=0 STEP 9; // Error: Esperando [TO].
        //...
    END
END
{-}

En una sentencia {#1043,FROM} siempre deben aparecer los valores {inicial}
y {final} de la variable contador del bucle a ambos lados de la
palabra {#1096,TO}.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.570,El valor STEP no es v lido}

En una sentencia {#1043,FROM}:

- Si el valor inicial {es menor} que el valor final, no se puede
especificar un valor negativo en la declaraci¢n {#1095,STEP}.

- Si el valor inicial {es mayor} que el valor final, no se puede
especificar un valor positivo en la declaraci¢n {#1095,STEP}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FROM x=0 TO 10 STEP -1; // Error: El valor STEP no es v lido.
        //...
    END
END
{-}

Este bucle no es v lido pues si a {x}, que originalmente valdr  {0},
se le resta {1} en cada iteraci¢n, no llegar  nunca a {10}. Si lo que
se pretende es hacer un bucle que se repita siempre, se debe utilizar
la sentencia {#1024,LOOP}.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.571,Sentencia FROM incorrecta}

En una sentencia {#1043,FROM}:

- Los valores {inicial} y {final} de un bucle {#1043,FROM} deben ser
diferentes.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FROM x=0 TO 0; // Error: Sentencia FROM incorrecta.
        //...
    END
END
{-}

Realizar este bucle no tiene sentido, pues no se va a repetir el
grupo interior de sentencias m s que una sola vez, lo que ser¡a
equivalente a inicializar {x} a {0} (con la sentencia {x=0;}) y,
despu‚s, poner directamente las sentencias interiores, omitiendo
el bucle {#1043,FROM}.

Si lo que se pretende es hacer un bucle que se repita siempre, se debe
utilizar la sentencia {#1024,LOOP}.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.599,Compilaci¢n correcta}

El programa no tiene errores de compilaci¢n, pulse:

{Men£ programas\Ejecutar} o {F10}.ú
Para grabar, compilar y ejecutar el programa.

{Men£ programas\Trazar} o {F12}.ú
Para grabar, compilar y trazar paso a paso el programa.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.600,Excedida la capacidad del vector de nombres}

Se excedi¢ el buffer para almacenar los {#1001,nombres} del programa;
este error puede deberse £nicamente a que se han utilizado nombres de
datos y procesos demasiado largos.

La £nica soluci¢n para poder compilar el programa es sustituir algunos
de estos nombres por otros m s peque¤os.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.601,Excedida la capacidad de la versi¢n demo}

Esta versi¢n DEMO de DIV Games Studio no permite crear programas tan grandes
como este, s¢lo puede compilar programas de un determinado n£mero de variables
y procesos.

En la versi¢n completa de DIV GAMES STUDIO no existe esta limitaci¢n, pudi‚ndose
crear programas de cualquier tama¤o.

La £nica opci¢n para poder compilar este programa es eliminando primero
todos los procesos y datos que ya no se requieran y/o no sean
imprescindibles.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.602,Excedida la capacidad de la tabla de objetos}

Se excedi¢ el espacio disponible para guardar registros de los datos y
los procesos del programa.

Este error no deber¡a suceder nunca pero si ha sucedido
tiene dif¡cil soluci¢n; el programa es demasiado grande para esta versi¢n
del compilador.

Si existe una nueva versi¢n del compilador o alg£n 'patch' que actualice
esta limitaci¢n, debe actualizarse.

En caso contrario la £nica opci¢n es eliminar del programa todos los
procesos y {#1034,datos} que ya no se requieran y/o no sean
imprescindibles.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.610,Esperando el nombre de la estructura}

Para definir una estructura de datos se debe especificar el nombre de la misma
tras la palabra reservada {#1012,STRUCT}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT posiciones[9]
        x, y;
    END
BEGIN
    //...
END
{-}

Esta estructura se ha definido con el nombre {posiciones} y contiene
{diez registros} (del 0 al 9) cada uno con dos valores {x} e {y}.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1012,Declaraci¢n Estructuras}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.611,Esperando el nombre del proceso o funci¢n}

Para definir un proceso o funci¢n se debe especificar el nombre del mismo
tras las palabras reservadas {#1016,PROCESS} o {#1408,FUNCTION}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
END

PROCESS mi_proceso()
BEGIN
    //...
END
{-}

Este proceso se ha declarado con el nombre {mi_proceso}.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.612,Esperando el nombre de un proceso}

Tras la palabra reservada {#1042,TYPE} se debe especificar el nombre de
uno de los procesos definidos en el programa.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
    signal(TYPE mi_proceso, s_kill);
    //...
END

PROCESS mi_proceso()
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1042,Tipos de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.613,Esperando un nombre}

La funci¢n {#1094,sizeof()} requiere como par metro el nombre de un dato,
pudiendo ser el nombre de una variable, una tabla o una
estructura del programa.

Esta funci¢n devuelve el numero de datos (o elementos) que tiene el objeto
cuyo nombre se le pasa como argumento; por lo tanto, si dicho objeto era una
variable, la funci¢n siempre devolver  1.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla[]=0, 1, 2, 3;
    longitud_tabla;
BEGIN
    longitud_tabla=sizeof(tabla);
END
{-}

En este ejemplo {longitud_tabla} valdr  {4} tras ejecutarse la sentencia,
ya que la tabla contiene cuatro datos.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1094,sizeof}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.614,El nombre no es nuevo}

Se ha utilizado un nombre para un campo de la estructura dos
veces. Debe sustituir dicho nombre por otro similar.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
GLOBAL
    STRUCT posicion[9]
        x0, x0; // Error: El nombre no es nuevo.
    END
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1012,Declaraci¢n de estructura}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.615,El nombre no es nuevo}

Se ha utilizado un {#1001,nombre} de programa no v lido pues ‚ste
ya estaba predefinido como nombre de otro objeto. Debe sustituir
dicho nombre por otro similar.

Para saber a qu‚ objeto est  identificado con dicho {#1001,nombre} puede acceder al
{glosario}.

{#9999,Ejemplo:}
PROGRAM x; // Error: El nombre no es nuevo.
BEGIN
    //...
END
{-}

En este ejemplo se pretend¡a utilizar como nombre del programa {x},
que est  predefinido como nombre de la variable local que indica la coordenada
x de los procesos.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.616,El nombre no es nuevo}

Se ha utilizado para definir una {#1004,constante} un {#1001,nombre}
no v lido, pues ‚ste ya estaba predefinido como nombre de otro objeto.
Puede tratarse de un nombre de una constante, una variable,
una tabla, una estructura, un proceso o
una funci¢n del programa.

Puede ser, tambi‚n, que se haya pretendido utilizar el mismo {#1001,nombre}
dentro del programa para identificar dos objetos diferentes, o bien
{puede que se haya utilizado un nombre predefinido para otro uso dentro
del lenguaje}. En dicho caso se puede acceder al {glosario} para ver a
qu‚ objeto se refiere dicho nombre.

Debe sustituir dicho nombre por otro similar.

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    x=0; // Error: El nombre no es nuevo.
BEGIN
    //...
END
{-}

En este ejemplo se pretend¡a utilizar como nombre de una constante {x} que
est  predefinido como variable local que indica la coordenada {#1123,x} de los
procesos.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.617,El nombre no es nuevo}

Se ha utilizado para definir un nuevo dato un {#1001,nombre}
no v lido, pues ‚ste ya estaba predefinido como nombre de otro
objeto. Puede tratarse de un nombre de una {#1004,constante},
una variable, una tabla, una estructura,
un proceso o una funci¢n del programa.

Asimismo, puede ser que se haya pretendido utilizar el mismo nombre dentro del
programa para identificar dos objetos diferentes, o bien {que se
haya utilizado un nombre predefinido para otro uso dentro del lenguaje}.
En dicho caso se puede acceder al {glosario} para ver a qu‚ objeto se refiere
dicho nombre.

Debe sustituir dicho nombre por otro similar.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    x[3]=0, 1, 2, 3; // Error: El nombre no es nuevo.
BEGIN
    //...
END
{-}

En este ejemplo se pretend¡a utilizar como nombre de una tabla global {x}
que est  predefinido como variable local que indica la coordenada {#1123,x} de los
procesos.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.618,El nombre no es nuevo}

Se ha utilizado un {#1001,nombre} de un proceso no v lido pues ‚ste
ya estaba predefinido como nombre de otro objeto. Puede tratarse de
un nombre de una {#1004,constante}, una variable, una
tabla, una estructura, un proceso o una
funci¢n del programa.

Puede ser que se haya pretendido utilizar el mismo nombre dentro del
programa para identificar dos objetos diferentes, o bien {puede que se
haya utilizado un nombre predefinido para otro uso dentro del lenguaje}.
En dicho caso puede acceder al {glosario} para ver a que objeto se refiere
dicho nombre.

Debe sustituir dicho nombre por otro similar.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
END

PROCESS mi_juego() // Error: El nombre no es nuevo.
BEGIN
    //...
END
{-}

En este ejemplo se pretend¡a utilizar como nombre de un proceso
el nombre que anteriormente se hab¡a empleado para identificar el
programa principal.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.619,Esperando [=]}

Para definir una constante se debe poner un s¡mbolo {#1073,=} tras el nombre de la
constante.

El compilador ha entendido que la £ltima palabra definida era el nombre
de una nueva {#1004,constante} y, en la posici¢n que se indica, se esperaba que se mostrara
el s¡mbolo de asignaci¢n ({#1073,=}).

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    a=0;
    b=1;
    c,d; // Error: Esperando [=].
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.620,Demasiados valores para la estructura}

Se ha inicializado una estructura con m s valores de los que puede contener.

Para inicializar una estructura se debe tener en cuenta el n£mero de valores m ximo
que puede contener; este n£mero ser :

    {N§ de registros} X {N§ de campos}

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT posiciones[9]
        x, y;
    END = 10 dup (-99, 99);
BEGIN
    //...
END
{-}

En este caso la estructura {posiciones} tiene {10 registros} (desde posiciones[0]
hasta posiciones[9]) y {2 campos} (x e y); luego, el n£mero m ximo de valores que puede
contener es {20}. En el ejemplo se inicializan todos los campos {x} a{ -99} y todos
los campos {y} a {99}.

{/}Ver: {#1000,Sintaxis} - {#1012,Declaraci¢n de estructura}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.621,Nombre desconocido}

En la posici¢n indicada del programa se hace referencia a un bloque {#1016,PROCESS} o {#1408,FUNCTION}
inexistente; puede tratarse de uno de los siguientes casos:

- Se ha tecleado incorrectamente el nombre de un proceso o funci¢n;
revise el nombre original pues puede que sea en su
definici¢n donde el nombre no aparece correctamente.

- Se ha pretendido utilizar una funci¢n del lenguaje
y no se ha escrito su nombre correctamente; en este caso puede
acceder a la ayuda para buscar el nombre exacto de la funci¢n.

- Se hace referencia a un proceso o funci¢n cuyo c¢digo a£n no se ha
definido, por ello si se quiere compilar el programa se debe
definir el bloque, al menos, como sigue:

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    mi_proceso();
END

PROCESS mi_proceso()
BEGIN
END
{-}

Indicando en el nuevo bloque los par metros que recibe (en el ejemplo anterior
no recibe ning£n par metro).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.622,No se puede realizar el incremento}

En la expresi¢n indicada en el programa se utiliza el operador
{#1057, ++} (o el operador{#1061, --}) incorrectamente, con el fin de
incrementar (o decrementar) un objeto. Dicho objeto no tiene direcci¢n,
pues no es una variable, tabla o estructura, por
lo que el compilador no puede realizar un incremento (o decremento) sobre
el mismo.

Probablemente se haya pretendido incrementar o decrementar una expresi¢n constante o una que
involucre varios operandos.

A continuaci¢n, se muestra un programa con varios ejemplos de uso v lido de
los operadores{#1057, ++} y{#1061, --}, y otros tantos inv lidos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    mi_constante=0;
GLOBAL
    mi_variable=0;
    mi_tabla[10];
    STRUCT mi_estructura[10]
        variable;
    END
BEGIN
    // Ejemplos correctos
    mi_variable++;
    mi_tabla--;
    ++mi_tabla[mi_variable];
    --mi_estructura[0].variable;
    id.x++;

    // Ejemplos err¢neos
    (mi_variable*2)++;
    mi_constante--;
    ++0;
    --(mi_variable+1);
END
{-}

Las constantes como {mi_constante} no se pueden incrementar pues son simples
sin¢nimos del valor num‚rico que representan.

La sentencia {(mi_variable*2)++;} es err¢nea debido a que la
multiplicaci¢n se realiza en primer lugar y, una vez realizada, el valor
{mi_variable*2} se convierte en un resultado num‚rico que no tiene direcci¢n
y, por lo tanto, no se puede acceder a ella para incrementarlo.

En este caso, probablemente, la sentencia correcta que se deber¡a haber utilizado
habr¡a sido {mi_variable=mi_variable*2+1;}

{/}Ver: {#1000,Sintaxis} - {#1057,++} - {#1061,--}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.623,Estructura de longitud negativa}

Para definir una estructura indicando entre {#1079,corchetes} su n£mero de registros
se debe emplear un n£mero entero positivo (0, 1, 2, 3, ...), teniendo en cuenta que todas las
estructuras comienzan en el registro cero y terminan en el registro que se indique
en el ¡ndice.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT e1[9]
      x, y;
    END
    STRUCT e2[-9] // Error: Estructura de longitud negativa.
      x, y;
    END
BEGIN
    //...
END
{-}

El compilador ha detectado una estructura definida con un n£mero negativo de registros como
{e2}; en este ejemplo se debe definir la estructura como {e1} que,
en este caso, ser  una estructura de 10 registros (desde e1[0] hasta e1[9])
y dos campos (x e y).

{/}Ver: {#1000,Sintaxis} - {#1012,Declaraci¢n de estructura}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.624,Se esperaba una sentencia}

La posici¢n indicada en el programa est  dentro del contexto de un
bloque de sentencias, por lo que se esperaba que comenzara una sentencia en
la posici¢n indicada. stos son los posibles tipos de sentencias:

sentencias de asignaci¢nú
<expresi¢n>{#1035,=}<expresi¢n>;

sentencias de controlú
{#1020,IF} y {#1021,SWITCH}.

sentencias de buclesú
{#1043,FROM}, {#1022,WHILE}, {#1023,REPEAT}, {#1024,LOOP} y {#1025,FOR}.

sentencias de rupturaú
{#1026,BREAK}, {#1027,CONTINUE} y {#1028,RETURN}.

sentencias especialesú
{#1029,FRAME}, {#1030,CLONE} y {#1031,DEBUG}.

Siendo posible que en esta posici¢n apareciera una de las palabras
reservadas que pueden marcar el final de un bloque de sentencias, como son:

{#1091,END}, {#1090,ELSE} y {#1097,UNTIL}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    CASE 0: // Error: Se esperaba una sentencia.
        //...
    END
END
{-}

Este ejemplo provocar  el error, dado que la palabra reservada {#1087,CASE} no
es v lida para comenzar una sentencia; s¢lo es v lida dentro de una
sentencia {#1021,SWITCH}.

{/}Ver: {#1000,Sintaxis} - {#1017,Declaraci¢n de sentencia}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.625,Esperando el nombre de la cadena}

Para definir una cadena de texto se debe especificar el nombre de la misma
tras la palabra reservada {STRING}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING jugador[32];
    STRING mensaje;
BEGIN
    //...
END
{-}

En este ejemplo se han definido dos cadenas de texto globales. La primera
con el nombre {jugador} que puede almacenar hasta 32 car cteres y la segunda
con el nombre {mensaje} que, como no declara su longitud, podr  almacenar
hasta 256 car cteres (ya que este es el tama¤o establecido por defecto a
las cadenas de texto).

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.626,El nombre no es nuevo}

Como nombre de la cadena de texto se ha utilizado uno que ya estaba
relacionado con otro objeto anteriormente definido. Puede tratarse de un nombre,
de una constante, una variable, una tabla, una estructura, un proceso o una funci¢n
del programa.

Tambi‚n puede que se haya pretendido utilizar el mismo nombre dentro del
programa para identificar dos objetos diferentes, o bien {que se
haya utilizado un nombre predefinido para otro uso dentro del lenguaje}.
En dicho caso, se puede acceder al glosario para ver a qu‚ objeto se refiere
dicho nombre.

De todas formas, {debe sustituir dicho nombre por otro similar}.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
GLOBAL
    jugador=0;
    STRING jugador; // Error: El nombre no es nuevo.
BEGIN
  //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.627,Cadena de texto de longitud negativa}

Para definir una cadena de texto indicando entre corchetes su longitud se
debe emplear un n£mero entero positivo (0, 1, 2, 3, ...), teniendo en cuenta
que todas las cadenas comienzan en la posici¢n cero y terminan en
la posici¢n que indicada en el ¡ndice.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[9];
    STRING cadena2[-9]; // Error: Cadena de texto de longitud negativa.
BEGIN
    //...
END
{-}

El compilador ha detectado una cadena de texto definida con una longitud
negativa como {cadena2}; en este ejemplo se debe definir la cadena como
{cadena1} que, en este caso, ser  una cadena de hasta 10 car cteres (desde
cadena1[0] hasta cadena1[9]).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.628,Se esperaba un literal}

Los literales son los {textos entre comillas}. En la posici¢n indicada del
programa se esperaba un literal como valor inicial de una cadena de texto.

Las cadenas de texto se pueden inicializar como se muestra en el siguiente ejemplo.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING cadena="Texto inicial en la cadena";
BEGIN
    //...
END
{-}

No siendo obligatoria la inicializaci¢n de las cadenas de texto de un programa.
En caso de no inicializarse, la cadena contendr¡a un texto vac¡o ("") al inicio
del programa, es decir, que la siguientes dos declaraciones ser n id‚nticas:

  {STRING} cadena;ú
  {STRING} cadena{=}""{;}

En estos casos, al no declarar su longitud, ambas cadenas podr n almacenar
hasta un m ximo de 256 car cteres (ya que este es el tama¤o establecido por
defecto a las cadenas de texto).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.629,Literal demasiado largo}

Se ha inicializado una cadena de texto con un literal con m s car cteres
de los que la cadena puede contener.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[3]="ABCDE"; // Error: Literal demasiado largo
BEGIN
    //...
END
{-}

Para inicializar una cadena de texto se debe tener en cuenta que, como
m ximo, puede tener tantos car cteres como indique el n£mero que va
entre los corchetes m s 1.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[3]="ABCD";
BEGIN
    //...
END
{-}

En este caso la cadena de texto {cadena1} puede contener cuatro car cteres
(cadena1[0]=char("A"), cadena1[1]=char("B"), cadena1[2]=char("C") y
cadena1[3]=char("D")).

Otra opci¢n es {no indicar el tama¤o de la cadena de texto}, asign ndose en
este caso a la cadena de texto un tama¤o m ximo de 256 car cteres.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING cadena1="ABCDEF";
BEGIN
    //...
END
{-}

En este caso, {cadena1} contendr¡a inicialmente los seis car cteres indicados
("ABCDEF"), pero podr¡a llegar a contener hasta 256 durante la ejecuci¢n del
programa.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.630,Se esperaba una coma}

Se est  accediendo una tabla indicando menos dimensiones de las requeridas.

Es decir, que una tabla de dos dimensiones se prentende utilizar como si fuera
de s¢lo una dimension, o bien que una tabla de tres dimensiones se prentende
utilizar como si fuera de dos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    tabla1[9,9];
BEGIN
    //...
    tabla1[0]=0; // Error: Se esperaba una coma.
END
{-}

Revise la declaraci¢n anterior en el programa de dicha tabla de datos.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.631,Se esperaba una coma}

Se est  accediendo una estructura indicando menos dimensiones de las requeridas.

Es decir, que una estructura de dos dimensiones se prentende utilizar como
si fuera de s¢lo una dimensi¢n, o bien que una estructura de tres dimensiones
se prentende utilizar como si fuera de dos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT estructura1[9,9];
      n;
      //...
    END
BEGIN
    //...
    estructura1[0].n=0; // Error: Se esperaba una coma.
END
{-}

Revise la declaraci¢n anterior en el programa de dicha estructura de datos.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.632,No se puede calcular el offset del dato}

En la expresi¢n indicada en el programa se utiliza el operador {#1085,offset}
(o el s¡mbolo sin¢nimo {#1085,&}) con el fin de obtener la direcci¢n
(desplazamiento) de un {#1406,car cter}, {#1404,byte} o {#1403,word} perteneciente
a una tabla.

Esto no est  permitido, £nicamente es posible obtener la direcci¢n del inicio
de la tabla, pero no de un dato de la misma (excepto con datos de tipo {#1402,int}).

A continuaci¢n se muestra un programa con dos ejemplos del uso del operador
{#1085,offset} (o bien el s¡mbolo {&}) para tablas de tipo {#1404,byte}; uno
v lido y otro no.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    BYTE mi_tabla[99];
    offset_dato;
BEGIN
    // Ejemplo correcto
    offset_dato=offset mi_tabla;

    // Ejemplo err¢neo
    offset_dato=offset mi_tabla[1];
END
{-}

{/}

Esto es tambi‚n aplicable a {cadenas de texto} (datos de tipo {#1406,string}),
es decir, que tampoco se puede obtener la direcci¢n de un car cter de dentro
de la cadena.

Adem s, el operador {#1085,offset} no es necesario para obtener el
desplazamiento de una cadena de texto (puede ser omitido). Es
decir, que estas dos sentencias ser¡an igualmente v lidas:

  offset_cadena{=}offset mi_cadena{;}ú
  offset_cadena{=}mi_cadena{;}

{Nota:} Para operar con las cadenas de texto debe utilizar las funciones
del lenguaje que han sido dise¤adas con tal fin (v‚ase por ejemplo
{#202,strcpy()}).

{/}Ver: {#1000,Sintaxis} - {#1085,offset}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.633,Asignaci¢n a cadena incorrecta}

Con las cadenas de texto £nicamente se pueden realizar asignaciones de
tres tipos:

- Asignaciones convencionales (=), se har  una copia de la cadena.

- Suma y asignaci¢n (+=), se a¤adir  la subcadena.

- Resta y asignaci¢n (-=), se eliminar n car cteres de la cadena.

En la posici¢n se¤alada del programa se ha intentado probablemente alg£n
otro tipo de asignaci¢n operativa con una {cadena de texto}. Dicha operaci¢n
no es posible, ya que carece de sentido alguno.

{/}Ver: {#1000,Sintaxis} - {#1035,Definici¢n de expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.635,Cadena de texto demasiado larga}

Para definir una cadena de texto indicando entre corchetes su longitud se
debe emplear un n£mero entero {menor que 1048576}, teniendo en cuenta
que todas las cadenas comienzan en la posici¢n cero y terminan en
la posici¢n que indicada en el ¡ndice.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[29999999]; // Error: Cadena de texto demasiado larga.
BEGIN
    //...
END
{-}

El compilador ha detectado una cadena de texto definida con una longitud
excesiva, como {cadena1}; como m ximo se podr¡a haber declarado una cadena
de texto de 1 Megabyte, con la siguiente declaraci¢n:

  {STRING} cadena1{[}1048575{];}

Pudiendo contener {cadena1} hasta {1024*1024} car cteres, es decir, desde
cadena1[0] hasta cadena1[1048575].

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.636,Inicializaci¢n incorrecta}

El n£mero de valores indicados en la inicializaci¢n no coincide con la
declaraci¢n previa de la estructura.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT mi_estructura[9];
        STRING nombre;
        x,y;
    END = 10 dup ("AAA",0); // Error: Inicializaci¢n incorrecta.
BEGIN
    //...
END
{-}

En el ejemplo anterior se declara una estructura de tres campos, y despu‚s
se inicializa como si £nicamente tuviera dos.

Debe revisar la declaraci¢n previa, recordando siempre que una
estructura como {mi_estructura[9]} tiene {10} registros (del {0} al {9}). Por
ejemplo, una inicializaci¢n v lida para la estructura anterior ser¡a la
siguiente:

  10 {dup (}"AAA"{,} 0{,} 0{);}

Ya que inicializa {10 registros} de {3  campos}, acorde a la declaraci¢n
de {mi_estructura}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.637,Esperando [;]}

El compilador espera un {#1068,punto y coma (;)} en la posici¢n indicada en
el programa.

En el lenguaje se debe indicar con un punto y coma el final de una
declaraci¢n de un dato.

{/}Ver: {#1000,Sintaxis} - {#1068, ; }

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.638,Esperando una opci¢n de compilaci¢n}

El compilador esperaba una opci¢n de compilaci¢n en la posici¢n indicada
del programa.

Ver las {#1400,opciones de compilaci¢n} disponibles en esta versi¢n del
lenguaje.

{/}Ver: {#1000,Sintaxis} - {#1003,Cabecera de programa}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.639,Esperando [=]}

Para establecer un n£mero m ximo de procesos se debe utilizar la sentencia
{#1400,compiler_options} como se muestra en el siguiente programa:

{#9999,Ejemplo:}
COMPILER_OPTIONS _max_process = 100;

PROGRAM mi_juego;
BEGIN
    //...
END
{-}

En este caso, se ha establecido que, durante la ejecuci¢n del programa, podr 
existir {un m ximo de 100 procesos} ejecut ndose de forma simult nea.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.640,Asignaci¢n dentro de una condici¢n}

El compilador ha detectado, en la posici¢n resaltada en el programa, una
sentencia de asignaci¢n dentro de una condici¢n.

Probablemente haya intentado comparar dos valores utilizando para ello
el s¡mbolo de asignaci¢n {#1073,=}, en lugar del s¡mbolo de comparaci¢n {#1074,==}.

{/}

{Nota para nuevos usuarios:} Si desea poder {comparar} dos valores con el
s¡mbolo {=}, debe incluir la opci¢n {#1400,_simple_conditions} en el programa.
Para ello deber  incluir en la primera l¡nea (antes de {PROGRAM ...}) la
siguiente sentencia:

  {COMPILER_OPTIONS _simple_conditions;}

{/}

{Nota para usuarios de la versi¢n anterior:} En esta nueva versi¢n del lenguaje
se prohiben inicialmente las {asignaciones dentro de una condici¢n}, para facilitar
la programaci¢n a usuarios no experimentados. No obstante esto puede cambiarse con
las opciones de compilaci¢n (ver {#1400,_extended_conditions y _simple_conditions}).

{/}Ver: {#1000,Sintaxis} - {#1400,Compiler_options}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.641,La longitud no coincide con la declaraci¢n anterior}

Se ha declarado una cadena de texto o puntero {dos veces}, como par metro y como
dato privado, y en ambas declaraciones se ha especificado una longitud
diferente.

No es necesario volver a declarar este dato como privado, pudiendo
especificar su longitud en los mismos par metros del proceso.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
BEGIN
  //...
END

PROCESS mi_proceso(string mi_cadena[16])
BEGIN
  //...
END
{-}

El proceso de este ejemplo recibe un par metro en una cadena {privada} (aunque
no se indique en esta secci¢n) de hasta {17} car cteres de longitud (desde
mi_cadena[0] hasta mi_cadena[16]).

El proceso anterior podr¡a haber vuelto a declarar esta cadena en la secci¢n
{#1008,PRIVATE} (por ejemplo, para a¤adir un comentario explicativo), pero debiendo
coincidir, en este caso, la longitud con la anteriormente especificada. Es decir,
que {mi_cadena} se declarar¡a como se muestra en el siguiente ejemplo.

{#9999,Ejemplo:}
PROGRAM nombre_del_programa;
BEGIN
  //...
END

PROCESS mi_proceso(string mi_cadena[16])

PRIVATE
  string mi_cadena[16]; // Aqu¡ me pasar n un texto.

BEGIN
  //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1008,Declaraci¢n de datos privados}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.642,Esperando un nombre}

Para definir una tabla de bytes se debe especificar el nombre de la misma
tras la palabra reservada {BYTE}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    BYTE mi_byte;
    BYTE mi_tabla1[127];
    BYTE mi_tabla2[255,255];
BEGIN
    //...
END
{-}

En este ejemplo se han definido tres datos de este tipo. El primero
con el nombre {mi_byte} podr  contener un £nico valor (entre 0 y 255), el segundo
con el nombre {mi_tabla1} podr  contener hasta 128 de estos valores
(desde mi_tabla1[0] hasta mi_tabla1[127]), y el tercero, que ser  una tabla
de bytes de dos dimensiones, pudiendo contener un total de 65536 valores
(ya que este es el resultado de multiplicar 256 por 256).

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.643,Valor de BYTE fuera del rango (0...255)}

Se ha inicializado un {BYTE} con un valor demasiado grande o negativo. Este
tipo de datos £nicamente pueden contener valores dentro del rango {0} ...
{255}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    BYTE mi_valor=300; // Error: Valor de byte fuera del rango (0...255).
BEGIN
    //...
END
{-}

Si quiere asignar este valor al dato, quiz  sea conveniente no declarar un
dato de tipo {BYTE}, como se muestra en el siguiente programa.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    mi_valor=300;
BEGIN
    //...
END
{-}

Ya que de esta forma se crea un dato que podr  contener valores num‚ricos
enteros dentro del rango ({#1177,min_int} ... {#1178,max_int}).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.644,Valor de WORD fuera del rango (0...65535)}

Se ha inicializado un {WORD} con un valor demasiado grande o negativo. Este
tipo de datos £nicamente pueden contener valores dentro del rango {0} ...
{65535}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    WORD mi_valor=70000; // Error: Valor de word fuera del rango (0...65535).
BEGIN
    //...
END
{-}

Si quiere asignar este valor al dato, quiz  sea conveniente no declarar un
dato de tipo {WORD}, como se muestra en el siguiente programa.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    mi_valor=70000;
BEGIN
    //...
END
{-}

Ya que de esta forma se crea un dato que podr  contener valores num‚ricos
enteros dentro del rango ({#1177,min_int} ... {#1178,max_int}).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.645,Esperando un nombre}

Para definir una tabla de bytes se debe especificar el nombre de la misma
tras la palabra reservada {WORD}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    WORD mi_word;
    WORD mi_tabla1[127];
    WORD mi_tabla2[255,255];
BEGIN
    //...
END
{-}

En este ejemplo se han definido tres datos de este tipo. El primero
con el nombre {mi_word} podr  contener un £nico valor (entre 0 y 65535), el segundo
con el nombre {mi_tabla1} podr  contener hasta 128 de estos valores
(desde mi_tabla1[0] hasta mi_tabla1[127]), y el tercero, que ser  una tabla
de words de dos dimensiones, pudiendo contener un total de 65536 valores
(ya que este es el resultado de multiplicar 256 por 256).

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.646,No se puede especificar una tabla como par metro}

Los {#1018,par metros del proceso} se deben declarar como variables,
no como tablas o estructuras, y no se deben inicializar (ya que recibir n
su valor en cada llamada).

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    //...
END
PROCESS mi_proceso(a[9]) // Error: No se puede especificar una tabla como par metro.
BEGIN
    //...
END
{-}

El compilador interpreta que se est  tipificando el par metro {a} como
una tabla de 10 posiciones, y como no se puede pasar una tabla como
par metro, emite el error.

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.647,Sentencia IMPORT incorrecta (ver la ayuda al respecto)}

La declaraci¢n de librerias externas debe hacerse justo {tras la cabecera
del programa}, es decir, tras la declaraci¢n {PROGRAM nombre_de_programa;}.
Pudiendo hacerse varias declaraciones {#1014,IMPORT} seguidas, para declarar
el uso de m s de una librer¡a, como en el siguiente ejemplo.

{#9999,Ejemplo:}
// Cabecera del programa

PROGRAM mi_juego;

// Declaraci¢n de librerias

IMPORT "lib1.dll";
IMPORT "lib2.dll";
//...

// Y a continuaci¢n (opcionalmente) el resto de secciones.

CONST
   //...
GLOBAL
   //...
LOCAL
   //...
PRIVATE
   //...

BEGIN
    //...
END
{-}

Este programa declara el uso de las librer¡as denominadas {lib1.dll} y
{lib2.dll} (supuestos nombres de unas hipot‚ticas librer¡as de funciones
externas).

{/}

{Nota 1:} En la primera versi¢n del lenguaje de programaci¢n DIV, esta
declaraci¢n se deb¡a hacer entre las secciones {LOCAL} y {PRIVATE} del
programa.

{Nota 2:} Las librer¡as preparadas para la primera versi¢n del lenguaje {no
funcionar n correctamente} en versiones posteriores, debi‚ndose recompilar
previamente estas librer¡as con los nuevos archivos de declaraciones. Es decir,
que el c¢digo fuente de las librer¡as sigue siendo v lido, pero antes debe
compilarse nuevamente con los nuevos archivos de cabecera (ya que estos
contienen las declaraciones de los nuevos datos y estructuras existentes en
el lenguaje).

{/}Ver: {#1000,Sintaxis} - {#1014,Declaraci¢n de librer¡as}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.648,Esperando un nombre}

Para declarar un puntero se debe especificar el nombre del mismo tras la
palabra reservada {#1405,POINTER} (o el s¡mbolo {*}).

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    POINTER ptr;
    WORD POINTER mis_words[15];
    BYTE POINTER mis_bytes;
BEGIN
    //...
END
{-}

En este ejemplo se han definido tres datos de este tipo. El primero
con el nombre {ptr} es un puntero a datos enteros convencionales, y no
tiene limitaci¢n de rango en su acceso (se puede acceder a ptr[{n}], siendo
{n} cualquier valor). El segundo es un puntero a datos de tipo {WORD}
(enteros entre 0 y 65535) con una limitaci¢n de acceso a los primeros 16
valores. Y el tercero es un puntero a datos de tipo {BYTE} (enteros entre
0 y 255) y sin limitaci¢n de rango.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.649,Esperando un nombre}

Para declarar un dato entero se debe especificar el nombre del mismo tras la
palabra reservada {INT} siendo, en todo caso, prescindible dicha palabra (ya
que todos los datos son de tipo entero por defecto).

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    INT a,b;  // Declara dos datos enteros
    c,d;      // Declara otros dos datos enteros
BEGIN
    //...
END
{-}

En este ejemplo se puede ver como se declaran 4 datos de tipo entero, para
los dos primeros ({a} y {b}) se ha especificado que su tipo sera {INT} (de
"integer", entero en ingl‚s), pero no existe ninguna diferencia, a nivel de
declaraci¢n, con los dos £ltimos ({c} y {d}), ya que estos tambi‚n ser n
datos de tipo entero.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.650,Declaraci¢n incorrecta de puntero a una estructura}

El compilador esperaba, en la posici¢n indicada del programa, el nombre
de una estructura declarada anteriormente, para poder declarar un puntero
a la misma.

Para definir un puntero a una estructura de datos se debe utilizar la
siguiente sintaxis:

{STRUCT POINTER nombre_estructura nombre_puntero;}

Siendo {nombre_estructura} el nombre de una estructura de datos declarada
en una posici¢n anterior del programa, y {nombre_puntero} nombre del puntero
la estructura que se est  declarando.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1012,Declaraci¢n Estructuras}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.651,No se puede recibir una estructura como par metro}

Un proceso no puede recibir una estructura como par metro, si se quiere
acceder desde un proceso a una estructura externa, se debe recibir como
par metro un puntero a la misma.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT posiciones[9]
        x, y;
    END
BEGIN
    mi_proceso(OFFSET posiciones);
    //...
END

PROCESS mi_proceso(STRUCT POINTER posiciones pos[9]);
BEGIN
    //pos[ ... ].x = ... ;
    //...
END
{-}

En este ejemplo se podr  acceder a la estructura dentro de {mi_proceso}
utilizando el puntero {pos}, como si fuera la propia estructura {posiciones}.

{/}Ver: {#1000,Sintaxis} - {#1001,Nombres} - {#1012,Declaraci¢n Estructuras}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.652,Esperando un nombre de estructura}

La funci¢n indicada requiere como par metro, en la posici¢n indicada, el nombre
de una estructura de datos del programa.

No se debe utilizar el operador {#1085,offset}, simplemente se debe indicar
el nombre de la estructura.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT records[9]
        STRING iniciales[2];
        puntos;
    END
BEGIN
    //...
    qsort(offset records,puntos,1); // Error: Esperando un nombre.
END
{-}

En este ejemplo se utiliza la funci¢n {qsort}, que requiere el nombre de una
estructura como primer par metro. En este caso, la instrucci¢n adecuada para
ordenar la tabla {records} ser¡a la siguiente:

  qsort(records,puntos,1);

Esta instrucci¢n indicar¡a que se quiere ordenar esta estructura, en funci¢n
del campo {puntos} y en orden descendente.

{/}

{Nota 1:} Tambi‚n es probable que el nombre indicado no se refiera a una
estructura de datos, sino a otro tipo de objeto diferente (por ejemplo, que
se haya especificado el nombre de una tabla de datos).

{Nota 2:} Esta estructura de datos no puede pertenecer a su vez a otra
estructura, es decir, que no se puede especificar el nombre de una estructura
dentro de otra.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.653,Esperando un campo de estructura}

La funci¢n indicada requiere como par metro, en la posici¢n indicada, el nombre
de {un campo perteneciente a la estructura indicada anteriormente}.

No se debe utilizar el operador {#1085,offset}, simplemente se debe indicar
el nombre del campo.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    STRUCT records[9]
        STRING iniciales[2];
        puntos;
    END
BEGIN
    //...
    qsort(records,&puntos,1); // Error: Esperando un campo de estructura.
END
{-}

En este ejemplo se utiliza la funci¢n {qsort}, que requiere el nombre de un campo
de la estructura como segundo par metro. En este caso, la instrucci¢n adecuada para
ordenar la tabla {records} ser¡a la siguiente:

  qsort(records,puntos,1);

Esta instrucci¢n indicar¡a que se quiere ordenar esta estructura, en funci¢n
del campo {puntos} y en orden descendente.

{/}

{Nota:} Tambi‚n es probable que el nombre indicado no se refiera a un campo
perteneciente a dicha estructura.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Temas de inter‚s relacionados con los errores de compilaci¢n
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1000,Sintaxis de un programa}

A continuaci¢n se muestra la estructura general de un programa en el
lenguaje; pulse con el rat¢n sobre la secci¢n de inter‚s para ver la
definici¢n sint ctica correspondiente.

{#1400,<Opciones de compilaci¢n>}ú
{#1003,<Cabecera del programa>}ú
{#1014,<Declaraci¢n de librer¡as>}ú
{#1004,<Declaraci¢n de constantes>}ú
{#1006,<Declaraci¢n de datos globales>}ú
{#1007,<Declaraci¢n de datos locales>}ú
{#1008,<Declaraci¢n de datos privados>}ú
{#1015,<C¢digo principal>}ú
{#1016,<Declaraci¢n de procesos>}ú
{#1408,<Declaraci¢n de funciones>}ú

Todos los programas deben respetar la estructura anterior con una
£nica excepci¢n, y es que pueden ponerse {#1002,comentarios explicativos}
en cualquier punto del programa.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1001,Definici¢n de un nombre}

Un nombre es una secuencia de car cteres alfanum‚ricos que
se utiliza para {identificar} un objeto del programa, como puede ser
el nombre de un proceso, de una {#1004,constante} o de una
variable.

Estos nombres pueden formarse con los siguientes car cteres:

  S¡mbolos:ú
  {_ # ¦ § $  Ÿ œ  ›}ú
  D¡gitos:ú
  {0123456789}ú
  Letras:ú
  {abcdefghijklmnopqrstuvwxyz}ú
  Letras (extendido):ú
  {¤ ‡ ‘ ƒ„…†  ˆ‰Š‚ Œ‹¡ “”•¢ –—£ ˜}ú

Siempre que se respeten las siguientes reglas para construir nuevos
nombres:

- La secuencia de car cteres no debe contener car cteres que no est‚n
en la relaci¢n anterior (excepto las letras {may£sculas} correspondientes
a las min£sculas de la lista).

- Dentro de la secuencia no se pueden poner espacios en blanco, es decir,
no es v lido como nombre {nave enemiga}, pues para el compilador
se tratar¡a de dos nombres; en este caso se puede declarar el
nombre como {nave_enemiga}.

- Un nombre no puede comenzar por un d¡gito num‚rico, es decir,
{0a} no es un nombre v lido. No obstante tras el primer car cter,
pueden incluirse en el nombre todos los d¡gitos necesarios ({a0} si
es un nombre v lido).

- El nombre no debe coincidir con ninguna de las palabras reservadas
del lenguaje ni con ninguno de los objetos (constantes, variables, etc.)
predefinidos en el lenguaje. Para comprobar esto, ver la lista de palabras
reservadas y objetos predefinidos, pudi‚ndose acceder al glosario en cualquier
momento. Las palabras reservadas aparecen en may£sculas y los objetos
predefinidos en min£sculas.

- No se diferencian las letras may£sculas de las m¡nusculas ({ABc} y {abC}
son el mismo nombre para el compilador).

- No se puede utilizar un mismo nombre para dos objetos diferentes,
por ejemplo, no se puede llamar a una constante {valor} y, despu‚s, declarar
un proceso como {PROCESS valor(x, y);}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1002,Definici¢n de comentarios}

Un comentario es una nota aclaratoria sobre el programa. Los comentarios no
son necesarios para el correcto funcionamiento del programa.

Hay dos tipos de comentarios:

- De una sola l¡nea, comienzan con el s¡mbolo{ //} y terminan al final de
la l¡nea en la que se definen.

- De varias l¡neas, comienzan con el s¡mbolo{ /*} y terminan con el
s¡mbolo {*/}.

{#9999,Ejemplo:}
/*
    Esto es un ejemplo de un comentario
    de varias l¡neas, en el que se pueden
    realizar aclaraciones sobre el programa
*/

PROGRAM mi_juego; // Ejemplo de un comentario de una l¡nea.
BEGIN             // Comienza el programa principal.
    FRAME;
END               // Termina el programa principal.
{-}

Todos los textos incluidos en un comentario son ignorados por el compilador.
Se pueden poner tantos comentarios en un programa como sean necesarios y
en cualquier punto del programa.

Los comentarios que comienzan con{ /*} y terminan con{ */} (denominados de
varias l¡neas) pueden tambi‚n comenzar y terminar en la misma l¡nea.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1003,Cabecera del programa}

{PROGRAM} {#1001,<nombre>} {;}

Todos los programas deben comenzar con la palabra reservada {PROGRAM} seguida
del nombre del programa y un s¡mbolo {#1068,; (punto y coma)}. Esta cabecera
es obligatoria en todos los programas (antes de la misma £nicamente pueden
aparecer las ({#1400,opciones de compilaci¢n}).

En los nombres y las palabras reservadas no se diferencia entre
may£sculas y min£sculas, por lo que son v lidas {PROGRAM}, {program}, {Program}, ...

{#9999,Ejemplo:}
// -------------------
// Listado de mi juego
// -------------------

PROGRAM nombre_de_mi_juego;
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1004,Declaraci¢n de constantes}

{CONST}ú
    {#1001,<nombre>} {=} {#1005,<constante>} {;}ú
    ...

Esta secci¢n de los programas es opcional, pues su utilidad consiste en establecer
una serie de sin¢nimos para unos valores num‚ricos.

Por ejemplo, si en un juego se establece en uno o varios puntos del programa
el n£mero 3 como el m ximo de vidas del protagonista, cuando
se quiera modificar para aumentarlo o disminuirlo habr  que buscar y
sustituir ese n£mero en el programa. Con el consiguiente riesgo de
sustituir otros '3' que aparezcan en el programa con otros fines.

Una alternativa es declarar una constante denominada, por ejemplo,
{m ximo_vidas} como un sin¢nimo del valor num‚rico 3 y utilizar en el
programa dicha constante en lugar del n£mero; ahora, cuando se quiera
cambiar este valor por otro, simplemente habr  que hacerlo en la declaraci¢n
de la constante {m ximo_vidas}.

Esta secci¢n establece entonces una relaci¢n de nombres que van
a representar una serie de constantes num‚ricas.

Esta secci¢n debe comenzar obligatoriamente con la palabra reservada {CONST}
y, a continuaci¢n, por cada constante declarada debe aparecer su nombre
seguido del s¡mbolo {#1073,= (s¡mbolo de asignaci¢n)} y una expresi¢n constante
(valor num‚rico). Tras la declaraci¢n de cada constante debe venir el s¡mbolo
{#1068,;} (punto y coma).

{#9999,Ejemplo:}
PROGRAM mi_juego;
CONST
    m ximo_vidas=3;
BEGIN
    //...
END
{-}

Una vez que se ha asignado un valor a una constante, ‚ste no podr  ser
modificado en el programa m s adelante.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1005,Definici¢n de una constante}

Una constante es un valor o una expresi¢n num‚rica constante.

Como valores se pueden utilizar £nicamente n£meros enteros dentro del rango
({#1177,min_int} ... {#1178,max_int}).

Las expresiones n£mericas constantes son f¢rmulas matem ticas en las que
se puede utilizar:

    - {Constantes} definidas con anterioridad.ú
    - {Valores num‚ricos}.ú
    - {Operadores} aritm‚ticos o l¢gicos.ú
    - {Literales} (textos entre comillas).ú
    - La funci¢n {#1094,sizeof()}.ú

Estas expresiones ser n evaluadas cuando el programa sea compilado y ser 
el resultado de las mismas el que sea utilizado en la ejecuci¢n del programa.

Los {operadores} que se pueden utilizar en una expresi¢n constante son (entre
par‚ntesis se muestran los sin¢nimos del operador, en caso de tenerlos).

    {#1056, +}    Sumaú
    {#1060, -}    Resta (o negaci¢n de signo)ú
    {#1054, *}    Multiplicaci¢nú
    {#1065, /}    Divisi¢nú
    {#1048, MOD}  M¢dulo ({#1048,%})ú
    {#1070, <<}   Rotaci¢n a la derechaú
    {#1077, >>}   Rotaci¢n a la izquierdaú
    {#1045, NOT}  Negaci¢n binaria y l¢gica ({!})ú
    {#1051, AND}  AND binario y l¢gico ({&},{&&})ú
    {#1083, OR}   OR binario y l¢gico ({|},{||})ú
    {#1082, XOR}  OR exclusivo ({^^})ú
    {#1074, ==}   Comparaci¢nú
    {#1046, <>}   Distinto ({!=})ú
    {#1076, >}    Mayorú
    {#1075, >=}   Mayor o igual ({=>})ú
    {#1069, <}    Menorú
    {#1072, <=}   Menor o igual ({=<})ú
    {#1085, OFFSET} Direcci¢n o desplazamiento ({&})ú
    {#1053, ( )}  Par‚ntesisú

A continuaci¢n se muestran algunos ejemplos de constantes v lidas:

{ 0}ú
{ -1000}ú
{ 2+2}ú
{ "Hola!"}ú
{ 4*(2+1)}ú
 ...

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1006,Declaraci¢n de datos globales}

{GLOBAL}ú
    {#1009,<declaraci¢n de dato>} {#1068,;}ú
    ...

Esta secci¢n de los programas es opcional; es donde se declaran los
datos de  mbito global, es decir, los {datos que pueden utilizarse
desde cualquier punto del programa}.

La secci¢n debe comenzar obligatoriamente con la palabra reservada GLOBAL
seguida de una serie de {#1009,declaraciones de datos} terminadas con un
s¡mbolo {#1068,;} (punto y coma).

En general, se declaran como datos globales todos aquellos que establecen
condiciones generales del juego que afecten a varios procesos; un ejemplo
puede ser los puntos obtenidos por el jugador, que podr¡an almacenarse en la
variable global {puntuaci¢n}, de modo que cualquier proceso del juego pudiera
incrementarla cuando fuera necesario.

Una declaraci¢n de dato global definir  un £nico dato que podr  ser utilizado
por todos los procesos del programa; en cambio una declaraci¢n de dato
local definir  un dato de ese tipo y con ese nombre, para cada uno de los
procesos del programa.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    puntuaci¢n=0;
BEGIN
    //...
END
{-}

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1007,Declaraci¢n de datos locales}

{LOCAL}ú
    {#1009,<declaraci¢n de dato>} {#1068,;}ú
    ...

Esta secci¢n de los programas es opcional, ya que es donde se declaran los
datos de  mbito local, es decir, los {datos que tendr n todos los procesos
del programa}, cada uno con sus propios valores (como las variables locales
predefinidas {#1123,x} e {#1124,y} determinan las coordenadas de todos los procesos).

La secci¢n debe comenzar obligatoriamente con la palabra reservada {LOCAL}
seguida de una serie de {#1009,declaraciones de datos} terminadas con un
s¡mbolo {#1068,;} (punto y coma).

En general, se declaran como datos locales todos aquellos que se consideren
informaciones importantes de los procesos, o sea, aquellos que pueda interesar
consultar o modificar desde otros procesos.

Un ejemplo puede ser la energ¡a que le queda a un proceso (puede ser una
nave, un disparo, el protagonista, etc.); esta informaci¢n podr¡a almacenarse
en la variable local {energ¡a} de modo que cualquier proceso pudiera
acceder o modificar la energ¡a de los dem s (por ejemplo, cuando colisionara
con ellos les podr¡a quitar energ¡a).

{#9999,Ejemplo:}
PROGRAM mi_juego;
LOCAL
    energ¡a=0;
BEGIN
    //...
END
{-}

Si un dato declarado como local va a utilizarse £nicamente dentro de un
proceso, entonces se puede definir como un dato privado (dentro de la secci¢n
{#1008,PRIVATE} de dicho proceso).

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1008,Declaraci¢n de datos privados}

{PRIVATE}ú
    {#1009,<declaraci¢n de dato>} {#1068,;}ú
    ...

Estas secciones de los programas son opcionales; en ellas se pueden declarar
datos de  mbito privado, es decir, {datos que van a ser utilizados exclusivamente
dentro de un proceso}.

Dicha secci¢n se define justo antes del {#1086,BEGIN} del proceso que va a utilizar
esos datos y debe comenzar, obligatoriamente, con la palabra reservada PRIVATE
seguida de una serie de {#1009,declaraciones de datos} terminadas con un
s¡mbolo {#1068,;} (punto y coma).

El programa principal tambi‚n se considera como un proceso, pudiendo tener
su declaraci¢n de datos privados justo antes del {#1086,BEGIN} del mismo.

En general, se declaran como datos privados todos aquellos que vayan a contener
informaci¢n necesaria £nicamente para un proceso e, igualmente, que no van a poder ser accedidos
desde ning£n otro proceso.

T¡picamente se definen como datos privados aquellas variables que van a ser utilizadas
como contadores en un bucle, las variables para contener  ngulos o c¢digos identificadores
secundarios, etc.

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE
    n;
BEGIN
    FROM n=0 TO 9;
        //...
    END
    //...
END

PROCESS mi_proceso()
PRIVATE
    id2;
    angle2;
BEGIN
    id2=get_id(TYPE mi_proceso);
    IF (id2<>0)
        angle2=id2.angle;
        //...
    END
    //...
END
{-}

Si un dato declarado como privado necesita consultarse o modificarse desde
otro proceso (identificador.dato), entonces se deber  declarar dicho dato
como local (dentro de la secci¢n {#1007,LOCAL} del programa); de esta forma,
todos los procesos poseer n el dato, pudiendo acceder cada uno a su valor
o al valor que tenga dicho dato en otro proceso.

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1009,Declaraci¢n de un dato}

En una declaraci¢n de dato pueden manifestarse tres tipos diferentes de
objetos:

  {#1010,<Declaraci¢n de una variable>}ú
  {#1011,<Declaraci¢n de una tabla>}ú
  {#1012,<Declaraci¢n de una estructura>}ú

En general, una variable almacenar  un simple valor num‚rico, una tabla una
lista de valores num‚ricos, mientras que una estructura almacenar  una lista de registros de varios
campos (como una lista de fichas con diversa informaci¢n).

Todos los datos se declaran con un nombre propio que, a partir
de ese momento, ser  el medio por el cual se acceda o se modifique la informaci¢n
que dicho dato contiene.

{/}

{Nota:} En esta versi¢n del lenguaje se han incluido diferentes
{#1401,tipos de datos}, aunque contin£an siendo v lidas las declaraciones de
datos de la versi¢n anterior.

{/}

Cada dato pertenecer  a un  mbito determinado, seg£n su declaraci¢n se
haga dentro de la secci¢n {#1006,GLOBAL}, {#1007,LOCAL} o {#1008,PRIVATE}..

  {#1006,<Declaraci¢n de datos globales>}ú
  {#1007,<Declaraci¢n de datos locales>}ú
  {#1008,<Declaraci¢n de datos privados>}ú

A los datos globales se puede acceder desde cualquier punto del
programa; los locales son aquellos que tienen todos los procesos
(cada proceso tiene su propio valor en ellos) mientras que los privados son los
que pertenecen a un s¢lo proceso determinado.

{/}Ver: {#1000,Sintaxis} - {#1401,Tipos de datos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1010,Declaraci¢n de una variable}

{#1401,<tipo>} {#1001,<nombre>}

(o bien, si se quiere inicializar)

{#1401,<tipo>} {#1001,<nombre>} {#1073,=} {#1005,<constante>}

Se pueden declarar variables num‚ricas de varios tipos, en cualquiera de las
secciones de declaraci¢n {#1006,GLOBAL}, {#1007,LOCAL} o {#1008,PRIVATE}.

Para declarar una variable debe indicarse el tipo ({#1402,INT}, {#1403,WORD} o {#1404,BYTE}) seguido del
nombre para la variable y, en caso de quererse inicializar, un s¡mbolo de asignaci¢n
({#1073,=}) precediendo al valor de la variable.

{/}

{Tipos de variables:}

{#1402,INT} - Variables num‚ricas enteras entre -2147483648 y +2147483647 ({#1177,min_int} ... {#1178,max_int}).
La palabra reservada {INT} puede omitirse, ya que todos los datos ser n de este tipo por
defecto (enteros de 32 bit con signo).

{#1403,WORD} - Variables num‚ricas enteras entre 0 y 65535 (enteros de 16 bit sin signo).

{#1404,BYTE} - Variables num‚ricas enteras entre 0 y 255 (enteros de 8 bit sin signo).

{#1405,POINTER} - Punteros a diferentes tipos de datos.

{Nota:} Las cadenas de texto (datos de tipo {#1406,STRING} se consideran tablas
de datos (de car cteres), en lugar de simples variables (ver la {#1011,declaraci¢n de una tabla}).

{/}

{Ejemplos de declaraci¢n de variables:}

{Mi_dato=-1;} -  Variable tipo INT, inicializada a -1.

{INT a=0,b;} - Dos variables tipo INT, inicializadas a 0.

{WORD conta=10;} - Variable tipo WORD, inicializada a 10.

{BYTE b1,b2=32;} - Variables tipo BYTE, b1 a 0 y b2 a 32.

{/}

{Consideraciones finales:}

{1.} Si no se indica el tipo de la variable, esta ser  INT.ú
{2.} Si no se indica el valor de la variable, esta ser  inicializada a 0.ú
{3.} Se debe poner el s¡mbolo punto y coma tras cada declaraci¢n.ú
{4.} Se pueden separar varios nombres de dato (del mismo tipo) por comas.ú

{Nota:} Siguen siendo v lidas las declaraciones de datos seg£n se hacian en la primera
versi¢n del lenguaje (sin indicar nunca el tipo). En este caso, todas las variables ser n
de tipo {#1402,INT}.

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1011,Declaraci¢n de una tabla}

{#1401,<tipo>} {#1001,<nombre>} {#1079,[} {#1005,<constante>} {#1079,]}

(o bien, si se quiere inicializar la tabla)

{#1401,<tipo>} {#1001,<nombre>} {#1079,[} {#1005,<constante>} {#1079,]} {#1073,=} {#1013,<lista de constantes>}

(o bien, si se inicializar sin definir su longitud)

{#1401,<tipo>} {#1001,<nombre>} {#1079,[} {#1079,]} {#1073,=} {#1013,<lista de constantes>}

Tambi‚n se pueden declarar tablas de varios tipos y en cualquier secci¢n ({#1006,GLOBAL}, {#1007,LOCAL} o {#1008,PRIVATE}).
Para declarar una tabla debe indicarse el tipo ({#1402,INT}, {#1403,WORD}, {#1404,BYTE} o {#1406,STRING}) el nombre,
la longitud entre corchetes ((s¡mbolos {#1079,[} {#1079,]})) y, en caso de quererse inicializar, un s¡mbolo de
asignaci¢n ({#1073,=}) precediendo a la {#1013,lista de constantes}.

{/}

{Nota:} La longitud de la tabla se expresa como el valor m ximo de su ¡ndice, es decir,
todas las tablas van de la {posici¢n 0} a la {posici¢n indicada entre los corchetes}. Por
ejemplo, una tabla declarada como {mi_tabla[9]}, ser  una tabla de {longitud 10} (de 10
posiciones, desde mi_tabla[0] hasta mi_tabla[9]).

{/}

{Varios ejemplos de declaraci¢n de tablas:}

{Mitabla[3];} - Tabla INT de 4 elementos (de Mitabla[0] a Mitabla[3]).

{INT tab[]=1,2,3,4,5;} - Tabla INT de 5 elementos (de tab[0] a tab[4]).

{WORD tword[1];} - Tabla WORD de 2 elementos.

{BYTE tbyte[3]=11,22;} - Tabla BYTE de 4 elementos (inicializada a 11,22,0,0).

{STRING p;} - Cadena de texto de hasta 256 caracteres (inicializada a "").

{STRING q[32]= "hola";} - Cadena de texto de hasta 33 caracteres (inicializada a "hola").

{/}

{Consideraciones sobre las tablas:}

{1.} Si no se indica el tipo de la tabla, esta ser  de tipo {#1402,INT}.ú
{2.} Si se inicializa la tabla (con una {#1013,lista de constantes}), puede omitirse la longitud entre corchetes.ú
{3.} Se debe poner un punto y coma tras cada declaraci¢n.ú
{4.} Si no se define la longitud de la tablas tipo {#1406,STRING}, estas ser n de {256 elementos}
(del {[0]} al {[255]}).ú
{5.} Si no se define la lista de constantes, los elementos estar n {inicializados a 0}.ú

Se permite acceder al {elemento 0} simplemente con el nombre de la tabla, como si
fuera una variable; es decir, para el compilador {mi_tabla[0]} ser  lo mismo que
{mi_tabla}.

{Nota:} No ser  posible obtener el {#1085,OFFSET} de un elemento de una tabla {#1404,BYTE}, {#1403,WORD} o
{#1406,STRING} (como {OFFSET tbyte[1]}), para acceder a este elemento externamente se deber 
utilizar, en todo caso, los datos de tipo {#1405,POINTER}.

{/}

{Las tablas multidimensionales.}

Se pueden declarar tablas {#1402,INT}, {#1403,WORD} o {#1404,BYTE} de {1, 2 o 3 dimensiones}. Tanto la
declaraci¢n de estas como el acceso a las mismas se debe hacer {separando las
dimensiones con comas}. Por ejemplo, la siguiente declaraci¢n:

 {BYTE tabla[255,255];}

Definir¡a tabla de tipo {#1404,BYTE} (para todos sus elementos) de {2 dimensiones}, con un
total de 65536 elementos (256*256).

{Nota:} Las tablas de tipo {#1403,WORD} y {#1404,BYTE} pueden significar un importante ahorro de memoria,
respecto a las tablas de tipo {#1402,INT} (ocupan 2 y 4 veces menos, respectivamente). Pero
{ser n m s r pidas las operaciones con datos de tipo} {#1402,INT}.

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1012,Declaraci¢n de una estructura}

{STRUCT} {#1001,<nombre>} {#1079,[} {#1005,<constante>} {#1079,]}ú
    {#1009,<declaraci¢n de dato>} {#1068,;}ú
    ...ú
{#1091,END}

(o bien, si se inicializa la estructura)

{STRUCT} {#1001,<nombre>} {#1079,[} {#1005,<constante>} {#1079,]}ú
    {#1009,<declaraci¢n de dato>} {#1068,;}ú
    ...ú
{#1091,END} {#1073,=} {#1013,<lista de constantes>}

Para declarar una estructura dentro de una secci¢n {#1006,GLOBAL},
{#1007,LOCAL} o {#1008,PRIVATE} se debe poner la palabra reservada {STRUCT}
precediendo a su nombre; tras ‚ste, y entre corchetes, (s¡mbolos {#1079,[ ]})
se deber  indicar el {n£mero de registros} de la estructura.

Tras la cabecera se declarar n todos los datos pertenecientes a la estructura, que
conformar n los campos de la misma. Y, por £ltimo, para finalizar la declaraci¢n debe
aparecer la palabra reservada {END}.

A continuaci¢n se muestra un ejemplo de estructura:

{STRUCT enemigo[9]}ú
{    INT energia;}ú
{    WORD x_inicial,y_inicial;}ú
{    WORD x_final,y_final;}ú
{    STRING nombre[15];}ú
{END}ú

Al igual que con las tablas, el {n£mero de registros} se expresa como el {n£mero
de registro m ximo} de la estructura, es decir, todas las estructuras tienen desde el
registro 0 hasta el indicado entre los corchetes (por ejemplo, la declaraci¢n
anterior definie una estructura de {10 registros}).

Se permite acceder al {resgistro 0} de la estructura simplemente con el nombre de la
estructura, es decir, que para el compilador {enemigo[0].y_final} ser  lo mismo que
{enemigo.y_final}.

{Nota:} Cada campo de la estructura puede ser una variable o tabla (de cualquier tipo,
ver los {#1401,tipos de datos}) u otra estructura completa, con sus diferentes registros
y campos.

{/}

{Inicializaci¢n de la estructura.}

Si se quiere inicializar la estructura (fijar los valores iniciales de sus campos en los
diferentes registros), se deber  poner el s¡mbolo {#1073,=} (asignaci¢n) tras la palabra
reservada {END} seguida de una lista de valores.

Si no se inicializa la estructura, todos los campos ser n puestos a 0 por
defecto. Por ejemplo, si se hace la siguiente declaraci¢n:

{STRUCT a[2]}ú
{    b;}ú
{    c[1];}ú
{END = 1,2,3,4,5,6,7,8,9;}ú

Primero se debe tener en cuenta que la estructura {a[]} tiene {3 registros} (desde {a[0]}
hasta {a[2]}) y en cada registro {3 campos} (b,c[0] y c[1]), luego la anterior declaraci¢n
inicializar  la estructura de la siguiente forma:

  {a[0].b=1;}ú
  {a[0].c[0]=2;}ú
  {a[0].c[1]=3;}ú
  {a[1].b=4;}ú
  {a[1].c[0]=5;}ú
 { ...}ú

{/}

{Inicializaci¢n global de los campos.}

Si se quiere que todos los registros de la estructura tengan inicialmente los mismos
valores para cada campo, se puede inicializar la estructura globalmente.

{STRUCT a[2]}ú
{    b=1;}ú
{    c[1]=2,3;}ú
{END}ú

En el ejemplo anterior, todos los registros de la estructura tendr¡an inicializado el
campo {b} a {1}, {c[0]} a {2} y {c[1]} a {3}.

{/}

{Nota:} Ver la {#1407,alineaci¢n de datos en memoria}, donde se muestra la ocupaci¢n
de memoria de los diferentes tipos de datos.

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1013,Definici¢n de una lista de constantes}

Una constante es un valor o una expresi¢n num‚rica constante
(ver {#1005,<definici¢n de constante>}).

Las listas de constantes son b sicamente una serie de constantes
separadas por {#1059,comas (,)} y se utilizan para inicializar los valores
de tablas o estructuras.

Un ejemplo de una lista de constantes podr¡a ser el siguiente:

1, 2, 3, 4, 5;

Pero, adem s de esta forma b sica de definici¢n, se permite el
uso del operador {#1089,DUP} para repetir un n£mero determinado de
veces una serie de constantes. Por ejemplo la siguiente lista:

0, 100 DUP (1, 2, 3), 0;

Es una lista de 302 constantes (0, 1, 2, 3, 1, 2, 3, ..., 1, 2, 3, 0), es decir,
que el operador {#1089,DUP} (de duplicar) permite repetir la secuencia que
aparece tras ‚l, entre par‚ntesis, el n£mero de veces indicadas.

Es posible anidar operaciones {#1089,DUP}, por ejemplo la lista siguiente:

2 {DUP} (88, 3 DUP (0, 1), 99);

equivaldr¡a a:

88, 0, 1, 0, 1, 0, 1, 99, 88, 0, 1, 0, 1, 0, 1, 99;

Adem s, se permite la omisi¢n del operador {#1089,DUP}, esto es, que
{2 DUP (0, 1)} equivale a {2(0, 1)}.

El operador DUP es £til, sobre todo, para la inicializaci¢n de
estructuras; si, por ejemplo, se quiere inicializar la siguiente
estructura de 100 registros:

{STRUCT a[99]}ú
    {b;}ú
    {c[9];}ú
    {d[9];}ú
{END}

Con los campos {b} incializados a {0}, los campos {c[9]} a {1} y los
campos {d[9]} a {2}, se utilizar¡a la siguiente lista de inicializaci¢n:

100 {#1089,DUP} (0, 10 DUP(1), 10 DUP(2));

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1014,Declaraci¢n de librer¡as}

{IMPORT} {<nombre de archivo>}

La creaci¢n de librer¡as de funciones para el lenguaje es un tema {muy avanzado},
s¢lo apto para programadores con amplia experiencia en el lenguaje {C} y/o {Ensamblador}.

Las librer¡as deben distribuirse con dos archivos: uno, con extensi¢n {DLL} con
la librer¡a en s¡ y, otro, con el mismo nombre pero con extensi¢n {TXT} que
debe ser un archivo de texto, con la explicaci¢n del prop¢sito
y funcionamiento de la librer¡a; en el mismo deben venir explicadas todas
las funciones proporcionadas y el proceso de instalaci¢n y utilizaci¢n de la
librer¡a.

Desde el lenguaje se deben importar las librer¡as poniendo la palabra reservada
{IMPORT} (tras la cabecera del programa) seguida de la ruta de acceso al
archivo {DLL}. Si el archivo con extensi¢n {DLL} se ha copiado al
directorio de {DIV Games Studio} entonces no es necesario especificar la ruta
de la librer¡a.

{#9999,Ejemplo:}
PROGRAM mi_juego;

IMPORT "c:\tmp\3dtrans.dll";

CONST
  //...
GLOBAL
  //...
LOCAL
  //...
PRIVATE
  //...

BEGIN
    //...
END
{-}

Desde el momento en que las librer¡as de funciones pueden ser desarrolladas
de forma libre, {no se garantiza el correcto funcionamiento de DIV Games
Studio cuando se utilicen librer¡as DLL externas}. Puede ser habitual el
funcionamiento incorrecto del {trazador de programas} cuando en un juego se
cargue una DLL que modifique partes vitales de la librer¡a de funciones o
del gestor de procesos de DIV Games Studio.

{/}

{Nota 1:} En la primera versi¢n del lenguaje de programaci¢n DIV, esta
declaraci¢n se deb¡a hacer entre las secciones {LOCAL} y {PRIVATE} del
programa.

{Nota 2:} Las librer¡as preparadas para la primera versi¢n del lenguaje {no
funcionar n correctamente} en versiones posteriores, debi‚ndose recompilar
previamente estas librer¡as con los nuevos archivos de declaraciones. Es decir,
que el c¢digo fuente de las librer¡as sigue siendo v lido, pero antes debe
compilarse nuevamente con los nuevos archivos de cabecera (ya que estos
contienen las declaraciones de los nuevos datos y estructuras existentes en
el lenguaje).

{Nota 3:} Si usted es un programador experto en C y Ensamblador, puede obtener
m s informaci¢n sobre la creaci¢n de nuevas librer¡as en el archivo
DLL\SOURCE\LEEME.TXT de DIV.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1015,C¢digo principal}

{#1086,BEGIN}ú
    {#1017,<sentencia>} {;}ú
    ...ú
{#1091,END}

El c¢digo principal de un programa comienza con la palabra reservada
{#1086,BEGIN}, tras la cual puede aparecer cualquier n£mero de sentencias,
y finaliza con la palabra reservada {#1091,END}.

Este c¢digo controla el proceso principal del programa, que es el encargado
de inicializar el programa, controlar los bucles de men£ y de juego, y
finalizar el programa.

{#9999,Ejemplo:}
PROGRAM mi_juego;

GLOBAL
    opci¢n;             // Opci¢n elegida en el men£.

BEGIN                   // Inicio del c¢digo principal.

    set_mode(m640x480); // Inicializaci¢n.
    set_fps(24, 4);
    // ...              // Carga ficheros, sonidos, etc.

    REPEAT              // Inicio bucle principal.

        opcion=0;       // Bucle de control del men£ de opciones.
        //...           // Inicializa el men£ de opciones.
        REPEAT
            // ...
            IF (key(_enter)) opcion=1; END  // Se elige jugar.
            IF (key(_esc)) opcion=2; END    // Se elige finalizar.
            FRAME;
        UNTIL (opcion>0);

        IF (opcion==1)  // Si se ha elegido la opcion de jugar.

            // Inicializa regiones, scroll, etc.
            // Crea los procesos de juego.
            // Bucle de control del juego, espera a que finalice.

        END

    UNTIL (opcion==2);  // Final del bucle principal.

    let_me_alone();     // Finaliza todos los procesos.

END                     // Final del c¢digo pricipal.

// ...                  // Declaraci¢n de los procesos del programa.
{-}

Que finalice la ejecuci¢n del c¢digo principal no implica que finalice la
ejecuci¢n del programa, pues ‚sta continuar  si quedan procesos vivos; si se
quiere forzar la terminaci¢n del programa cuando finalice este c¢digo, se
puede utilizar, por ejemplo, la funci¢n {#129,let_me_alone()} justo antes del
{#1091,END} que marca el final del c¢digo principal, para eliminar al resto
de procesos que puedan quedar vivos.

Tambi‚n se puede finalizar en cualquier punto del programa su
ejecuci¢n mediante la funci¢n {#109,exit()} que autom ticamente eliminar 
todos los procesos.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1016,Los bloques PROCESS}

Existen dos tipos de bloques de c¢digo (adem s del {#1015,c¢digo principal}):
los bloques {PROCESS} (que se detallan a continuaci¢n), y los bloques {#1408,FUNCTION}.

{PROCESS} {#1001,<nombre>} {(} {#1018,<par metros>} {)}ú
{#1008,<Declaraci¢n de datos privados>}ú
{#1086,BEGIN}ú
    {#1017,<sentencia>} {;}ú
    ...ú
{#1091,END}

Un proceso debe comenzar con la palabra reservada {PROCESS} seguida
de su nombre y sus {#1018,par metros} de llamada entre
par‚ntesis. Los par metros son una lista de datos en los que el
proceso va a recibir diferentes valores. Los par‚ntesis son
obligatorios incluso cuando el proceso no tenga par metros.

Tras esta cabecera puede venir, de forma opcional, una secci¢n {#1008,PRIVATE}
donde se declaren datos que va a utilizar exclusivamente el proceso.

Y, por £ltimo, se especificar  el c¢digo para el proceso, que es una
secuencia de sentencias entre las palabras reservadas {#1086,BEGIN} y
{#1091,END}.

Un proceso se corresponde, normalmente, con un tipo de objeto del
juego, como puede ser una nave, una explosion, un disparo, etc.,
y dentro del c¢digo del proceso se suele implementar un bucle
dentro del cual se fijar n todos los valores necesarios de
visualizaci¢n de dicho objeto (gr fico, coordenadas, etc.) y
despu‚s, mediante la sentencia {#1029,FRAME}, se dar  la orden para
visualizar el objeto con los atributos establecidos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE
    id2;
BEGIN
    id2=mi_proceso(160, 100)
    // ...
END

PROCESS mi_proceso(x, y)
PRIVATE
    n;
BEGIN
    graph=1;
    FROM n=0 to 99;
        x=x+2;
        y=y+1;
        FRAME;
    END
END
{-}

Como se puede observar en este ejemplo, cuando se llama a un proceso
‚ste devuelve su {#1039,c¢digo identificador} (que en el ejemplo se guarda en la
variable {#1008,PRIVATE} del programa principal {id2}); si se quiere
implementar un proceso al estilo de las funciones de otros lenguajes,
que devuelva un resultado num‚rico, entonces se debe utilizar la
sentencia {#1028,RETURN(}valor{)} y no utilizar la sentencia {#1029,FRAME}
dentro del proceso, pues ‚sta retorna al proceso padre (llamante),
devolviendo el {#1039,c¢digo identificador} del proceso como valor de retorno.

{/}Ver: {#1000,Sintaxis} - {#1408,Los bloques FUNCTION}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1017,Relaci¢n de sentencias}

Una sentencia es una orden a ejecutar por el ordenador dentro de un
programa. Estos son los posibles tipos de sentencias:

Sentencias de asignaci¢nú
    {#1019,=}ú

Sentencias de controlú
    {#1020,IF}ú
    {#1021,SWITCH}ú

Sentencias de buclesú
    {#1024,LOOP}ú
    {#1043,FROM}ú
    {#1023,REPEAT}ú
    {#1022,WHILE}ú
    {#1025,FOR}ú

Sentencias de rupturaú
    {#1026,BREAK}ú
    {#1027,CONTINUE}ú
    {#1028,RETURN}ú

Sentencias especialesú
    {#1029,FRAME}ú
    {#1030,CLONE}ú
    {#1031,DEBUG}ú

Sentencias de llamadaú
    {#1033,Llamada a un proceso}ú

Las sentencias siempre aparecen como un grupo de sentencias, desde
ninguna (que no tiene sentido) hasta tantas como sean necesarias.

Todas las sentencias se ejecutar n secuencialmente (la primera,
la segunda, la tercera, ...) salvo por las excepciones que definen
las sentencias que pueden controlar el flujo del programa (las
sentencias de control, de bucles y de ruptura).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1018,Par metros de un proceso}

Los par metros de un proceso son, b sicamente, una lista de datos en los cuales
el proceso recibir  distinta informaci¢n cada vez que sea invocado
(llamado o utilizado) desde otro proceso.

Los procesos pueden recibir par metros en los siguientes tipos de datos:

- Un dato local predefinido (como {#1123,x}, {#1128,size}, {#1127,flags}, ...).

- Un dato local definido dentro de la secci¢n {#1007,LOCAL}.

- Un dato global definido dentro de la secci¢n {#1006,GLOBAL}.

- Un dato privado del proceso declarado dentro de la secci¢n {#1008,PRIVATE}
del propio proceso.

- Un dato privado que {no est‚ declarado} dentro de la secci¢n {#1008,PRIVATE}.

Entendi‚ndose, en todos estos casos, que un dato puede referirse a una variable,
a una posici¢n concreta de una tabla o a un elemento
dentro de una estructura.

Para ejemplificar los diferentes tipos de par metros se muestra,
a continuaci¢n, un programa con un proceso que recibe cinco par metros
diferentes de los tipos indicados en la lista anterior, respectivamente.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
    puntos=0;
LOCAL
    energia=0;
BEGIN
    mi_proceso(1, 2, 3, 4, 5);
    // ...
END

PROCESS mi_proceso(x, energ¡a, puntos, n, m)
PRIVATE
    n;
BEGIN
    // ...
END
{-}

El proceso {mi_proceso} recibe cinco par metros en cinco variables:
local predefinida, local, global, {#1008,private} declarada y {#1008,private} sin
declarar.

Recibir en un dato global un par metro (como la variable {#1006,GLOBAL}
{puntos}) equivale a realizar la asignaci¢n ({puntos=3;}) y, despu‚s,
llamar al proceso.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1019,Sentencia de asignaci¢n}

Las sentencias de asignaci¢n sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<Referencia a un dato>} {#1073,=} {#1035,<expresi¢n>} {#1068,;}

Se debe indicar el dato en el cual se va a guardar el resultado
de la expresi¢n, seguido del s¡mbolo {#1073,=} (s¡mbolo de la {asignaci¢n})
y la expresi¢n num‚rica o l¢gica a evaluar cuando se ejecute la
sentencia. Tras esta sentencia se debe poner siempre el
s¡mbolo{#1068, ;(punto y coma)}.

En una sentencia de asignaci¢n s¢lo est  permitido asignar valores a objetos
tales como variables (de cualquier tipo), a una {#1011,posici¢n de una tabla},
o a un {#1012,elemento de una estructura}.

No es posible asignar un valor a una {#1004,constante}, a una funci¢n
o a un proceso, o, en general, a cualquier {#1035,expresi¢n num‚rica o l¢gica}.

Se muestra a continuaci¢n un programa con varias asignaciones.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x=x+1;
    angle=(angle*3)/2-pi/2;
    size=(x+y)/2;
    z=abs(x-y)*3-pow(x, 2);
    // ...
END
{-}

sta es la forma b sica de las asignaciones, si bien existen otros s¡mbolos de asignaci¢n
que, en lugar de asignar un nuevo valor al dato referido, modifican su valor.
stos son los s¡mbolos de {asignaciones operativas}:

{#1058, +=} Suma al dato el resultado de la expresi¢nú
        {x=2; x+=2;} -> (x==4)

{#1062, -=} Resta al dato el resultado de la expresi¢nú
        {x=4; x-=2;} -> (x==2)

{#1055, *=} Multiplica el dato por el resultado de la expresi¢nú
        {x=2; x*=3;} -> (x==6)

{#1066, /=} Divide el dato por el resultado de la expresi¢nú
        {x=8; x/=2;} -> (x==4)

{#1049, %=} Pone en el dato el resto de dividir al mismo entre el resultado de la
expresi¢nú
        {x=3; x%=2;} -> (x==1)

{#1052, &=} Realiza un AND (binario y/o l¢gico) entre el dato y el resultado de la
expresi¢n y lo asigna como nuevo valor del datoú
        {x=5; x&=6;} -> (x==4)

{#1084, |=} Realiza un OR (binario y/o l¢gico) entre el dato y el resultado de la
expresi¢n y lo asigna como nuevo valor del datoú
        {x=5; x|=6;} -> (x==7)

{#1081, ^=} Realiza un OR exclusivo (XOR binario y/o l¢gico) entre el dato y el
resultado de la expresi¢n y lo asigna como nuevo valor del datoú
        {x=5; x^=3;} -> (x==3)

{#1078, >>=} Rota a la derecha el dato tantas veces como indique el resultado de la
expresi¢n (cada rotaci¢n a la derecha equivale a dividir entre 2 el dato)ú
        {x=8; x>>=2;} -> (x==2)

{#1071, <<=} Rota a la izquierda el dato tantas veces como indique el resultado de la
expresi¢n (cada rotaci¢n a la izquierda equivale a multiplicar por 2 el dato)ú
        {x=2; x<<=2;} -> (x==8)

Tambi‚n se admiten dentro de la categor¡a de sentencias de asignaci¢n los
{incrementos} y {decrementos} de un dato. Por ejemplo, si quisieramos sumarle 1
a la variable local {x} podr¡amos hacerlo con la sentencia {x=x+1;}, con
la sentencia {x+=1;} o bien con el operador de incremento: {x++;} o{ ++x;}.

Es decir, se aceptan como sentencias de asignaci¢n {#1057,incrementos ( ++ )} o
{#1061,decrementos ( -- )} de un dato.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1020,Sentencia IF}

{IF} {#1053,(} {#1037,<condici¢n>} {#1053,)}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

(o bien)

{IF} {#1053,(} {#1037,<condici¢n>} {#1053,)}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1090,ELSE}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

La sentencia {IF} sirve para ejecutar un bloque de sentencias opcionalmente,
cuando se cumpla una condici¢n. En la segunda variante que aparece arriba,
se ejecutar  adem s otro bloque de sentencias (dentro de la secci¢n
{#1090,ELSE}) cuando la condici¢n {no} se cumpla.

Se muestra, a continuaci¢n, un programa con varias sentencias {IF}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN

    IF (key(_esc))
        exit("Adios!", 0);
    END

    IF (x>100 AND x<220)
        y=y+4;
    ELSE
        y=y-8;
    END

    IF (size>0)
        size=size-1;
    END

    IF (timer[5]>1000)
        z=1;
    ELSE
        z=-1;
    END

    // ...
END
{-}

Es posible anidar sentencias {IF} sin ning£n l¡mite, es decir, se pueden poner
m s sentencias {IF} dentro de la parte que se ejecuta cuando se cumple la
condici¢n (parte {IF}) o dentro de la que se ejecuta cuando la condici¢n no
se cumple (parte {#1090,ELSE}).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1021,Sentencia SWITCH}

{SWITCH} {#1053,(} {#1035,<expresi¢n>} {#1053,)}ú
    {#1087,CASE} {<rango de valores>} {#1067,:}ú
        {#1017,<sentencia>} {#1068,;}ú
        ...ú
    {#1091,END}ú
    ...ú
    {#1088,DEFAULT} {#1067,:}ú
        {#1017,<sentencia>} {#1068,;}ú
        ...ú
    {#1091,END}ú
{#1091,END}

Una sentencia {SWITCH} consta de una serie de secciones {#1087,CASE} y,
opcionalmente, una secci¢n {#1088,DEFAULT}.

Cuando se ejecuta una sentencia {SWITCH}, primero se eval£a la expresi¢n y
despu‚s, si el resultado est  dentro del rango de valores contemplados en la
primera secci¢n {CASE}, se ejecutar n las sentencias de la misma y se dar 
por finalizada la sentencia. En caso de no estar el resultado de la expresi¢n
en el primer {#1087,CASE} se pasar  a comprobarlo con el segundo {#1087,CASE}, el tercero,
etc. Y, por £ltimo, si existe una secci¢n {#1088,DEFAULT} y el resultado de la
expresi¢n no ha coincidido con ninguna de las secciones {#1087,CASE},
entonces se ejecutar n las sentencias de la secci¢n {#1088,DEFAULT}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    SWITCH (x)
        CASE 1:
            x=-1;
        END
        CASE 2:
            x=-2;
        END
        CASE 3:
            x=-3;
        END
        CASE 99:
            x=-99;
        END
        DEFAULT:
            x=0;
        END
    END
END
{-}

La sentencia {SWITCH} de este programa cambiar  de signo la variable {x} si
‚sta vale {1}, {2}, {3} o {99}; en caso contrario la pondr  a {0}.

{Rango de valores de una secci¢n case}{/}

En una secci¢n case se puede especificar un valor, un rango de valores
(m¡nimo {#1064,..} m ximo), o una lista de valores y/o rangos separados por {#1059,comas (,)}.
Por ejemplo, la sentencia anterior se podr¡a haber expresado como:

  {SWITCH (x)}ú
      {CASE 1..3, 99:}ú
          {x=-x;}ú
      {END}ú
      {DEFAULT:}ú
          {x=0;}ú
      {END}ú
  {END}ú

Una vez ejecutada una de las secciones {#1087,CASE} de una sentencia {SWITCH}
{ya no se ejecutar n m s secciones}, aunque ‚stas especifiquen tambi‚n el
resultado de la expresi¢n, por ejemplo, en la siguiente sentencia:

  {SWITCH (2+2)}ú
      {CASE 3..5:}ú
          {x=x+1;}ú
      {END}ú
      {CASE 2, 4, 6:}ú
          {y=y-1;}ú
      {END}ú
  {END}

Se ejecutar  la secci¢n {x=x+1;} y despu‚s se finalizar  la sentencia, no
ejecut ndose la secci¢n {y=y-1;} pues, aunque el resultado de la expresi¢n
evaluada ({4}) est  contemplado en ella, tambi‚n lo est  en la secci¢n anterior,
(ya que 4 est  dentro del rango 3..5).

No es necesario ordenar las secciones {#1087,CASE} seg£n sus valores (de menor
a mayor, o de mayor a menor), pero s¡ es imprescindible que la secci¢n
{#1088,DEFAULT} (en caso de haberla) sea la £ltima secci¢n. No puede haber
m s que una secci¢n {#1088,DEFAULT}.

Es posible anidar sentencias {SWITCH} sin ning£n l¡mite, es decir, se pueden
poner nuevas sentencias {SWITCH} dentro de una secci¢n {#1087,CASE} (y
cualquier otro tipo de sentencia).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1022,Sentencia WHILE}

{WHILE} {#1053,(} {#1037,<condici¢n>} {#1053,)}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}ú

La sentencia {WHILE} (mientras) es una sentencia que implementa un {bucle}, es
decir, que es capaz de {repetir un grupo de sentencias un n£mero determinado de
veces}.

Para implementar este bucle se debe especificar entre par‚ntesis la
condici¢n que se debe cumplir para que se ejecute el grupo de sentencias a
continuaci¢n de la palabra reservada {WHILE}. Tras especificar esta condici¢n,
se pondr n todas las sentencias que se necesita que se repitan y, finalmente,
se marcar  el final del bucle con la palabra reservada {#1091,END} (No
importa que dentro del bucle aparezcan m s palabras {#1091,END} si ‚stas
forman parte de sentencias interiores a dicho bucle).

Cuando se ejecute una sentencia {WHILE} se realizar  la comprobaci¢n que
se especifica y, si ‚sta resulta cierta, se ejecutar n las sentencias
interiores; en caso contrario, se continuar  el programa a partir
del {#1091,END} que marca el final del {WHILE}.

Si se han ejecutado las sentencias interiores (lo que se denomina realizar
una {iteraci¢n} del bucle), se volver  a comprobar la condici¢n y, si ‚sta
vuelve a ser cierta, se realizar  otra {iteraci¢n} (se volver n a ejecutar
las sentencias interiores). Este proceso se repetir  hasta que, al comprobarse
la condici¢n del {WHILE}, ‚sta resulte falsa.

Si seg£n se ejecuta una sentencia {WHILE} la condici¢n resulta falsa directamente,
entonces no se ejecutar n las sentencias interiores ninguna vez.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x=0;
    WHILE (x<320)
        x=x+10;
        FRAME;
    END
END
{-}

En este ejemplo se pondr  la variable local {x} (coordenada x del proceso) a
cero y despu‚s, mientras x sea menor que 320, se le sumar n 10 a {x} y se
dar  un {#1029,FRAME}.

Una sentencia {#1026,BREAK} dentro de un bucle {WHILE} lo finalizar  de forma
inmediata, continuando el programa por la sentencia siguiente a dicho bucle.

Una sentencia {#1027,CONTINUE} dentro de un bucle {WHILE} forzar  al programa a
comprobar la condici¢n inicial inmediatamente y, si ‚sta es cierta,
volver a ejecutar las sentencias interiores desde el principio (tras el {WHILE}).
Si la condici¢n resulta falsa, la sentencia {#1027,CONTINUE} finalizar  el bucle.

Las sentencias interiores a un bucle {WHILE} pueden ser tantas como se
quieran y de cualquier tipo, incluyendo, por supuesto, nuevos bucles {WHILE}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1023, Sentencia REPEAT}

{REPEAT}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1097,UNTIL} {#1053,(} {#1037,<condici¢n>} {#1053,)}

La sentencia {REPEAT} (REPEAT ... UNTIL( ... )) es una sentencia que implementa
un {bucle}, es decir, que es capaz de {repetir un grupo de sentencias un n£mero
determinado de veces}.

Para implementar este bucle se debe comenzar con la palabra reservada {REPEAT},
seguida de las sentencias que se quieren repetir una o m s veces y el final
de la sentencia se determinar  poniendo la palabra reservada {#1097,UNTIL}
seguida de la condici¢n que se debe cumplir para que {se de por finalizada
la sentencia}.

Cuando se ejecute una sentencia {REPEAT} se ejecutar n primero las sentencias
interiores (las que est n entre el {REPEAT} y el {#1097,UNTIL}) y, tras hacerlo,
se comprobar  la condici¢n especificada en el {#1097,UNTIL} y si ‚sta contin£a
siendo falsa, se volver n a ejecutar las sentencias interiores. El proceso se
repetir  hasta que la condici¢n del {#1097,UNTIL} resulte cierta, continuando
entonces la ejecuci¢n del programa tras esta sentencia.

Cada vez que se ejecutan las sentencias interiores se dice que se ha realizado
una {iteraci¢n} del bucle. La sentencia {REPEAT} ... {#1097,UNTIL} (literalmente
traducida como {REPETIR} ... {HASTA} (que se cumpla la) {<condici¢n>}) siempre
ejecutar  las sentencias interiores al menos una vez, ya que comprueba
la condici¢n siempre tras ejecutarlas.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x=0;
    REPEAT
        x=x+10;
        FRAME;
    UNTIL (x>320)
END
{-}

En este ejemplo se pondr  la variable local {x} (coordenada x del proceso) a
cero y, despu‚s, se le sumar n 10 a {x} y se dar  un {#1029,FRAME} {hasta} que
{x} sea un n£mero mayor que 320.

Una sentencia {#1026,BREAK} dentro de un bucle {REPEAT} lo finalizar  de
forma inmediata, continuando el programa por la sentencia siguiente a dicho
bucle.

Una sentencia {#1027,CONTINUE} dentro de un bucle {REPEAT} forzar  al programa
a realizar la comprobaci¢n del {#1097,UNTIL} inmediatamente y, si ‚sta es
falsa, volver  a ejecutar las sentencias interiores desde el principio (tras la
palabra reservada {REPEAT}). Si la condici¢n resulta cierta, la sentencia
{#1027,CONTINUE} finalizar  el bucle.

Las sentencias interiores a un bucle {REPEAT} pueden ser tantas como se
quieran y de cualquier tipo incluyendo, por supuesto, nuevos bucles {REPEAT}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1024,Sentencia LOOP}

{LOOP}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

La sentencia {LOOP} (bucle) es una sentencia que implementa un {bucle infinito},
es decir, que {repite indefinidamente un grupo de sentencias}.

Para implementar este bucle se debe comenzar con la palabra reservada {LOOP},
seguida de las sentencias que se quieren repetir continuamente y la palabra
reservada {#1091,END} al final.

Cuando en un programa se encuentre una sentencia {LOOP} ... {#1091,END} se
ejecutar n a partir de entonces, una y otra vez, todas las sentencias interiores
a dicho bucle.

Para finalizar un bucle {LOOP} se puede utlizar la sentencia {#1026,BREAK}
que, al ejecutarse dentro de un bucle de este tipo, forzar  al programa a
seguir a continuaci¢n del {#1091,END}.

Cada vez que se ejecutan las sentencias interiores se dice que se ha realizado
una {iteraci¢n} del bucle. La sentencia {#1027,CONTINUE}, dentro de un bucle,
finalizar  la {iteraci¢n} actual y comenzar  la siguiente (el programa
continuar  ejecut ndose tras la palabra reservada {LOOP}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x=0;
    LOOP
        IF (key(_esc))
            BREAK;
        END
        x=x+1;
        FRAME;
    END
END
{-}

En este ejemplo se pondr  la variable local {x} (coordenada x del proceso) a
cero y, despu‚s, se le sumar  1 y se dar  un {#1029,FRAME} continuamente. Si
se pulsa la tecla de escape ({ESC}) se ejecutar  la sentencia {#1026,BREAK},
finalizando el bucle {LOOP}.

Las sentencias interiores a un bucle {LOOP} pueden ser tantas como se
quieran y de cualquier tipo incluyendo, por supuesto, nuevos bucles {LOOP}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1025,Sentencia FOR}

{FOR} {#1053,(}<inicializaci¢n>{#1068,;} <condici¢n>{#1068,;} <incremento>{#1053,)}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

La sentencia {FOR} (r‚plica del lenguaje C) es una sentencia que implementa
un {bucle}, es decir, que es capaz de {repetir un grupo de sentencias un n£mero determinado de
veces}.

Para implementar este bucle se deben especificar, entre par‚ntesis, tres partes
diferentes, separadas por s¡mbolos {#1068,;} (punto y coma) tras la palabra
reservada {FOR}. Estas tres partes son opcionales (pueden omitirse) y son
las siguientes:

- {Inicializaci¢n}. En esta parte se suele codificar una sentencia de asignaci¢n
que fija el valor inicial de la variable que va a utilizarse como contador de
{iteraciones} del bucle (a cada ejecuci¢n del grupo interior de sentencias
se le denomina una {iteraci¢n} del bucle). Un ejemplo puede ser la sentencia de
asignaci¢n {x=0}, que fijar¡a la variable {x} a cero al inicio del bucle (valor
para la primera iteraci¢n).

- {#1037,Condici¢n}. En esta parte se especifica una condici¢n; justo
antes de cada iteraci¢n se comprobar  que sea cierta para pasar a ejecutar
el grupo de sentencias. Si la condici¢n se eval£a como falsa, se finalizar 
el bucle {FOR}, continuando el programa tras el {#1091,END} del bucle {FOR}.
Un ejemplo de condici¢n puede ser {x<10}, que permitir  que se ejecute el
grupo interior de sentencias £nicamente cuando la variable {x} sea un n£mero
menor que {10}.

- {Incremento}. En la £ltima de las tres partes es donde se indica el incremento
de la variable usada como contador por cada iteraci¢n del bucle; normalmente
‚sto se expresa tambi‚n con una sentencia de asignaci¢n. Por ejemplo, la
sentencia {x=x+1} le sumar¡a {1} a la variable {x} tras cada iteraci¢n del
bucle.

Tras la definici¢n del bucle {FOR} con sus tres partes es donde debe aparecer
el grupo de sentencias interiores al bucle que se van a repetir secuencialmente
mientras se cumpla la condici¢n de permanencia (parte segunda). Tras este grupo
de sentencias la palabra reservada {#1091,END} determinar  el final del
bucle {FOR}.

Cuando en un programa llega una sentencia {FOR} se ejecuta primero la parte
de la inicializaci¢n y se comprueba la condici¢n; si ‚sta es cierta se
ejecutar  el grupo de sentencias interiores y, despu‚s, la parte del incremento,
volvi‚ndose a comprobar la condici¢n, etc. Si antes de cualquier iteraci¢n la
condici¢n resulta falsa, finalizar  la sentencia {FOR} inmediatamente.

A continuaci¢n, se muestra un programa con un bucle {FOR} con las tres partes
sugeridas en las secciones anteriores.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FOR ( x=0 ; x<10 ; x=x+1 )
        // Aqu¡ vendr¡an las sentencias interiores.
    END
END
{-}

Este bucle se ejecutar¡a la primera vez con la variable {x} valiendo {0}, la
segunda valiendo {1}, ..., y la £ltima valiendo {9}; tras esta iteraci¢n se
ejecutar¡a la parte del incremento, pasando {x} a valer {10} y, entonces,
al comprobarse la condici¢n de permanencia en el bucle (que {x} sea menor
que {10}) y resultar ‚sta falsa, se dar¡a por finalizado el bucle.

Como se ha mencionado, las tres partes en la definici¢n del bucle son opcionales;
si se omitieran las tres:

  {FOR ( ; ; )}ú
      // ...ú
  {END}

Entonces, este bucle es equivalente a un bucle {#1024,LOOP} ... {#1091,END}.

Adem s en un bucle {FOR} pueden ponerse varias partes de inicializaci¢n,
condici¢n o incremento separadas por comas ({#1059,,}), ejecut ndose todas las
inicializaciones al principio, luego comprob ndose todas las condiciones
de permanencia (si cualquiera resulta falsa, el bucle finalizar ), las
asentencias interiores y, al final, tras cada iteraci¢n, todos los incrementos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FOR ( x=0, y=1000 ; x<y ; x=x+2, y=y+1 )
        // Aqui vendr¡an las sentencias interiores.
    END
END
{-}

Una sentencia {#1026,BREAK} dentro de un bucle {FOR} lo finalizar  de forma
inmediata, continuando el programa por la sentencia siguiente a dicho bucle.

Una sentencia {#1027,CONTINUE} dentro de un bucle {FOR} forzar  al programa a
ejecutar directamente la parte del incremento y, despu‚s, realizar la comprobaci¢n
de permanencia y, si ‚sta es cierta, volver a ejecutar las sentencias interiores
desde el principio. Si la condici¢n resulta cierta, la sentencia {#1027,CONTINUE}
finalizar  el bucle {FOR}.

Un bucle {FOR} es, pr cticamente, equivalente a un bucle {#1022,WHILE} implementado
de la siguiente forma:

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x=0;
    WHILE (x<10)
        // Aqui vendr¡an las sentencias interiores.
        x=x+1;
    END
END
{-}

Con la £nica excepci¢n de que una sentencia {#1027,CONTINUE}, dentro de este
bucle {#1022,WHILE}, no ejecutar¡a la parte del incremento, mientras que en un bucle {FOR}
s¡ lo har¡a.

Si en un bucle {FOR}, tras ejecutarse la inicializaci¢n, la condici¢n
resulta falsa directamente, no se ejecutar n ninguna vez las sentencias interiores.

Las sentencias interiores a un bucle {FOR} pueden ser tantas como se
quieran y de cualquier tipo incluyendo, por supuesto, nuevos bucles {FOR}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1026,Sentencia BREAK}

Una sentencia {BREAK} dentro de un bucle lo finalizar  de forma
inmediata, continuando el programa por la sentencia siguiente a dicho bucle.
No se puede poner esta sentencia m s que dentro de los siguientes bucles:

  {#1022,LOOP} ... {#1091,END}ú
  {#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
  {#1023,REPEAT} ... {#1097,UNTIL} {#1053,(} .. {#1053,)}ú
  {#1024,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
  {#1025,FOR} {#1053,(} .. {#1068;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú

Un {BREAK} provocar  que el programa contin£e ejecut ndose tras el {#1091,END}
o {#1097,UNTIL} del bucle m s cercano a la sentencia.

En caso de haber varios bucles anidados (unos dentro de otros) la sentencia
{BREAK} saldr  £nicamente del bucle m s interior de ellos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    LOOP
        REPEAT
            IF (key(_esc)) BREAK; END
            //...
        UNTIL (x==0);
        //...
    END
END
{-}

En este ejemplo la sentencia {BREAK} saldr  del {#1023,REPEAT} ... {UNTIL}
(cuando se pulse la tecla {ESC}), pero no del {#1022,LOOP} ... {#1091,END}.

{Importante}{/}

La sentencia {BREAK} no es v lida para finalizar sentencias {#1020,IF}, ni
{#1021,SWITCH} (ni las secciones {#1087,CASE} de esta sentencia), ni
sentencias {#1030,CLONE}.

{BREAK} s¢lo puede finalizar las sentencias que implementan un bucle.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1027, Sentencia CONTINUE}

Una sentencia {CONTINUE} dentro de un bucle forzar  al programa a
finalizar la iteraci¢n actual del mismo y comenzar la siguiente.

Se denomina {iteraci¢n} a cada ejecuci¢n del grupo de sentencias interior
a un bucle (las sentencias entre un {#1022,LOOP} y su {#1091,END}, por
ejemplo).

No se puede poner esta sentencia m s que dentro de los siguientes bucles:

{#1022,LOOP} ... {#1091,END}ú
Un CONTINUE dentro de este bucle saltar  al LOOP.

{#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
Un CONTINUE dentro de este bucle realizar  el incremento (STEP) y, si no
se ha pasado el valor indicado en el TO, continuar  el programa al inicio
del bucle.

{#1023,REPEAT} ... {#1097,UNTIL} {#1053,(}..{#1053,)}ú
Un CONTINUE dentro de este bucle saltar  al UNTIL.

{#1024,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
Un CONTINUE dentro de este bucle saltar  al WHILE.

{#1025,FOR} {#1053,(} .. {#1068,;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú
Un CONTINUE dentro de este bucle realizar  el incremento y la comparaci¢n;
si ‚sta £ltima resulta cierta continuar  el programa al inicio del bucle,
si resulta falsa el programa continuar  tras el END del FOR.

En caso de haber varios bucles anidados (unos dentro de otros) la sentencia
{CONTINUE} tendr  efecto £nicamente en el bucle m s interior de ellos.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FOR (x=0, y=0;x<10;x++)
        IF (x<5) CONTINUE; END
        y++;
    END
END
{-}

En este ejemplo, tras ejecutarse el bucle completo, {x} valdr  {10} e {y}
valdr  {5}, pues mientras {x} es menor que 5 la sentencia {CONTINUE}
impide que se ejecute la sentencia {y++;}.

{Importante}{/}

La sentencia {CONTINUE} no es v lida dentro de sentencias {#1020,IF}, ni
{#1021,SWITCH} (ni las secciones {#1087,CASE} de esta sentencia), ni
sentencias {#1030,CLONE} (ya que estas sentencias no implementan bucles y,
por tanto, no realizan iteraciones).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1028,Sentencia RETURN}

La sentencia {RETURN} finaliza el proceso actual de forma inmediata, como
si se llegara al {#1091,END} de su {#1086,BEGIN}.

Esta sentencia en el c¢digo principal lo finalizar , pero si quedan procesos
vivos ‚stos se seguir n ejecutando. Para terminar un programa y todos sus
procesos se puede utilizar, por ejemplo, la funci¢n {#109,exit()}.

Un {RETURN} dentro de un proceso lo finalizar , matando a dicho proceso.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    LOOP
        IF (key(_esc))
            RETURN;
        END
        FRAME;
    END
END
{-}

En este ejemplo, al pulsarse la tecla de escape ({ESC}) se ejecutar  la
sentencia {RETURN}, finalizando el programa.

{Uso de RETURN para retornar un valor}{/}

Es posible construir procesos con un comportamiento similar a las funciones
de otros lenguajes de programaci¢n, que {reciban una serie de par metros y
devuelvan un valor}. Por ejemplo, un proceso que reciba dos valores num‚ricos
y devuelva el mayor de ambos.

Para ello, se debe utilizar esta sentencia con la siguiente sintaxis:

{RETURN(}{#1035,<expresi¢n>}{)}

Tambi‚n es importante no utilizar la sentencia {#1029,FRAME} dentro del proceso,
pues ‚sta retornar  inmediatamente al proceso llamante. Cuando el compilador
encuentra la sentencia {#1029,FRAME} dentro de un {#1016,PROCESS} lo cataloga
directamente como proceso, descartando su posible uso como funci¢n.

{Importante:} Para poder retornar un valor con la sentencia {RETURN} despu‚s de haber
ejecutado una o varias sentencias {#1029,FRAME}, se debe construir un bloque
de tipo {#1408,FUNCTION}.

{/}

A continuaci¢n se muestra el ejemplo antes propuesto: una implementaci¢n de
la funci¢n matem tica {max} que devuelve el mayor de sus dos par metros.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    x=max(2, 3)+max(5, 4);
END
PROCESS max(a, b)
BEGIN
    IF (a>b)
        RETURN(a);
    ELSE
        RETURN(b);
    END
END
{-}

Tras ejecutarse este programa, la variable {x} del proceso principal valdr  {8} (3+5).

{/}

{Nota:} Por defecto, si se utiliza la sentencia {RETURN} sin la expresi¢n
entre par‚ntesis o la sentencia {#1029,FRAME} en un proceso, el valor de retorno del
mismo ser  su {#1039,c¢digo identificador} de proceso.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1029,Sentencia FRAME}

La sentencia {FRAME} es una pieza clave dentro del lenguaje. El funcionamiento
de un programa es, a grandes rasgos, el siguiente:

- Comienza ejecut ndose el proceso principal, el cual puede crear m s
procesos (objetos del juego) en cualquier punto. Todos los procesos pueden
finalizar en cualquier momento, crear o eliminar otros procesos.

- Los juegos se visualizar n siempre imagen a imagen (frame by frame).
En cada imagen, el sistema ejecutar  todos los procesos existentes en ese
momento, uno por uno, hasta que cada uno ejecute la sentencia {FRAME}, que
indicar  que est  listo para la siguiente visualizaci¢n (imagen).

En la preparaci¢n de cada imagen todos los procesos ser n ejecutados en
el orden de prioridad establecido (la variable local {#1121,priority} de los
procesos determina este orden).

Luego esta sentencia es algo as¡ como la orden de visualizaci¢n de los
procesos.

Si un proceso comienza a ejecutarse y no finaliza ni ejecuta
esta sentencia, entonces el programa se quedar  bloqueado, ya que existe
un proceso que no est  nunca listo para la siguiente visualizaci¢n; por lo que
el sistema ser  incapaz de mostrar la siguiente imagen.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    mi_proceso();
    mi_proceso();
    LOOP
        IF (key(_esc))
            mi_segundo_proceso();
        END
        FRAME;
    END
END
PROCESS mi_proceso()
BEGIN
    LOOP
        FRAME;
    END
END
PROCESS mi_segundo_proceso()
BEGIN
    LOOP
    END
END
{-}

En este programa el proceso principal (de tipo {mi_juego}) crea otros dos
procesos (de tipo {mi_proceso}); a partir de este momento los tres procesos
se ejecutar n continuamente, cada uno hasta su sentencia {FRAME}. Pero si
se pulsa la tecla de escape ({ESC}), el proceso principal crear  un nuevo
proceso (de tipo {mi_segundo_proceso}) que se quedar  en un bucle {#1024,LOOP}
indefinidamente, sin ejecutar ning£n {FRAME}, por lo que el programa
quedar  interrumpido (el sistema advertir  de dicha situaci¢n transcurridos
unos segundos, ver {#1115,max_process_time}).

B sicamente, todos los procesos que se corresponden con objetos de un juego
construyen un bucle dentro del cual, cada imagen, fija todos sus valores
de visualizaci¢n ({#1123,x}, {#1124,y}, {#1126,graph}, {#1128,size}, {#1129,angle}, ...)
y, despu‚s, ejecutan la sentencia {FRAME}.

{Sincronizaci¢n de procesos}{/}

Es posible utilizar esta sentencia con la siguiente sintaxis:

{FRAME(}<porcentaje>{)}

Poniendo un porcentaje entero, de 0 a 100 o mayor, entre par‚ntesis tras
la palabra reservada {FRAME}.

Este porcentaje indicar  el tanto por ciento de la siguiente imagen completado
por el proceso; es decir, cuando no se especifica dicho porcentaje
es lo mismo que si se pusiera {FRAME(100)} (se ha completado el 100% del
trabajo previo a la siguiente visualizaci¢n por parte del proceso).

Por ejemplo, si un proceso ejecuta en un bucle la sentencia {FRAME(25)},
necesitar  ejecutarla {4 veces} antes de estar listo para la siguiente
visualizaci¢n (ya que 4*25% es el 100%).

En el otro extremo, si un proceso ejecuta dentro de su bucle la sentencia
{FRAME(400)}, cuando se ejecute la primera vez habr  completado ya un
400% de la visualizaci¢n, por lo que, aun tras visualizarse, le seguir 
restando un 300% de visualizaci¢n completado. Por ello, en la preparaci¢n
de las siguientes {3} im genes el sistema no ejecutar  dicho proceso, pues
ya est  listo para la visualizaci¢n. Luego este proceso se ejecutar¡a
s¢lo una de cada 4 im genes (al contrario que el ejemplo del p rrafo anterior,
que se ejecutaba 4 veces por cada imagen del juego).

Los procesos no llegar n a la siguiente visualizaci¢n hasta no dar,
{por lo menos, el 100%}. Por ejemplo, si un proceso ejecuta siempre sentencias
{FRAME(80)}, las ejecutar  dos veces antes de la primera visualizaci¢n con lo
que llevar  el 160% (2*80%) de la visualizaci¢n completado. Para la siguiente
visualizaci¢n tendr , por tanto, un 60% pre-completado (160%-100%); por ello, en la
segunda visualizaci¢n tan s¢lo requerir  una sentencia {FRAME(80)} para
visualizarse, ya que este 80%, unido al 60% sobrante de la primera, har  un total
de un 140% completado, con lo cual se visualizar  inmediatamente, e incluso le
sobrar  otro 40% para la preparaci¢n de la siguiente imagen.

{/}

Una sentencia {FRAME(0)}, que complete un 0% de la siguiente visualizaci¢n,
puede tener sentido en estos dos casos:

- Puede ser una forma de forzar al sistema a que ejecute en ese punto al resto
de los procesos que tienen la misma prioridad que el actual y que, tras ellos,
vuelva a ejecutarlo.

- O puede ser una forma de inicializar funciones como {#120,get_id()} o
{#104,collision()}, pues ‚stas devuelven unos determinados valores para
cada imagen; si se quiere volver a obtener valores de nuevo, se puede
ejecutar una sentencia {FRAME(0)} que estas funciones interpretar n
como una nueva imagen.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1030,Sentencia CLONE}

{CLONE}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

Esta sentencia crea un nuevo proceso id‚ntico al actual, con la salvedad
de que las sentencias entre las palabras reservadas {CLONE} y {#1091,END} se
ejecutar n £nicamente en el nuevo proceso y no en el actual.

Por ejemplo, si cualquier proceso del programa, con unas coordenadas ({#1123,x},
{#1124,y}) determinadas y un gr fico ({#1126,graph}) concreto, ejecuta la
siguiente sentencia:

  {CLONE}ú
      x=x+100;ú
  {#1091,END}

Se crear  un nuevo proceso identico a ‚l, con el mismo gr fico y los mismos
valores en todas sus variables, a excepci¢n de la coordenada {#1123,x}, que
el nuevo proceso tendr  {100} puntos m s a la derecha.

Esta sentencia se utiliza para crear r‚plicas de un proceso, dividirlo en
dos procesos (casi) iguales.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    // ...
    x=0;
    y=0;
    CLONE
        x=x+10;
    END
    CLONE
        y=y+10;
    END
    // ...
END
{-}

En este ejemplo, las {2} sentencias {CLONE} crear n {3} copias del proceso
principal (y no 2, como podr¡a haberse esperado).

Al ejecutarse la primera sentencia {CLONE} se crear  un nuevo proceso, con
lo que habr  {2}: uno en (x=0, y=0) y otro en (x=10, y=0). Y estos dos
procesos ejecutar n la segunda sentencia {CLONE}, el primero (el original)
creando con ello un nuevo proceso en (x=0, y=10), y el segundo crear  el
nuevo proceso en (x=10, y=10).

Para crearse £nicamente {2} copias del proceso original se podr¡a haber
construido el programa, por ejemplo, de la siguiente forma:

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    // ...
    x=0;
    y=0;
    CLONE
        x=x+10;
        CLONE
            y=y+10;
        END
    END
    // ...
END
{-}

El proceso original (x=0, y=0) crear  uno en (x=10, y=0) y ‚ste, a su vez,
otro en (x=10, y=10), creandose £nicamente dos copias del original.

Se debe, por tanto, tener mucho cuidado con el uso de la sentencia {CLONE}
de forma secuencial o dentro de un {bucle}, pues se debe contar con que los
primeros '{clones}' pueden crear, a su vez, a nuevos '{clones}'.

Esta sentencia permite usarse sin poner sentencias entre las palabras
{CLONE} y {#1091,END}. Pero, al menos en un principio, no parece tener mucho
sentido el querer tener dos procesos id‚nticos, con las mismas coordenadas,
el mismo gr fico y ejecutando el mismo c¢digo.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1031,Sentencia DEBUG}

La sentencia {DEBUG} invocar  al trazador (o debugger) interactivo cuando
se ejecute.

Se suele utilizar para depurar programas, es decir, para encontrar posibles
errores que tengan los programas. Se suele poner, en ocasiones, en los siguientes
puntos.

- Donde se quiera comprobar que una parte del programa ha hecho lo que se
esperaba que hiciera; tras ejecutarse dicha parte, {DEBUG} invocar  al
trazador, desde donde pueden comprobarse todos los procesos activos y el
valor de todas sus variables.

- Cuando no se est  muy seguro de si algo puede suceder en un programa, se
puede poner esta sentencia en dicho punto, para que nos avise en caso de que
suceda.

Esta sentencia se pone £nicamente de forma temporal hasta que se localiza
el error buscado; una vez encontrado ya no es necesaria la sentencia por lo que se puede quitar
del programa, ya que por lo dem s, no tiene ning£n otro efecto.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    // ...
    IF (x<0)
        DEBUG;
    END
    // ...
END
{-}

En este ejemplo se comprueba, en un determinado punto del programa, que la
coordenada {x} del proceso no sea un n£mero negativo (menor que cero); si
esto sucediera, se invocar  al trazador para poder investigar por qu‚
ha sucedido.

Cuando se ejecuta esta sentencia se abre un cuadro de di logo que nos
ofrece las siguientes opciones:

- Desabilitar la sentencia {DEBUG}, para que no vuelva a activarse en
esta ejecuci¢n del programa.

- Detener el programa y entrar en el trazador, para poder examinar todos
los procesos y sus variables.

- O terminar de inmediato la ejecuci¢n del programa, regresando a la edici¢n
del mismo en el entorno gr fico de ventanas.

Adem s, si se pulsa la tecla de escape {ESC} en dicho cuadro, simplemente
se ignorar  dicha sentencia {DEBUG} y se continuar  ejecutando el programa
normalmente.

{/}

Cuando se ejecuta un programa desde el entorno gr fico de ventanas, puede
invocarse al trazador en cualquier instante pulsando la tecla {F12}.

Al invocarse de esta forma al trazador, el programa ser  interrumpido siempre
justo antes de empezar a procesar una nueva imagen, estando todos los
procesos por ejecutar antes de la pr¢xima visualizaci¢n.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1032,Lista de funciones del lenguaje}{+4,1}{-}

Funciones de interacci¢n entre procesosú
  {#104,collision()}ú
  {#116,get_angle()}ú
  {#117,get_dist()}ú
  {#118,get_distx()}ú
  {#119,get_disty()}ú
  {#120,get_id()}ú
  {#129,let_me_alone()}ú
  {#158,signal()}ú

Funciones sobre geometr¡aú
  {#101,advance()}ú
  {#113,fget_angle()}ú
  {#114,fget_dist()}ú
  {#142,near_angle()}ú
  {#183,xadvance()}ú

Funciones de b£squeda de caminosú
  {#185,path_find()}ú
  {#187,path_free()}ú
  {#186,path_line()}ú

Funciones matem ticasú
  {#100,abs()}ú
  {#246,acos()}ú
  {#245,asin()}ú
  {#247,atan()}ú
  {#248,atan2()}ú
  {#243,cos()}ú
  {#145,pow()}ú
  {#242,sin()}ú
  {#160,sqrt()}ú
  {#244,tan()}ú

Funciones de aleatoriosú
  {#149,rand()}ú
  {#150,rand_seed()}ú

Funciones gr ficasú
  {#103,clear_screen()}ú
  {#123,get_pixel()}ú
  {#135,map_block_copy()}ú
  {#136,map_get_pixel()}ú
  {#137,map_put()}ú
  {#138,map_put_pixel()}ú
  {#139,map_xput()}ú
  {#188,new_map()}ú
  {#146,put()}ú
  {#147,put_pixel()}ú
  {#148,put_screen()}ú
  {#212,screen_copy()}ú
  {#173,xput()}ú

Funciones de primitivas gr ficasú
  {#250,delete_draw()}ú
  {#249,draw()}ú
  {#251,move_draw()}ú

Funciones del sistema de audioú
  {#256,change_channel()}ú
  {#102,change_sound()}ú
  {#175,reset_sound()}ú
  {#178,set_volume()}ú

Funciones para efectos de sonidoú
  {#221,is_playing_sound()}ú
  {#134,load_pcm()}ú
  {#134,load_wav()}ú
  {#159,sound()}ú
  {#167,stop_sound()}ú
  {#170,unload_pcm()}ú
  {#170,unload_wav()}ú

Funciones para m£sica CDú
  {#127,is_playing_cd()}ú
  {#144,play_cd()}ú
  {#164,stop_cd()}ú

Funciones para m£sica digitalú
  {#220,get_song_line()}ú
  {#219,get_song_pos()}ú
  {#222,is_playing_song()}ú
  {#214,load_song()}ú
  {#218,set_song_pos()}ú
  {#216,song()}ú
  {#217,stop_song()}ú
  {#215,unload_song()}ú

Funciones de entradaú
  {#121,get_joy_button()}ú
  {#122,get_joy_position()}ú
  {#128,key()}ú

Funciones para el manejo de la paletaú
  {#105,convert_palette()}ú
  {#110,fade()}ú
  {#111,fade_off()}ú
  {#112,fade_on()}ú
  {#264,find_color()}ú
  {#266,force_pal()}ú
  {#133,load_pal()}ú
  {#154,roll_palette()}ú
  {#179,set_color()}ú

Funciones para scroll y modo 7ú
  {#140,move_scroll()}ú
  {#152,refresh_scroll()}ú
  {#162,start_mode7()}ú
  {#163,start_scroll()}ú
  {#165,stop_mode7()}ú
  {#166,stop_scroll()}ú

Funciones para el modo 8ú
  {#195,get_point_m8()}ú
  {#193,get_sector_height()}ú
  {#198,get_sector_texture()}ú
  {#200,get_wall_texture()}ú
  {#191,go_to_flag()}ú
  {#189,load_wld()}ú
  {#201,set_env_color()}ú
  {#196,set_fog()}ú
  {#194,set_point_m8()}ú
  {#192,set_sector_height()}ú
  {#197,set_sector_texture()}ú
  {#199,set_wall_texture()}ú
  {#190,start_mode8()}ú
  {#182,stop_mode8()}ú

Funciones para imprimir textosú
  {#107,delete_text()}ú
  {#131,load_fnt()}ú
  {#141,move_text()}ú
  {#177,unload_fnt()}ú
  {#171,write()}ú
  {#253,write_in_map()}ú
  {#172,write_int()}ú

Funciones de cadenas de textoú
  {#184,char()}ú
  {#210,lower()}ú
  {#203,strcat()}ú
  {#206,strchr()}ú
  {#205,strcmp()}ú
  {#202,strcpy()}ú
  {#211,strdel()}ú
  {#204,strlen()}ú
  {#208,strset()}ú
  {#207,strstr()}ú
  {#209,upper()}ú

Funciones de conversi¢n de cadenasú
  {#254,calculate()}ú
  {#255,itoa()}ú

Funciones para animacionesú
  {#108,end_fli()}ú
  {#115,frame_fli()}ú
  {#153,reset_fli()}ú
  {#161,start_fli()}ú

Funciones de regiones de pantallaú
  {#106,define_region()}ú
  {#143,out_region()}ú

Funciones de informaci¢n sobre gr ficosú
  {#124,get_point()}ú
  {#125,get_real_point()}ú
  {#126,graphic_info()}ú

Funciones de inicializaci¢nú
  {#156,set_fps()}ú
  {#157,set_mode()}ú

Funciones de carga de recursosú
  {#132,load_fpg()}ú
  {#174,load_map()}ú
  {#174,load_pcx()}ú
  {#169,unload_fpg()}ú
  {#176,unload_map()}ú
  {#176,unload_pcx()}ú

Funciones de grabaci¢n de mapasú
  {#241,save_map()}ú
  {#241,save_pcx()}ú

Funciones de grabaci¢n de datosú
  {#130,load()}ú
  {#155,save()}ú

Funciones de archivosú
  {#224,fclose()}ú
  {#229,filelength()}ú
  {#230,flush()}ú
  {#223,fopen()}ú
  {#225,fread()}ú
  {#227,fseek()}ú
  {#228,ftell()}ú
  {#226,fwrite()}ú

Funciones de directoriosú
  {#235,chdir()}ú
  {#238,disk_free()}ú
  {#231,get_dirinfo()}ú
  {#232,get_fileinfo()}ú
  {#233,getdrive()}ú
  {#236,mkdir()}ú
  {#237,remove()}ú
  {#234,setdrive()}ú

Funciones de compresi¢nú
  {#262,compress_file()}ú
  {#263,uncompress_file()}ú

Funciones de encriptaci¢nú
  {#261,decode_file()}ú
  {#259,encode()}ú
  {#260,encode_file()}ú

Funciones de sistemaú
  {#109,exit()}ú
  {#240,ignore_error()}ú
  {#168,system()}ú

Funciones de memoria din micaú
  {#258,free()}ú
  {#257,malloc()}ú
  {#239,memory_free()}ú

Funciones de redú
  {#181,net_get_games()}ú
  {#180,net_join_game()}ú

{/}

{Nota:} Para obtener ayuda de una funci¢n en concreto directamente, sit£e el
cursor de edici¢n sobre el nombre de la funci¢n (en el editor de programas)
y pulse {F1}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1033,Llamada a un proceso}

<nombre_del_proceso>{(}<lista de par metros>{)}

Una llamada a un proceso se hace poniendo el {#1001,nombre} del
proceso (su nombre), seguido de una lista con tantas expresiones
separadas por {#1059,comas (,)}, como {#1018,par metros} tenga el proceso,
entre {#1053,par‚ntesis (())}. Los par‚ntesis son obligatorios aun cuando
el proceso no tenga {#1018,par metros} de llamada.

Una llamada a un proceso siempre devolver  un valor, que depende de cual
de las siguientes acciones realice primero el proceso llamado.

- Si ejecuta la sentencia {#1029,FRAME} el proceso retornar  su {#1039,c¢digo identificador}.

- Si el proceso ejecuta la sentencia {#1028,RETURN}{#1053,(}<expresi¢n>{#1053,)}
retornar  el resultado de dicha expresi¢n.

- Si el proceso termina, bien porque llegue el {#1091,END} de su {#1086,BEGIN}
o porque ejecute una sentencia {#1028,RETURN} sin expresi¢n, el proceso
retornar  el {#1039,c¢digo identificador} que tuvo, pero como el proceso ha
finalizado (muerto), se debe tener en cuenta que dicho
{#1039,c¢digo identificador} puede ser ahora utilizado por cualquier otro proceso
que se cree a partir de ahora.

El valor de retorno puede ignorarse, asignarse a una variable o bien
utilizarse dentro de una expresi¢n.

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE
  id2;
BEGIN
    mi_proceso(0, 0);
    id2=mi_proceso(320, 200);
    // ...
END
PROCESS mi_proceso(x, y)
BEGIN
    LOOP
        FRAME;
    END
END
{-}

En este ejemplo el proceso principal {mi_juego} realiza dos llamadas
al proceso {mi_proceso}, que recibe dos par metros en sus variables locales
{x} e {y}.

Como el proceso ejecuta la sentencia {#1029,FRAME} devolver  su
{#1039,c¢digo identificador}.

Se puede observar c¢mo el valor devuelto en la primera llamada al proceso
es despreciado (no se utiliza para nada), y c¢mo en la segunda se asigna
el {#1039,c¢digo identificador} de {mi_proceso(320, 200)} a la variable privada del
proceso principal {id2}.

Cuando se realiza una llamada a un proceso se detiene moment neamente la
ejecuci¢n del proceso actual y se pasa a ejecutar el c¢digo del proceso
llamado, hasta que este retorne por uno de los tres casos enumerados (hasta
que termine o ejecute una sentencia {#1029,FRAME} o {#1028,RETURN}).

Si el proceso ha terminado con una sentencia {#1029,FRAME} se visualizar 
en la siguiente imagen seg£n los valores establecidos en sus variables
locales ({#1023,x}, {#1024,y}, {#1026,graph}, ...) y, en la preparaci¢n de
la siguiente imagen, dicho proceso continuar  ejecut ndose a partir de
la sentencia {#1029,FRAME}.

{/}Ver: {#1000,Sintaxis} - {#1018,Par metros de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1034,Referencia a un dato}

Una referencia a un dato es cualquier expresi¢n que haga referencia a una
celda o posici¢n de la memoria del ordenador, normalmete suele entenderse
como uno de los siguientes aspectos:

- Si el dato es una variable, para referirnos de esta forma al dato
simplemente debemos especificar su nombre.

Ejemplo de una referencia a una variable: {x}

- Si el dato es una tabla se suele hacer referencia a la misma
con su nombre seguido de una expresi¢n entre corchetes ({#1079,[ ]}); dicha
expresi¢n determinar  la posici¢n de la tabla que se pretende acceder.
Si se omite el ¡ndice entre corchetes se acceder  a la primera posici¢n de
la tabla (la posici¢n 0).

Ejemplo de una referencia a una tabla: {timer[0]}

- Si el dato es una estructura se har  referencia a la misma con su
nombre seguido de una expresi¢n entre corchetes ({#1079,[ ]}) que
determinar  el n£mero de registro al que se acceder  y, tras esto, ir 
el s¡mbolo{#1063, . (punto)} precediendo al nombre concreto del campo
de la estructura al que se va a acceder. Si se omite el n£mero de registro
entre corchetes se acceder  al primer registro de la estructura (el n£mero 0).

Ejemplo de una referencia a una estructura: {scroll[0].z}

Estos tres casos se refieren a accesos a datos del propio proceso o globales;
cuando se pretenda acceder a un dato ajeno (un dato local de otro proceso),
se preceder  por el {#1039,c¢digo identificador} del
proceso ajeno y el s¡mbolo{#1063, . (punto)}, operador de acceso a datos
locales y estructuras).

Ejemplo de una referencia a una variable local ajena: {father.x}

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1035,Definici¢n de una expresi¢n}

Una expresi¢n se entiende, b sicamente, como una f¢rmula matem tica que
involucre a uno o m s {operandos} ({x}, {2}, {id}, ...) por medio de diversos
{operadores} ({*}, {AND}, {>>}, ...); algunos ejemplos de expresiones ser¡an:
{2}, {2+3} o {(x*4)/-3}.

Como valores se pueden utilizar £nicamente n£meros enteros dentro del rango
({#1177,min_int} ... {#1178,max_int}) y el resultado de la expresi¢n
siempre quedar  truncado dentro de este rango.

Estas expresiones ser n evaluadas cuando se ejecute la sentencia que las
contiene dentro del programa.

Los {operandos} que se pueden utilizar en una expesi¢n son:

    - {#1004,Constantes}.ú
    - {Valores num‚ricos}.ú
    - {Literales} (textos entre comillas).ú
    - Variables, tablas o estructuras de cualquier tipo.ú
    - Cualquier tipo de funci¢n o proceso.ú
    - {#1039,C¢digo identificador} del proceso.ú
    - Tipo de proceso ({#1042,type <nombre>}).ú

Los {operadores} que se pueden utilizar en una expresi¢n son (entre
par‚ntesis se muestran los sin¢nimos del operador, en caso de tenerlos):

    {#1056, +}    Sumaú
    {#1060, -}    Resta (o negaci¢n de signo)ú
    {#1054, *}    Multiplicaci¢nú
    {#1065, /}    Divisi¢nú
    {#1048, MOD}  M¢dulo ({#1048,%})ú
    {#1070, <<}   Rotaci¢n a la derechaú
    {#1077, >>}   Rotaci¢n a la izquierdaú
    {#1045, NOT}  Negaci¢n binaria y l¢gica ({#1045,!})ú
    {#1051, AND}  AND binario y l¢gico ({#1050,&}, {#1051,&&})ú
    {#1083, OR}   OR binario y l¢gico ({#1083,|}, {#1083,||})ú
    {#1082, XOR}  OR exclusivo ({#1082,^^})ú
    {#1074, ==}   Comparaci¢nú
    {#1046, <>}   Distinto ({#1046,!=})ú
    {#1076, >}    Mayorú
    {#1075, >=}   Mayor o igual ({#1075,=>})ú
    {#1069, <}    Menorú
    {#1072, <=}   Menor o igual ({#1072,=<})ú
    {#1085, OFFSET} Direcci¢n o desplazamiento ({#1050,&})ú
    {#1057, ++}   Operador de incrementoú
    {#1061, --}   Operador de decrementoú
    {#1079, ^}    Operador de indirecci¢n ({#1054,*}, {#1079,[ ]})ú
    {#1053, ( )}  Par‚ntesisú

Pulse sobre "{#1036,Evaluaci¢n de una expresi¢n}" para ver el orden en el
que son realizados los c lculos dentro de una expresi¢n y cu ndo deben usarse los par‚ntesis.

A continuaci¢n se muestran algunos ejemplos de expresiones v lidas:

{    -33}ú
{    44-2*22}ú
{    id}ú
{    x+1}ú
{    (angle*3)/2-pi/2}ú
{    (x+y)/2}ú
{    abs(x-y)*3-pow(x, 2)}ú
    ...

{/}Ver: {#1000,Sintaxis} - {#1036,Evaluaci¢n de una expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1036,Evaluaci¢n de una expresi¢n}

Es importante conocer la forma en la que son evaluadas las expresiones para
saber d¢nde pueden ser necesarios o no par‚ntesis que indiquen el modo en el
que se pretende que la expresi¢n sea evaluada.

En el lenguaje, una expresi¢n puede contener operadores de diferentes niveles
de prioridad.

En la evaluaci¢n de una expresi¢n ser n siempre procesados primero los de
{prioridad 1} (si los hay), luego los de {prioridad 2}, tras estos los de
{prioridad 3} y, as¡, sucesivamente.

Prioridad 1ú
    {#1053, ( )}  Par‚ntesis, inicio y fin de una sub-expresi¢nú

Prioridad 2ú
    {#1063, .}    Punto, operador de acceso a datos locales y estructurasú

Prioridad 3ú
    {#1045, NOT}  Negaci¢n binaria y l¢gica (#1045,{!})ú
    {#1085, OFFSET} Direcci¢n o desplazamiento (#1050,{&})ú
    {#1079, ^}    Operador de indirecci¢n ({#1054,*}, {#1079,[ ]})ú
    { -}  Negaci¢n de signoú
    {#1057, ++}   Operador de incrementoú
    {#1061, --}   Operador de decrementoú

Prioridad 4ú
    {#1054, *}    Multiplicaci¢nú
    {#1065, /}    Divisi¢nú
    {#1048, MOD}  M¢dulo ({#1048,%})ú

Prioridad 5ú
    {#1056, +}    Sumaú
    {#1060, -}    Restaú

Prioridad 6ú
    {#1070, <<}   Rotaci¢n a la derechaú
    {#1077, >>}   Rotaci¢n a la izquierdaú

Prioridad 7ú
    {#1051, AND}  AND binario y l¢gico ({#1050,&}, {#1051,&&})ú
    {#1083, OR}   OR binario y l¢gico ({#1083,|}, {#1083,||})ú
    {#1082, XOR}  OR exclusivo ({#1082,^^})ú

Prioridad 8ú
    {#1074, ==}   Comparaci¢nú
    {#1046, <>}   Distinto ({#1046,!=}ú
    {#1076, >}    Mayorú
    {#1075, >=}   Mayor o igual ({#1075,=>}ú
    {#1069, <}    Menorú
    {#1072, <=}   Menor o igual ({#1072,=<}ú

Prioridad 9ú
    {#1073, =}    Asignaci¢nú
    {#1058, +=}   Suma-asignaci¢nú
    {#1062, -=}   Resta-asignaci¢nú
    {#1055, *=}   Multiplicaci¢n-asignaci¢nú
    {#1066, /=}   Divisi¢n-asignaci¢nú
    {#1049, %=}   M¢dulo-asignaci¢nú
    {#1052, &=}   AND-asignaci¢nú
    {#1084, |=}   OR-asignaci¢nú
    {#1081, ^=}   XOR-asignaci¢nú
    {#1078, >>=}  Rotaci¢n a la derecha-asignaci¢nú
    {#1071, <<=}  Rotaci¢n a la izquierda-asignaci¢nú

Los operadores de {prioridad 3} son los operadores conocidos como {unarios}; ‚stos
no relacionan a dos operandos (que es el caso de los operadores {binarios} como,
por ejemplo, una multiplicaci¢n), sino que £nicamente afectan al valor de un
operador. Dentro de los operadores {unarios} se ejecutar n primero los m s
cercanos al operando, por ejemplo en la expresi¢n:

  {NOT -x}

El operando {x} tiene dos operadores {unarios}, la negaci¢n de signo{ -} y
el {#1045,NOT} l¢gico y/o binario; de ‚stos se ejecutar  primero la negaci¢n de
signo, pues es la que est  m s cerca del operando.

Todos los operadores a partir de la {prioridad 4} son {binarios} y se
ejecutar n seg£n su nivel de prioridad por lo que, cuando en una expresi¢n haya m s
de un operador del mismo nivel (por ejemplo, una multiplicaci¢n y una divisi¢n,
que son ambas de prioridad 4), se procesar n de izquierda a derecha, es decir,
en la siguiente expresi¢n:

  {8/2*2}

Se ejecutar  primero la divisi¢n y despu‚s la multiplicaci¢n (que es la forma
natural de evaluar las expresiones en matem ticas).

La £nica excepci¢n son los operadores de {prioridad 9} (operadores de {asignaci¢n}),
que ser n evaluados de derecha a izquierda (en lugar de izquierda a derecha), es
decir, en la expresi¢n:

  {x=y=0}

Primero, se procesar  {y=0} (se pondr  {y} a {0}) y, despu‚s, {x=y} (tambi‚n se
pondr  {x} a {0}, ya que {y} ahora valdr  {0}).

Como se puede observar las asignaciones funcionan a modo de operador
devolviendo, tras realizar la asignaci¢n, el valor que han asignado como
resultado de la operaci¢n.

{/}Ver: {#1000,Sintaxis} - {#1035,Definici¢n de una expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1037,Definici¢n de una condici¢n}

Las condiciones son expresiones que normalmente son como las siguientes:

  {x<320}ú
  {size==100 AND graph>10}ú
  {y==0 OR (x>=100 AND x<=200)}ú
  ...

En general, cualquier expresi¢n es v lida como condici¢n. En el lenguaje
se interpretan todas las expresiones {IMPARES} como {ciertas} y todas las {PARES}
como {falsas}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    IF (20*2+1)
        x=x+1;
    END
END
{-}

En este ejemplo la sentencia {x=x+1;} se ejecutar  siempre, pues la expresi¢n
{20*2+1} vale {41}, que es un n£mero {impar}. Todos los operadores disponibles
son v lidos dentro de una condici¢n.

Todos los {#1039,c¢digos identificadores} de procesos son n£meros {impares},
es decir, todos son {ciertos}. Es posible, por tanto, implementar condiciones
como la siguiente (suponiendo que {id2} se haya declarado como variable,
y {disparo} es un tipo de proceso del programa).

  {id2=get_id(type disparo);}ú
  {WHILE (id2)}ú
      {id2.size=id2.size-1;}ú
      {id2=get_id(type disparo);}ú
  {END}

En la condici¢n {(id2)} se comprueba si la funci¢n {get_id()} ha devuelto
un {#1039,c¢digo identificador}, pues ‚ste ser  siempre un n£mero {impar} y la condici¢n ser  evaluada
como {cierta} (si {get_id()} no encuentra (m s) identificadores de procesos
"tipo {disparo}", entonces devolver  {0} (que es un n£mero {par})
interpret ndose la condici¢n como {falsa}, y terminando la sentencia {#1022,WHILE}.

Las sentencias anteriores decrementar¡an la variable {#1128,size} (tama¤o) de todos
los procesos de tipo {disparo} que hubiera en el programa.

{/}Ver: {#1000,Sintaxis} - {#1035,Definici¢n de una expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1038,Formas de obtener el c¢digo identificador de un proceso}

Todos los procesos tienen su propio {#1039,c¢digo identificador} en {#1092,ID}
(palabra reservada en el lenguaje que equivale al {#1039,c¢digo identificador} del
proceso).

Cuando se crea un proceso (se llama), ‚ste devuelve como valor de retorno
su propio {#1039,c¢digo identificador}, a no ser que haya terminado con un
{#1028,RETURN}{#1053,(}<expresi¢n>{#1053,)}. Es decir, un proceso devolver 
su {#1039,c¢digo identificador} siempre que termine (llegue su {#1091,END}), ejecute
la sentencia {#1029,FRAME} o la sentencia {#1028,RETURN} sin expresi¢n
entre par‚ntesis.

En el siguiente ejemplo, desde el programa principal se crea un proceso
(de tipo {mi_proceso}) y se guarda su identificador en la variable {id2}.

{#9999,Ejemplo:}
PROGRAM mi_juego;
PRIVATE id2;
BEGIN
    id2=mi_proceso();
    // ...
END
PROCESS mi_proceso()
BEGIN
    // ...
END
{-}

Todos los procesos tienen predefinidas las siguientes variables locales
con indentificadores de otros procesos:

{#1117,father} - padre, identificador del proceso que lo cre¢ (el que hizo
la llamada).

{#1118,son} - hijo, identificador del £ltimo proceso creado por ‚ste (£ltimo
proceso al que se ha llamado).

{#1120,bigbro} - Hermano mayor, identificador del £ltimo proceso que cre¢
el padre antes de crear ‚ste.

{#1119,smallbro} - Hermano menor, identificador del siguiente proceso que
cre¢ el padre tras crear ‚ste.

Estas variables pueden valer {0} si no han sido definidas (por ejemplo
{#1118,son} valdr  {0} hasta que no se cree un proceso, o si ‚ste ya
ha desaparecido).

Los c¢digos identificadores de los procesos permiten acceder a las variables
locales del mismo (<identificador>.<variable>), y como {#1117,father},
{#1118,son}, etc., son, a su vez, variables locales se pueden realizar
combinaciones como {son.bigbro} para acceder al identificador del pen£ltimo
proceso creado (ya que {#1118,son} es el del £ltimo, por lo que su hermano mayor ser 
el pen£ltimo).

Hay otras formas de obtener c¢digos identificadores de procesos (adem s de
cuando se crean y por parentesco directo), como son:

- La funci¢n {#120,get_id()} para obtener los identificadores de los procesos
de un tipo determinado (nave, disparo, etc.) que existen en un determinado
momento del juego.

- La funci¢n {#104,collision()} para obtener los identificadores de los
procesos con los se est  chocando (colisionando).

Cuando un proceso determinado necesita acceder desde muchos otros, por
ser un proceso importante como, por ejemplo, la nave protagonista de un juego,
entonces puede ser m s £til asignar su identificador a una variable
{#1006,GLOBAL} del programa (que puede ser accedida por cualquier proceso
en cualquier punto).
De esta forma cualquier proceso podr  interactuar con ‚l, ya que tendr  su
identificador.

{#9999,Ejemplo:}
PROGRAM mi_juego;
GLOBAL
  id_nave;
BEGIN
    id_nave=nave();
    // ...
END
PROCESS nave()
BEGIN
    // ...
END
PROCESS enemigo()
BEGIN
    // ...
    id_nave.z=0;
    // ...
END
{-}

En este ejemplo los procesos de tipo {enemigo} acceden en un determinado
punto a la variable {z} de la {nave} que cre¢ el programa principal,
utilizando para ello su identificador que est  en la variable global {id_nave}.

{/}Ver: {#1039,C¢digos identificadores de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1039,C¢digos identificadores de procesos}

Un proceso es un objeto independiente del programa que ejecuta su propio
c¢digo y que puede tener sus propias coordenadas, gr ficos, etc., por ejemplo
pueden ser procesos de un programa: una nave, un disparo o un enemigo.

Cuando se pone dentro de un programa algo similar a esto:

{PROCESS disparo(}...{);}ú
{#1086,BEGIN}ú
   { // }sentencias{ ...}ú
{#1091,END}

Se est n especificando las sentencias que van a ejecutar los procesos
"de tipo {disparo}", es decir, el c¢digo que va a regir su comportamiento.

Como se puede observar puede haber en un programa m s de un proceso tipo
{disparo}, luego ¨c¢mo se diferencian unos de otros? Sencillamente, por
su c¢digo identificador.

Cada vez que en un juego se crea un nuevo proceso, a ‚ste le es asignado un
c¢digo identificador; este c¢digo va a ser la referencia exclusiva del
proceso hasta el momento en el que desaparezca.

Dos procesos diferentes no tendr n nunca el mismo c¢digo identificador a la vez;
sin embargo, el c¢digo que perteneci¢ a un proceso que ya ha desaparecido le puede
ser asignado a un nuevo proceso (algo as¡ como el n£mero del carnet de identidad).

Los c¢digo identificadores son siempre n£meros enteros positivos e impares,
como podr¡an ser 471, 1937 o 10823.

Todos los procesos tienen su propio c¢digo identificador en {#1092,ID}, que es
algo similar a una variable local del proceso, salvo que no puede modificarse.

Los procesos, adem s, tienen el c¢digo identificador del proceso que les
cre¢ (el que los llam¢) en {#1117,father} (padre), el del £ltimo proceso
que ellos crearon (el £ltimo que llamaron) en {#1118,son} (hijo), etc.
(ver {#1041,Jerarqu¡as de procesos}).

{¨Para qu‚ sirven los c¢digos identificadores?}{/}

Normalmente, todos los procesos necesitan el c¢digo identificador de los dem s
procesos para interactuar con ellos (ver donde est n, modificarlos, ...).

No se puede, por ejemplo, restarle energ¡a al proceso "tipo {enemigo}", pues
procesos de ese tipo pueden no existir ninguno o existir muchos; se necesita el
c¢digo identificador concreto del proceso {enemigo} al que se quiere restarle
energ¡a.

Un proceso accede a todas sus propias variables simplemente por sus nombres, como
{#1123,x}, {#1128,size} o {#1126,graph}. Pues bien, si se dispone del
identificador de un proceso (en {#1118,son}, {#1117,father} o cualquier
variable definida por el usuario, como {id2}) se puede, entonces, acceder
a las variables de dicho proceso como ({son.x}, {father.size} o {id2.graph}),
es decir, la sintaxis para acceder a variables locales de otro proceso es:

  <c¢digo_identificador> . <nombre_variable>

Pudi‚ndose utilizar dichas variables normalmente para consultarlas o modificarlas.

{No es posible en ning£n caso acceder a variables de tipo {#1008,PRIVATE} de
otro proceso}. Si se quiere acceder a una variable privada de otro proceso,
se debe cambiar la declaraci¢n de ‚sta a la secci¢n {#1007,LOCAL} para
convertirla en una variable local; entonces, cualquier proceso podr  acceder
a dicha variable teniendo el c¢digo identificador del proceso, ya que todos
los procesos poseer n dicha variable.

Los identificadores tienen m s usos que el acceso a variables locales ajenas,
como puede ser la funci¢n {#158,signal()} que puede enviar determinadas se¤ales
a un proceso si se dispone de su c¢digo identificador (por ejemplo, para
eliminar el proceso).

Tambi‚n hay otras funciones, como {#104,collision()}, para detectar colisiones
(choques) con otros procesos que, en caso de detectar una colisi¢n, devuelve
el c¢digo identificador del proceso con el cual se est  chocando. Una vez
se tiene dicho c¢digo, se puede acceder a las variables del proceso y enviarle
se¤ales.

La funci¢n {#120,get_id()} funciona de forma similar a {#104,collision()},
obteniendo el c¢digo identificador de un proceso, pero sin necesidad de que se
produzca una colisi¢n con ‚l.

{/}Ver: {#1038,Formas de obtener el c¢digo identificador de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1040,Estados de un proceso}

Los procesos son los diferentes elementos de un programa (objetos del juego);
‚stos pueden pasar por diferentes estados al crearse, destruirse o recibir
determinadas se¤ales por medio de la funci¢n {#158,signal()}.

proceso {vivo o despierto}

Si un proceso se est  ejecutando (est  interpretando las sentencias
comprendidas entre su {#1086,BEGIN} y su {#1091,END}) se dice que est 
vivo.

proceso {muerto}

Cuando un proceso finaliza (porque llega su {#1091,END} en la ejecuci¢n,
porque ejecute un {#1028,RETURN} o porque reciba una se¤al {#1153,s_kill} o
{#1157,s_kill_tree}) se dice que ha muerto.

proceso {dormido}

Un proceso puede recibir la se¤al {#1155,s_sleep} (o {#1159,s_sleep_tree}) y,
entonces, pasar  a estado dormido; en este estado el proceso se comporta como
si estuviera muerto, s¢lo que no lo est  pues, en cualquier momento, puede
recibir una se¤al {#1154,s_wakeup} y volver a estado vivo o despierto.
Tambi‚n se puede matar a un proceso que est  dormido.

proceso {congelado}

La se¤al {#1156,s_freeze} (o {#1160,s_freeze_tree}) pasa a estado congelado
un proceso. En este estado el proceso se queda inmovilizado, se sigue viendo
y el resto de los procesos lo pueden seguir detectando (en las colisiones,
por ejemplo), pero no se ejecuta (deja de interpretar sus sentencias de
c¢digo). Estar  en este estado hasta que reciba otra se¤al que le cambie
de estado o lo mate.

Un proceso congelado puede ser controlado (movido) por otro proceso,
manipulando directamente sus variables.

{/}

Siempre que se env¡a una se¤al a un proceso con el fin de cambiarle de estado,
‚sta no tendr  efecto si el proceso se est  ejecutando hasta que llegue a
su pr¢xima visualizaci¢n ({#1029,FRAME}). Si el proceso no se estuviera ejecutando,
entonces la se¤al tendr¡a efecto de inmediato.

No se deben enviar se¤ales a procesos inexistentes (a un {#1039,c¢digo identificador}
que no se corresponda a ning£n proceso).

Si se intenta poner a un proceso en el estado en el que ya est , la se¤al
ser  ignorada.

{/}Ver: {#1041,Jerarqu¡as de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1041,Jerarqu¡as de procesos}

Un proceso es un objeto independiente del programa que ejecuta su propio
c¢digo y que puede tener sus propias coordenadas, gr ficos, etc., por ejemplo,
pueden ser procesos de un programa: una nave, un disparo o un enemigo.

Cuando un programa comienza a ejecutarse s¢lo existe un proceso; el proceso
inicial que es el que comienza a ejecutar las sentencias del c¢digo
principal, pero, a partir de entonces, ‚ste puede crear nuevos procesos
y ‚stos, a su vez, otros, destruirse procesos, etc.

Para aclarar los acontecimientos que van sucediendo en un programa se establece
un s¡mil, que es hablar de los procesos como si fueran seres vivos que nacen
y mueren (cuando se crean y destruyen). Por ello, se establecen los siguientes
t‚rminos:

{Padre}, denominaci¢n que se da al proceso que ha creado a otro (la verdad
es que se deber¡a haber llamado madre).

{Hijo}, el proceso que ha sido creado por otro.

{Hermanos}, procesos que han sido creados por el mismo padre.

{Hu‚rfano}, proceso cuyo padre ha muerto (ha sido eliminado o a finalizado).

Y esta jerga se puede extender hasta donde llegue la imaginaci¢n, {abuelos},
{nietos}, {t¡os}, etc.

Todos los procesos tienen acceso a los c¢digos identificadores de los
procesos con los que tienen parentesco directo (ver: {#1038,Formas de obtener
el {#1039,c¢digo identificador} de un proceso}.

En ocasiones, se hace referencia a acciones hechas por "{el sistema}"; este
proceso, denominado {div_main}, es el que controla al resto, por tanto es el
encargado de crear el proceso inicial al comienzo de la ejecuci¢n, de ajustar
la velocidad de ejecuci¢n, el trazador, etc. Todos los procesos que se
quedan hu‚rfanos pasan a ser hijos de este proceso.

El {identificador de div_main} se puede obtener con {#120,get_id(0)}. Puede
servir para enviar una se¤al en  rbol (tree) a todos los procesos,
pero dicho proceso no se visualizar  en pantalla aunque se definan sus
variables {#1123,x}, {#1124,y}, {#1126,graph}, etc.

{/}Ver: {#1040,Estados de un proceso}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1042,Tipos de procesos}

Los bloques de los programas que comienzan con la palabra reservada {#1016,PROCESS}
determinan el comportamiento de un tipo concreto de proceso. Despu‚s, cuando
se ejecute el programa podr  haber cualquier n£mero de procesos de dicho
tipo en un momento determinado, cada uno con un {#1039,c¢digo identificador}
diferente pero todos del mismo tipo.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    // ...
END
PROCESS nave()
BEGIN
    // ...
END
PROCESS enemigo()
BEGIN
    // ...
END
PROCESS disparo()
BEGIN
    // ...
END
{-}

En este ejemplo se definen cuatro tipos de procesos, {mi_juego} (que ser 
el tipo del proceso inicial del programa}, {nave}, {enemigo} y {disparo}.

El n£mero de procesos de cada uno de estos tipos que haya despu‚s en el
juego depende del n£mero de llamadas que se realicen a dichos procesos.

Todos los procesos de tipo {nave} ejecutar n siempre las sentencias que
se definen en el bloque {PROCESS nave()} del programa.

Un "tipo de proceso" es un c¢digo num‚rico que hace referencia al
nombre que tiene el PROCESS que determina el comportamiento del
proceso durante el juego; este c¢digo num‚rico se puede
obtener con: {TYPE <nombre_del_proceso>}

{TYPE} es un operador definido en el lenguaje que, aplicado a un nombre de proceso,
devuelve este c¢digo num‚rico.

Por ejemplo, {TYPE nave} equivaldr  a una constante num‚rica determinada y
{TYPE enemigo} a otra.

Todos los procesos tienen una variable local que contiene este c¢digo num‚rico
y es: {reserved.process_type}.

{¨Para qu‚ sirve el tipo de un proceso?}{/}

El tipo de los procesos se emplea para varias cosas, por ejemplo:

- Para la funci¢n {#120,get_id()} que recibe como par metro un tipo de proceso
(por ejemplo, {get_id(TYPE enemigo)}) y devuelve los c¢digos identificadores
de los procesos de dicho tipo que existan en el juego en ese momento.

- Para la funci¢n {#104,collision()} es similar a la anterior s¢lo que devuelve
los c¢digos identificadores de los procesos con los que se est‚ colisionado
(chocando, es decir, que los gr ficos de ambos procesos est‚n parcialmente
superpuestos).

- Para la funci¢n {#158,signal()} que puede enviar una se¤al a todos los
procesos que existan de un tipo determinado.

- O bien para, a partir de un {#1039,c¢digo identificador} de un proceso, poder comprobar
de qu‚ tipo de proceso se trata (si es de tipo nave, de tipo disparo, etc.).

{/}

El operador TYPE puede utilizarse £nicamente precediendo a un nombre de
proceso del programa o a la palabra {mouse}, para la detecci¢n de colisiones
con el puntero del rat¢n (con {collision(TYPE mouse)}).

{/}Ver: {#1039,C¢digos identificadores de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1043,Sentencia FROM}

{FROM} <variable>{#1073,=}{#1005,<constante>} {#1096,TO} {#1005,<constante>}{#1068,;}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

(o bien)

{FROM} <variable>{#1073,=}{#1005,<constante>} {#1096,TO} {#1005,<constante>} {#1095,STEP} {#1005,<constante>}{#1068,;}ú
    {#1017,<sentencia>} {#1068,;}ú
    ...ú
{#1091,END}

La sentencia {FROM} es una sentencia que implementa un {bucle}, es decir, que
es capaz de {repetir un grupo de sentencias un n£mero determinado de veces}.

Para implementar este bucle se necesita una variable {#1006,GLOBAL}, {#1007,LOCAL} o
{#1008,PRIVATE} del propio proceso que sirva como contador del bucle.

Antes de las sentencias que conformar n el grupo interior de sentencias se
debe poner la palabra reservada {FROM} seguida del {nombre de la variable contador},
el s¡mbolo de asignaci¢n ({#1073,=}), el {valor inicial} de la variable, la
palabra reservada {#1096,TO} y, finalmente, el {valor final} de la variable.
Tras esta declaraci¢n del bucle {FROM} se debe poner el s¡mbolo {#1068,;}
(punto y coma).

Despu‚s de esta cabecera definiendo las condiciones del bucle vendr 
el grupo interior de sentencias que se pretende repetir un n£mero
determinado de veces y, al final, la palabra reservada {#1091,END}.

Se denomina {iteraci¢n} del bucle el n£mero de veces que se ejecuta el grupo
interior de sentencias.

La primera iteraci¢n se har  con el {valor incial}
en la variable usada como contador, tras esta iteraci¢n se le {sumar  1}
a esta variable (si el valor inicial {es menor} que el valor final)
o se le {restar  1} (en caso contrario). Tras actualizar el valor
de la variable, se pasar  a la siguiente iteraci¢n siempre que el
valor de dicha variable no haya llegado (o sobrepasado) el {valor
final} del bucle.

Como segunda acepci¢n de la sentencia {FROM} se puede poner tras los valores
inicial y final de la sentencia la palabra reservada {#1095,STEP} seguida de un
{valor constante} que indique el incremento de la variable contador tras
cada iteraci¢n del bucle, en lugar de {1} o{ -1}, que son los incrementos
que se har n por defecto si se omite la declaraci¢n {#1095,STEP} (paso).

A continuaci¢n, se muestra un programa con dos bucles {FROM}, uno sin declaraci¢n
{#1095,STEP} (con incremento o decremento por defecto) y otro con ella.

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FROM x=9 TO 0;
        // sentencias interiores ...
    END
    FROM x=0 TO 9 STEP 2;
        // Sentencias interiores ...
    END
END
{-}

El primer bucle se ejecutar  {10} veces con la variable {x} valiendo
desde {9} hasta {0} en las diferentes iteraciones; por defecto, se le resta
uno a la variable cada vez, ya que el valor inicial (9) es mayor que
el valor final (0).

En el segundo, se indica como incremento de la variable la constante {2},
por lo que el bucle se ejecutar  {5} veces con la variable {x} valiendo
{0}, {2}, {4}, {6} y {8}, respectivamente, en las sucesivas iteraciones.
Como se puede observar no se har  ninguna iteraci¢n con {x} valiendo {9},
aunque ‚ste sea el {valor final} del bucle.

Por defecto, si no se hubiera especificado como {#1095,STEP} (paso) del bucle {2},
se le habr¡a sumado {1} a la variable {x} tras cada iteraci¢n.

Un bucle {FROM} siempre se puede realizar tambi‚n con la sentencia {#1025,FOR},
como se muestra a continuaci¢n (con dos bucles equivalentes a los del
ejemplo anterior).

{#9999,Ejemplo:}
PROGRAM mi_juego;
BEGIN
    FOR ( x=9 ; x>=0 ; x=x-1 )
        // Sentencias interiores ...
    END
    FOR ( x=0 ; x<=9 ; x=x+2 )
        // Sentencias interiores ...
    END
END
{-}

Los valores {inicial} y {final} de un bucle {FROM} deben ser diferentes.

Si el valor inicial {es menor} que el valor final, no se puede
especificar un valor negativo en la declaraci¢n {#1095,STEP}.

Si el valor inicial {es mayor} que el valor final, no se puede
especificar un valor positivo en la declaraci¢n {#1095,STEP}.

Una sentencia {#1026,BREAK} dentro de un bucle {FROM} lo finalizar  de forma
inmediata, continuando el programa por la sentencia siguiente a dicho bucle
(tras el {#1091,END}).

Una sentencia {#1027,CONTINUE} dentro de un bucle {FROM} forzar  al programa a
incrementar inmediatamente la variable usada como contador y, despu‚s,
si no se ha sobrepasado el valor final, comenzar con la siguiente iteraci¢n.

Las sentencias interiores a un bucle {FROM} pueden ser tantas como se
quiera y de cualquier tipo, incluyendo, por supuesto, nuevos bucles {FROM}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1044,Uso de  ngulos en el lenguaje}

Todos los  ngulos se especifican en el lenguaje en mil‚simas de grado.
Por ejemplo:

  {0} es {0 grados} (hacia la derecha)ú
  {90000} son {90 grados} (hacia arriba)ú
 { -45000} son{ -45 grados} (diagonal abajo derecha)ú

Si a cualquier  ngulo se le suman o restan {360 grados} (360000) se
obtiene un  ngulo equivalente. Por ejemplo, los  ngulos -90000 y
270000 son equivalentes (los  ngulos de{ -90 grados} y {270 grados}
son ambos hacia abajo)

Se puede utilizar como referencia la constante {#1179,PI} predefinida como {180000},
{3.1415 radianes} o, lo que es lo mismo, {180 grados}. Por ejemplo {PI/2}
equivaldr  a 90 grados (90000).

Algunas de las funciones para el manejo de  ngulos son las siguientes:

  {#116,get_angle()}ú
  {#118,get_distx()}ú
  {#119,get_disty()}ú
  {#113,fget_angle()}ú
  {#142,near_angle()}ú
  {#101,advance()}ú
  {#183,xadvance()}ú

Todos los procesos tienen una variable local predefinida denominada {angle}
que, por defecto, valdr  {0}; si se modifica su valor se cambiar  el  ngulo
de visualizaci¢n del gr fico del proceso (se rotar  el gr fico en los grados
indicados, a partir del gr fico original).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1045,NOT  !}

Operador unario de {negaci¢n} l¢gica y binaria utilizado en expresiones y
condiciones.

La palabra reservada {NOT} y el s¡mbolo {!} son sin¢nimos.

{NOT l¢gico:} Si el operando es {cierto}, al aplicarle este operador, se obtendr 
una expresi¢n {falsa} y viceversa.

  CIERTO  ->  FALSOú
  FALSO   ->  CIERTOú

{NOT binario:} Cambia todos los bit del operando, es decir, pasa los 0 a 1 y
los 1 a 0.

{/}

{Nota:} Este operador funciona indistintamente como l¢gico y binario debido
a que en el lenguaje se interpretan las expresiones l¢gicas {ciertas} como las
que tienen el £ltimo bit a 1 (el bit 0, de peso 1), es decir, los n£meros
impares (1, -1, 3, -3, ...), y como expresiones l¢gicas {falsas} las que
tienen el £ltimo bit a 0 (los n£meros pares: 0, 2, -2, 4, -4, ...).

Al cambiar el operador {NOT} todos los bit tambi‚n cambian
el £ltimo convirtiendo, de este modo, los n£meros pares en impares (expresiones
falsas en ciertas) e impares en pares (expresiones ciertas en falsas).

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1046,<>  !=}

Operador l¢gico [{distinto que}] utilizado en condiciones. Los s¡mbolos
{<>} y {!=} son sin¢nimos.

Debe utilizarse entre dos expresiones num‚ricas y devuelve un
resultado l¢gico:

{Falso} - Si ambas expresiones dan el mismo resultado (si son dos
expresiones equivalentes), pues NO son distintas.

{Cierto} - Si las expresiones dan resultados distintos, pues SI son distintas.

{Ejemplos:}

  {2+2 <> 4} devolver  {falso}.ú
  {0 <> -1}  devolver  {cierto}.ú

{/}Ver: {#1000,Sintaxis} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1047,"  '}

S¡mbolos delimitadores de literales.

Los literales son los {textos entre comillas} que pueden comenzar y terminar
con el car cter [{'}] o bien con el car cter [{"}] (deben comenzar y terminar
con el mismo car cter). Si se quiere incluir el car cter [{"}] en un literal, se puede
hacer de dos formas; sup¢ngase que se quiere definir un literal que contenga
el texto: a"B"c

 - Duplicar el car cter: "a""B""c"

 - Definirlo con la comilla simple: 'a"B"c'

Lo mismo sucede con el car cter [{'}], que se puede incluir en un literal
si se duplica, o bien si el literal se delimita con el car cter [{"}].

Todos los literales deben cerrarse en la misma l¡nea en la que comenzaron, no
pudi‚ndose definir literales de m s de una l¡nea.

{/}

{Literales de varias l¡neas.}

Es posible definir literales en varias l¡neas, para ello s¡mplemente deber  dividirse el
texto en varios, y ponerse estos seguidos (sin separarse por ning£n s¡mbolo). Por
ejemplo, se podr¡a definir una constante como:

{saludo="­Ho"}ú
{       "la!";}

Esto podr¡a utilizarse tambi‚n para inicializar los datos de tipo {#1406,STRING}.
No hay l¡mite en el n£mero de l¡neas. Entre dos literales seguidos £nicamente
podr¡an aparecer {#1002,comentarios explicativos}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1048,MOD  %}

Operador aritm‚tico de {m¢dulo} o {resto de una divisi¢n} entera. La palabra
reservada {MOD} y el s¡mbolo{ %} son sin¢nimos.

Este operador se utiliza en las {#1035,expresiones aritm‚ticas} entre dos
operandos, para obtener el m¢dulo del primero partido por el segundo.

Por ejemplo {7 MOD 3} devolver  1, ya que al realizar la divisi¢n entera de 7
entre 3 se obtiene 2 como cociente y {1} como {resto}.

Es decir, que {n MOD m} siempre devolver  un n£mero dentro del rango (0..m-1).

Para comprender de forma sencilla c¢mo obtener el resto de una operaci¢n
{n MOD m} se pueden seguir los siguientes pasos:

{Paso 1} - Si {n} es menor que {m}, el resultado de la operaci¢n {MOD} es {n}.

{Paso 2} - (Cuando {n} es mayor o igual que {m}) se le resta {m} a {n} y se
vuelve al {paso 1}.

{/}

{Uso:} Este operador se utiliza en ocasiones en los programas en los que
se requiere que una variable contador var¡e entre {0} y {otro n£mero}
siempre; si se quiere, por ejemplo, que la variable {x} var¡e
entre 0 y 319 indefinidamente (x=0, x=1, x=2, ..., x=319, x=0, x=1, ...)
se podr¡a optar por lo siguiente:

  {x=0;}ú
  {LOOP}ú
  {    x=x+1;}ú
  {    IF (x==320) x=0;}ú
  {    // ...}ú
  {END}ú

Pero muchos programas sustituyen estas sentencias por las siguientes:

  {x=0;}ú
  {LOOP}ú
  {    x=(x+1) MOD 320;}ú
  {    // ...}ú
  {END}ú

que realizan exactamente la misma funci¢n, ya que el operador {MOD} truncar 
la expresi¢n cuando sea mayor o igual que 320 a un valor menor.

{/}

El {cociente} de una divisi¢n entera se obtiene con el operador {#1065,/}
(divisi¢n).

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1049,%=}

Asignaci¢n operativa. Operaci¢n de {m¢dulo} o {resto de divisi¢n} entera.

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo {%=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato el {m¢dulo} o {resto de la divisi¢n} siguiente:

  [{valor_anterior_del_dato}] / [{resultado_de_la_expresi¢n}]

Ejemplo: {x=3; x%=2;} -> (x=1)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C},
en cualquier caso una sentencia del tipo {n %= m;} ser  equivalente a
‚sta otra {n = n MOD m;}.

Ver el operador {#1048,MOD} para m s informaci¢n sobre el {m¢dulo}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1050,&}

S¡mbolo bifuncional que tiene dos usos diferentes seg£n se utilice como
un operador unario o binario.

Un operador {UNARIO} aparece dentro de una expresi¢n precediendo,
simplemente, a un operando (como si fuera el signo de ‚ste); en este caso
el operador{ &} ser  un sin¢nimo de {#1085,OFFSET}.

{Ejemplo: &x} es equivalente a {OFFSET x}

Un operador {BINARIO} aparece dentro de una expresi¢n concatenando
a dos operandos (indicando una operaci¢n entre ambos), en este caso el
operador{ &} ser  un sin¢nimo de {#1051,AND}.

{Ejemplo: x&2} es equivalente a {x AND 2}

{/}Ver: {#1000,Sintaxis} - {#1085,OFFSET} - {#1051,AND}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1051,AND  &&}

Operador binario del {producto l¢gico} utilizado en expresiones y
condiciones.

La palabra reservada {AND} y el s¡mbolo{ &&} son sin¢nimos.

{AND l¢gico:} Se eval£an, primero, las condiciones de la derecha e izquierda
del operador y, si ambas son {ciertas}, este operador devolver  {cierto},
en caso contrario el operador devolver  siempre {falso}.

  FALSO  AND FALSO  = FALSOú
  FALSO  AND CIERTO = FALSOú
  CIERTO AND FALSO  = FALSOú
  CIERTO AND CIERTO = CIERTOú

Se utiliza para comprobar que se cumplan obligatoriamente m s de una condici¢n,
por ejemplo:

  {(x>0 AND x<100)}

Para comprobar que la variable sea mayor que 0 {Y} que sea menor que 100.

{AND binario:} Eval£a los bit de los resultados de las expresiones anterior
y posterior al operador generando, como resultado, un valor que tendr  a uno
£nicamente los bit que tuvieran a uno ambas expresiones.

  0 AND 0 = 0ú
  0 AND 1 = 0ú
  1 AND 0 = 0ú
  1 AND 1 = 1ú

Esta regla se aplicar  a todos los bits de los operandos (en el lenguaje
son enteros de 32 bits).

{/}

{Nota:} Este operador funciona indistintamente como l¢gico y binario debido
a que en el lenguaje se interpretan las expresiones l¢gicas {ciertas} como las
que tienen el £ltimo bit a 1 (el bit 0, de peso 1), es decir, los n£meros
impares (1, -1, 3, -3, ... ), y como expresiones l¢gicas {falsas} las que
tienen el £ltimo bit a 0 (los n£meros pares: 0, 2, -2, 4, -4, ...).

El operador {AND} £nicamente dejar  a 1 el £ltimo bit (s¢lo devolver  {cierto}
como resultado} cuando lo tuvieran a 1 ambos operandos (cuando los dos fueran
expresiones {ciertas}).

{/}

{Nota:} El s¡mbolo{ &} tambi‚n puede utlizarse como un sin¢nimo m s de
{AND} y{ &&}.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1052,&=}

Asignaci¢n operativa. Operaci¢n binaria de {producto l¢gico} ({AND}).

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo {&=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato el {producto l¢gico} siguiente:

  [{valor_anterior_del_dato}] AND [{resultado_de_la_expresi¢n}]

Ejemplo: {x=5; x&=6;} -> (x=4)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C};
en cualquier caso, una sentencia del tipo {n &= m;} ser  equivalente a
esta otra {n = n AND m;}.

Ver el operador {#1051,AND} para m s informaci¢n sobre el {producto l¢gico}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1053,(  )}

Los s¡mbolos {(} y {)}, denominados par‚ntesis, deben aparecer siempre
emparejados y en este mismo orden.

Se utilizan para delimitar determinados c lculos, par metros o condiciones
de los programas, marcando el inicio de los mismos con el s¡mbolo {(} y
el final con el s¡mbolo {)}.

{/}

Dentro de una expresi¢n indican que el c lculo de su interior se
debe realizar antes que el de su exterior.

Por ejemplo, la expresi¢n {2*3+2} se evaluar  como {8}, ya que primero
se realizar  la multiplicaci¢n (2 por 3, que es 6) y despu‚s la suma
(6 m s 2, que da como resultado 8).

Utilizando par‚ntesis se puede forzar a que se realice la suma en primer lugar,
expresando el c lculo como {2*(3+2)}, que ser  evaluado como {10}, ya que
ahora se realizar  primero la suma (3 m s 2, que es 5) y despu‚s la
multiplicaci¢n (2 por 5, que es 10).

{/}

Los par‚ntesis tambi‚n se utilizan para delimitar los par metros de llamada
de los procesos o las funciones y dentro de la
sintaxis de diferentes sentencias del lenguaje.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1054,*}

Operador aritm‚tico de {multiplicaci¢n} entera. Este operador se utiliza en las
{#1035,expresiones aritm‚ticas} entre dos operandos, para obtener como resultado
su producto (la multiplicaci¢n).

Por ejemplo {2 * 8} devolver  {16}, {99 * 0} devolver  {0}, {2 * -1}
devolver { -2}, etc.

Todas las variables son {enteros} con signo de 32 bit en el lenguaje.
Por lo tanto, £nicamente se pueden manejar n£meros enteros dentro del rango
({#1177,min_int} ... {#1178,max_int})} por lo que, cuando el resultado de
la {multiplicaci¢n} deba exceder dicho rango, {se mostrar n resultados
incorrectos}. En este caso, el sistema no advertir  de ning£n error, de ah¡
que se deban extremar las precauciones.

{/}

Este s¡mbolo es bifuncional, es decir, tiene dos usos diferentes seg£n
se utilice como un operador unario o binario.

Un operador {UNARIO} aparece dentro de una expresi¢n precediendo
simplemente a un operando (como si fuera el signo de ‚ste); en este caso
el operador {*} ser  un sin¢nimo de {#1079,^}.

{Ejemplo: *x} es equivalente a {^x}.

Un operador {BINARIO} aparece dentro de una expresi¢n concatenando
a dos operandos (indicando una operaci¢n entre ambos), en cuyo caso el
operador {*} ser  el operador aritm‚tico de {multiplicaci¢n} explicado
anteriormente.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1079,^}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1055,*=}

Asignaci¢n operativa. Operaci¢n aritm‚tica de {multiplicaci¢n}.

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo {*=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato la {multiplicaci¢n} siguiente:

  [{valor_anterior_del_dato}] * [{resultado_de_la_expresi¢n}]

Ejemplo: {x=2; x*=3;} -> (x=6)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C},
en cualquier caso una sentencia del tipo {n *= m;} ser  equivalente a
esta otra {n = n * m;}.

Ver el operador {#1054,*} para m s informaci¢n sobre la {multiplicaci¢n}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1056,+}

Operador aritm‚tico de {suma}. Este operador se utiliza en las
{#1035,expresiones aritm‚ticas} entre dos operandos, para obtener su suma.

Por ejemplo {2 + 6} devolver  8, la suma de 2 m s 6.

Todas las variables son {enteros} con signo de 32 bits en el lenguaje.
Luego, £nicamente se pueden manejar n£meros enteros dentro del rango
({#1177,min_int} ... {#1178,max_int})}, por lo que cuando el resultado de
la {suma} deba exceder dicho rango, {se mostrar n resultados
incorrectos}. En este caso, el sistema no advertir  de ning£n error, de ah¡
que deban extremarse las precauciones.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1057,++}

Operador de incremento, este operador, derivado del lenguaje C, permite
incrementar el valor de un dato (sumarle 1) sin requerir, para ello, una
{#1019,sentencia de asignaci¢n}.

El dato puede ser una variable, una {posici¢n de una tabla}, o bien un
{campo de una estructura}.

Este operador se puede incluir dentro de una expresi¢n en dos modalidades:
{preincremento} y {postincremento}.

{Operador de preincremento}

Cuando se ponga el s¡mbolo { ++} justo delante de un dato, se le sumar  1
al mismo {antes de ejecutar la sentencia}, por ejemplo, v‚anse las siguientes
sentencias:

{ ++x;} - sentencia que sumar  1 a la variable {x}.

{ z=++x+y;} - sentencia que sumar  1 a la variable {x} y, despu‚s, asignar 
a la variable {z} la suma de {x} (ya incrementada) e {y}.

{Operador de postincremento}

Cuando se ponga el s¡mbolo{ ++} justo detr s de un dato, se le sumar  1 al
mismo {tras ejecutar la sentencia}, por ejemplo, v‚anse las siguientes
sentencias:

{ x++;} - sentencia que sumar  1 a la variable {x}.

{ z=x+y++;} - sentencia que asignar  la suma de {x} m s {y} a la variable {z},
y, despu‚s, incrementar  la variable {y}.

{/}

{Resumen:}

En general, una sentencia del tipo{ ++dato;} o {dato++;} es siempre equivalente
a la siguiente sentencia: {dato=dato+1;} (o bien {dato+=1;}).

La diferencia entre el {preincremento} y el {postincremento} es que en el primero se
toma el valor del dato ya incrementado para evaluar el resto de la expresi¢n,
mientras que en el segundo se eval£a la expresi¢n con el valor que ten¡a el dato antes de
ser incrementado.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1061,Decremento(--)}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1058,+=}

Asignaci¢n operativa. Operaci¢n aritm‚tica de {suma}.

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ +=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato la {suma} siguiente:

  [{valor_anterior_del_dato}] + [{resultado_de_la_expresi¢n}]

Ejemplo: {x=2; x+=2;} -> (x=4)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C},
en cualquier caso una sentencia del tipo {n += m;} ser  equivalente a
esta otra {n = n + m;}.

Ver el operador {#1056,+} para m s informaci¢n sobre la {suma}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1059,,}

El s¡mbolo de la coma ( {,} ) se utiliza dentro del lenguaje de programaci¢n,
en diferentes puntos de un programa, {para separar} dos elementos consecutivos
de una lista.

Se utiliza, por ejemplo, en los siguientes puntos:

- En las {#1013,listas de constantes} para separar los diferentes valores
num‚ricos de las mismas.

- En la definici¢n de los {#1018,par metros de un proceso} para separar
los nombres de los diferentes par metros.

- En la {#1033,llamada a un proceso}
para separar las diferentes expresiones que ser n asignadas a
los p rametros.

- En la {#1025,sentencia FOR} para separar diferentes inicializaciones,
condiciones o incrementos.

- En la {#1021,sentencia SWITCH} para definir los diferentes valores
aceptados en un bloque {CASE ... END}.

{/}

El s¡mbolo de la coma se puede utilizar tambi‚n para separar varias
{#1009,declaraciones de datos}, en lugar de finalizar cada una de ellas
con un s¡mbolo {punto y coma} ({#1068,;}).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1060,-}

Operador aritm‚tico de {resta}. Este operador se utiliza en las
{#1035,expresiones aritm‚ticas} entre dos operandos para obtener su suma.

Por ejemplo {2 - 6} devolver  -4, el resultado de restarle 6 a 2.

Todas las variables son {enteros} con signo de 32 bits en el lenguaje.
Por ello, £nicamente se pueden manejar n£meros enteros dentro del rango
({#1177,min_int} ... {#1178,max_int})}, por lo que cuando el resultado de
la {resta} deba exceder dicho rango, {se mostrar n resultados
incorrectos}. En este caso, el sistema no advertir  de ning£n error, con
lo que se deben extremar las precauciones.

{/}

Este s¡mbolo es bifuncional, es decir, tiene dos usos diferentes seg£n
se utilice como un operador unario o binario.

Un operador {UNARIO} aparece dentro de una expresi¢n precediendo
simplemente a un operando, este caso el operador{ -} ser  el {signo menos}.

{Ejemplo: -7} el n£mero entero negativo {menos siete}.

Un operador {BINARIO} aparece dentro de una expresi¢n concatenando
a dos operandos (indicando una operaci¢n entre ambos); en este caso el
operador{ -} ser  el operador aritm‚tico de {resta} explicado anteriormente.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1061,--}

Operador de decremento, este operador, derivado del lenguaje C, permite
decrementar el valor de un dato (restarle 1), sin requerir para ello una
{#1019,sentencia de asignaci¢n}.

El dato puede ser una variable, una {posici¢n de una tabla}, o bien un
{campo de una estructura}.

Este operador se puede incluir dentro de una expresi¢n en dos modalidades:
{predecremento} y {postdecremento}.

{Operador de predecremento}

Cuando se ponga el s¡mbolo{ --} justo delante de un dato, se le restar  1
al mismo {antes de ejecutar la sentencia}, por ejemplo, v‚anse las siguientes
sentencias:

{ --x;} - sentencia que restar  1 a la variable {x}.

{ z=--x+y;} - sentencia que restar  1 a la variable {x} y despu‚s asignar 
a la variable {z} la suma de {x} (ya decrementada) e {y}.

{Operador de postdecremento}

Cuando se ponga el s¡mbolo{ --} justo detr s de un dato, se le restar  1 al
mismo {tras ejecutar la sentencia}, por ejemplo, v‚anse las siguientes
sentencias:

{ x--;} - sentencia que restar  1 a la variable {x}.

{ z=x+y--;} - sentencia que asignar  la suma de {x} m s {y} a la variable {z},
y despu‚s decrementar  la variable {y}.

{/}

{Resumen:}

En general, una sentencia del tipo{ --dato;} o {dato--;} siempre equivalente
a la siguiente sentencia: {dato=dato-1;} (o bien {dato-=1;}).

La diferencia entre el {predecremento} y el {postdecremento} es que en el primero se
toma el valor del dato ya decrementado para evaluar el resto de la expresi¢n,
y en el segundo se eval£a la expresi¢n con el valor que ten¡a el dato antes de
ser decrementado.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1057,Incremento(++)}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1062,-=}

Asignaci¢n operativa. Operaci¢n aritm‚tica de {resta}.

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ -=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato la {resta} siguiente:

  [{valor_anterior_del_dato}] - [{resultado_de_la_expresi¢n}]

Ejemplo: {x=4; x-=2;} -> (x=2)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C};
en cualquier caso una sentencia del tipo {n -= m;} ser  equivalente a
esta otra {n = n - m;}.

Ver el operador{#1060, -} para m s informaci¢n sobre la {resta}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1063,.  ->}

Operador de acceso a estructuras o datos locales ajenos. Los s¡mbolos{ .} y{ ->}
son sin¢nimos, por lo que pueden ser usados indistintamente.

{/}

{Acceso a estructuras}

Para acceder a un campo de una estructura se debe utilizar este operador
de la siguiente forma:

<nombre de la estructura>{[}<n§ registro>{]}{ . }<nombre del campo>

(o bien, utilizando el otro s¡mbolo)

<nombre de la estructura>{[}<n§ registro>{]}{ -> }<nombre del campo>

{Ejemplos:}ú
  {scroll[0].camera}ú
  {m7[1]->z}ú

{Nota:} Se recuerda que el n£mero de registro entre corchetes se puede omitir
cuando se acceda al registro n£mero 0, por ejemplo {scroll[0].camera} equivaldr 
siempre a {scroll.camera}.

{/}

{Acceso a datos locales ajenos (de otro proceso)}

Para acceder a un dato {#1007,LOCAL} de un proceso desde otro, se debe
tener el {#1039,c¢digo identificador} del proceso del cual se quiere leer
o modificar su dato, entonces se podr  acceder al mismo de la siguiente forma:

<c¢digo identificador>{ . }<nombre dato local>

(o bien, utilizando el otro s¡mbolo)

<c¢digo identificador>{ -> }<nombre dato local>

{Ejemplos:}ú
   {father.x}ú
   {son->graph}ú

{/}Ver: {#1012,Declaraci¢n de una estructura} - {#1039,C¢digos identificadores} - {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1064,..}

{Rango de valores de una secci¢n CASE}{/}

El s¡mbolo{ ..} (doble punto) se utiliza para definir un rango de valores,
es decir, para expresar el conjunto de n£meros comprendidos entre dos valores
(incluyendo ‚stos).

Este s¡mbolo se utiliza {£nicamente en las sentencias} {#1021,SWITCH}, dentro
de las {secciones CASE}, para especificar un rango de valores.

Resulta indiferente expresar un rango como {m¡nimo..m ximo} o como {m ximo..m¡nimo}.

Por ejemplo, el rango definido con{ -2 .. 1} ser¡an los n£meros{ -2},{ -1}, {0} y {1}.

{/}Ver: {#1000,Sintaxis} - {#1021,sentencia SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1065,/}

Operador aritm‚tico de {divisi¢n} entera. Este operador se utiliza en las
{#1035,expresiones aritm‚ticas} entre dos operandos, para obtener el cociente
del primero partido por el segundo.

Por ejemplo {7 / 3} devolver  2, ya que al realizar la divisi¢n entera de 7
entre 3 se obtiene {2} como {cociente} (y 1 como resto).

Es decir, que {n / m} siempre devolver  el resultado de la divisi¢n
de {n} entre {m}, pero sin decimales (ya que todas las variables son
{enteros} con signo de 32 bits en el lenguaje).

{/}

El {resto} de una divisi¢n entera se obtiene con el operador {#1048,MOD}
(m¢dulo).

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1066,/=}

Asignaci¢n operativa. Operaci¢n de {divisi¢n entera} (cociente).

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ /=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato el {resultado entero} (cociente) de la {divisi¢n} siguiente:

  [{valor_anterior_del_dato}] / [{resultado_de_la_expresi¢n}]

Ejemplo: {x=8; x/=2;} -> (x=4)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C},
en cualquier caso una sentencia del tipo {n /= m;} ser  equivalente a
esta otra {n = n / m;}.

Ver el operador {#1065,/} para m s informaci¢n sobre la {divisi¢n entera}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1067,:}

El s¡mbolo {:} (dos puntos) se utiliza para finalizar una declaraci¢n
{#1087,CASE} o una declaraci¢n {#1088,DEFAULT} de una {#1021,sentencia SWITCH}.

En realidad, los s¡mbolos {:} (dos puntos) y {;} (punto y coma) son sin¢nimos
en este lenguaje, es decir, que es indiferente utilizar uno u otro.

A£n as¡, por similitud a otros lenguajes de programaci¢n se utiliza, normalmente,
el s¡mbolo {punto y coma} como terminador de sentencias y el s¡mbolo {dos puntos}
dentro de la sintaxis de la {#1021,sentencia SWITCH}.

{/}Ver: {#1000,Sintaxis} - {#1087,CASE} -  {#1088,DEFAULT} - {#1021,sentencia SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1068,;}

El s¡mbolo {;} (punto y coma) se utiliza en m£ltiples puntos de un programa
para indicar, siempre, que finaliza una sentencia o alg£n tipo de declaraci¢n.
Es lo que se denomina un s¡mbolo {terminador} que tiene, como £nico fin marcar el
final de algo.

En el lenguaje se deben indicar con punto y coma los siguientes
puntos del programa:

- El final de la {#1003,declaraci¢n PROGRAM}.

- El final de una {#1009,declaraci¢n de un dato}.

- El final de una {#1014,declaraci¢n IMPORT}.

- El final de las siguientes sentencias:ú
    {#1019,Asignaciones o incrementos de datos}.ú
    {#1033,Llamadas a procesos}.ú
    {#1032,Llamadas a funciones}.ú
    {#1029,FRAME}, {#1028,RETURN}, {#1031,DEBUG}, {#1026,BREAK} y {#1027,CONTINUE}.ú

- El final de un inicio de bucle {#1043,FROM}.

- Y como separador de las diferentes partes de una sentencia {#1025,FOR}.

El compilador indicar  cuando falte el s¡mbolo {;} en cualquiera de estos
puntos.

Pudiendo, adem s, ponerse dicho s¡mbolo en otros puntos determinados de los
programas, como detr s de cualquier otro tipo de sentencia, aunque en este
caso ser  opcional y, por tanto, el compilador no advertir  de su ausencia.

{/}

En realidad los s¡mbolos {;} (punto y coma) y {:} (dos puntos) son sin¢nimos
en este lenguaje, es decir, que es indiferente utilizar uno u otro.

A£n as¡, por similitud a otros lenguajes de programaci¢n se utiliza, normalmente,
el s¡mbolo {punto y coma} como terminador de sentencias y el s¡mbolo {dos puntos}
dentro de la sintaxis de la {#1021,sentencia SWITCH}.

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1069,<}

Operador l¢gico [{menor que}] utilizado en condiciones. Debe utilizarse entre
dos expresiones num‚ricas y devuelve un resultado l¢gico:

{Falso} - Si la primera expresi¢n NO es menor que la segunda.

{Cierto} - Si la primera expresi¢n SI es menor que la segunda.

{Ejemplos:}

  {2+2 < 4} devolver  {falso}.ú
  {1 < 2}   devolver  {cierto}.ú

{/}Ver: {#1000,Sintaxis} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1070,<<}

Operador binario de {rotaci¢n a la izquierda}. Este operador se utiliza en las
{#1035,expresiones aritm‚ticas}, entre dos operandos, para obtener el resultado
de rotar el primer operando a la izquierda el n£mero de veces que indique
el segundo. Por ejemplo, la siguiente rotaci¢n:

  {n} << {m}

Devolver  {n} rotado a la izquierda {m} veces; cada rotaci¢n a la izquierda
equivale a multiplicar por 2 el n£mero. Es decir, rotar a la izquierda 1
vez, equivale a multiplicar por 2, rotar a la izquierda 2 veces a multiplicar
por 4, 3 veces a multiplicar por 8, y, as¡, sucesivamente.

O lo que es equivalente (la {#145,funci¢n POW}{(2, m)} devuelve {2} elevado a {m}):

  {n} * POW(2, {m})

Por ejemplo, {2<<3} devolver  16, {4<<1} devolver  8, {100<<0} devolver  100, etc.

Todas las variables son {enteros} con signo de 32 bits en el lenguaje.
Por eso s¢lo se pueden manejar n£meros enteros dentro del rango
({#1177,min_int} ... {#1178,max_int})}, por lo que cuando el resultado de
la {rotaci¢n} deba exceder dicho rango, {se mostrar n resultados
incorrectos}. En este caso, el sistema no advertir  de ning£n error, por
lo que se deben extremar las precauciones.

{/}

El operador de rotaci¢n a la derecha (operaci¢n opuesta a ‚sta) es el
{#1077,s¡mbolo >>}.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1071,<<=}

Asignaci¢n operativa. Operaci¢n binaria de {rotaci¢n a la izquierda}.

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ <<=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato el resultado de la siguiente rotaci¢n:

  [{valor_anterior_del_dato}] << [{resultado_de_la_expresi¢n}]

O lo que es equivalente (la {#145,funci¢n POW}{(2, n)} devuelve {2} elevado a {n}):

  [{valor_anterior_del_dato}] * POW(2, [{resultado_de_la_expresi¢n}])

Es decir, si el resultado de la expresi¢n es:

  0 -> el dato mantendr  su valor.ú
  1 -> el dato ser  multiplicado por 2.ú
  2 -> el dato ser  multiplicado por 4.ú
  3 -> el dato ser  multiplicado por 8.ú
  ...

Ejemplo: {x=2; x<<=2;} -> (x=8)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C},
en cualquier caso una sentencia del tipo {n <<= m;} ser  equivalente a
esta otra {n = n << m;}.

Ver el operador {#1070,<<} para m s informaci¢n sobre la {rotaci¢n a la izquierda}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1072,<=  =<}

Operador l¢gico [{menor o igual que}] utilizado en condiciones. Los s¡mbolos
{<=} y {=<} son sin¢nimos.

Debe utilizarse entre dos expresiones num‚ricas y devuelve un
resultado l¢gico:

{Falso} - Si la primera expresi¢n NO es menor o igual que la segunda.

{Cierto} - Si la primera expresi¢n SI es menor o igual que la segunda.

{Ejemplos:}

  {2+2 <= 3} devolver  {falso}.ú
  {2+2 <= 4} devolver  {cierto}.ú

{/}Ver: {#1000,Sintaxis} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1073,=}

El s¡mbolo {=} (s¡mbolo de {asignaci¢n}) se utiliza en el lenguaje dentro
de las {#1009,declaraciones de datos} para inicializarlos, es decir, para
definir el valor inicial de los mismos y en las {#1019,sentencias de
asignaci¢n} para separar la referencia al dato, de la expresi¢n asignada.

Dentro de una expresi¢n este operador se puede utilizar como un
operador aritm‚tico binario convencional, que se sit£a entre dos operandos,
y devuelve como resultado el valor del segundo operando (adem s de realizar
la asignaci¢n de este resultado al dato reflejado como primer operando).

Este operador representa una {orden imperativa}; se ordena que, al ejecutarse
la sentencia que lo contiene, el primer operando (anterior al s¡mbolo) tome
el valor que tiene el segundo operando (o expresi¢n posterior al s¡mbolo).

En la evaluaci¢n de una expresi¢n los operandos de asignaci¢n son siempre
los de {menor prioridad} (los £ltimos que se interpretan en la expresi¢n),
pudiendo utilizar par‚ntesis para forzar una prioridad mayor. Si en una
expresi¢n (o sentencia) se han utilizado varios operadores de asignaci¢n,
‚stos ser n evaluados (ejecutados) de derecha a izquierda.

Por ejemplo, en la sentencia:

  {x=y=x+y;}

Primero se relizar  la suma ({x+y}), despu‚s se asignar  el resultado como
nuevo valor de la variable {y} ({y=x+y}) y, por £ltimo, se asignar  este
mismo valor a la variable {x} ({x=y}).

{/}Ver: {#1000,Sintaxis} - {#1009,Declaraciones de datos} - {#1019,Sentencias de asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1074,==}

Operador l¢gico [{igual que}] utilizado en condiciones. Debe utilizarse entre
dos expresiones num‚ricas y devuelve un resultado l¢gico:

{Falso} - Si las expresiones dan resultados distintos, pues NO son iguales
(ni equivalentes).

{Cierto} - Si ambas expresiones dan el mismo resultado (si son dos
expresiones equivalentes), pues SI son iguales.

{Ejemplos:}

  {0 == -1}  devolver  {falso}.ú
  {2+2 == 4} devolver  {cierto}.ú

{/}

{Nota:} El s¡mbolo {#1073,=} no puede utilizarse para comparar dos expresiones
o valores num‚ricos, ya que es el s¡mbolo de asignaci¢n.

{/}Ver: {#1000,Sintaxis} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1075,>=  =>}

Operador l¢gico [{mayor o igual que}] utilizado en condiciones. Los s¡mbolos
{>=} y {=>} son sin¢nimos.

Debe utilizarse entre dos expresiones num‚ricas y devuelve un
resultado l¢gico:

{Falso} - Si la primera expresi¢n NO es mayor o igual que la segunda.

{Cierto} - Si la primera expresi¢n SI es mayor o igual que la segunda.

{Ejemplos:}

  {2+2 >= 5} devolver  {falso}.ú
  {2+2 >= 4} devolver  {cierto}.ú

{/}Ver: {#1000,Sintaxis} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1076,>}

Operador l¢gico [{mayor que}] utilizado en condiciones. Debe utilizarse entre
dos expresiones num‚ricas y devuelve un resultado l¢gico:

{Falso} - Si la primera expresi¢n NO es mayor que la segunda.

{Cierto} - Si la primera expresi¢n SI es mayor que la segunda.

{Ejemplos:}

  {2+2 > 4} devolver  {falso}.ú
  {2 > 1}   devolver  {cierto}.ú

{/}Ver: {#1000,Sintaxis} - {#1037,Condici¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1077,>>}

Operador binario de {rotaci¢n a la derecha}. Este operador se utiliza en las
{#1035,expresiones aritm‚ticas} entre dos operandos para obtener el resultado
de rotar el primer operando a la derecha el n£mero de veces que indique
el segundo. Por ejemplo, la siguiente rotaci¢n:

  {n} >> {m}

devolver  {n} rotado a la derecha {m} veces; cada rotaci¢n a la derecha
equivale a dividir por 2 el n£mero. Es decir, rotar a la izquierda 1
vez, equivale a dividir por 2, rotar a la izquierda 2 veces a dividir
por 4, 3 veces a dividir por 8, etc.

Se recuerda que todos los n£meros manipulados en este lenguaje son {enteros}
(sin decimales) por lo que siempre se devolver  el resultado {entero} de la
divisi¢n (7 dividido entre 2 devolver  3, por ejemplo).

O lo que es equivalente (la {#145,funci¢n POW}{(2, m)} devuelve {2} elevado a {m}):

  {n} / POW(2, {m})

Por ejemplo, {16>>3} devolver  2, {2>>1} devolver  1, {100>>0} devolver  100, etc.

{/}

El operador de rotaci¢n a la izquierda (operaci¢n opuesta a ‚sta) es el
{#1070,s¡mbolo <<}.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1078,>>=}

Asignaci¢n operativa. Operaci¢n binaria de {rotaci¢n a la derecha}.

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ >>=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato el resultado de la siguiente rotaci¢n:

  [{valor_anterior_del_dato}] >> [{resultado_de_la_expresi¢n}]

O lo que es equivalente (la {#145,funci¢n POW}{(2, n)} devuelve {2} elevado a {n}):

  [{valor_anterior_del_dato}] / POW(2, [{resultado_de_la_expresi¢n}])

Es decir, si el resultado de la expresi¢n es:

  0 -> el dato mantendr  su valor.ú
  1 -> el dato ser  dividido por 2.ú
  2 -> el dato ser  dividido por 4.ú
  3 -> el dato ser  dividido por 8.ú
  ...

Ejemplo: {x=8; x>>=2;} -> (x=2)

El resultado de una rotaci¢n a la derecha ser  siempre un n£mero entero,
sin decimales, es decir, el cociente de la divisi¢n entera anterior.

Ejemplo: {x=9; x>>=2;} -> (x=2)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C};
en cualquier caso, una sentencia del tipo {n >>= m;} ser  equivalente a
esta otra {n = n >> m;}.

Ver el operador {#1077,>>} para m s informaci¢n sobre la {rotaci¢n a la derecha}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1079,^  [  ]}

Operador de indirecci¢n. Este operador requiere un nivel ligeramente
avanzado en t‚cnicas de programaci¢n. El uso de punteros es una
caracter¡stica de otros lenguajes que, aunque puede ser muy £til,
no resulta imprescindible para la realizaci¢n de programas, por
complejos que ‚stos sean.

El s¡mbolo {^} sirve para hacer referencia a una posici¢n determinada
de la memoria del ordenador.

{Caso pr ctico}{/}

Por ejemplo, si se tiene una variable denominada {mi_variable}
con el valor {3}, ‚sta estar  en una direcci¢n de la memoria (todas
las variables tienen su direcci¢n), el operador {#1085,OFFSET} sirve
para obtener esta direcci¢n.

Suponiendo que exista otra variable denominada {direcci¢n_de_mi_variable}
en la que guardar la direcci¢n de la variable anterior, ‚sto se har¡a
con la siguiente sentencia:

  {direcci¢n_de_mi_variable = OFFSET mi_variable;}

Esta direcci¢n ser  un n£mero entero, pongamos {12345}; para
obtener el valor de la variable ({3}) o modificarlo, teniendo £nicamente
la direcci¢n (posici¢n) de la variable en memoria (y no su nombre),
se debe utilizar el operador {^}, la sentencia obtener el
valor de la variable a partir de su direcci¢n ser¡a:

  {mi_variable = ^ direcci¢n_de_mi_variable;}

Para aclarar los conceptos de {nombre de variable}, {direcci¢n de la
variable} y {valor de la variable} se muestran a continuaci¢n una
serie de expresiones y sus equivalentes num‚ricos.

  {mi_variable} = {3}ú
  {OFFSET mi_variable} = {12345}ú
  {direcci¢n_de_mi_variable} = {12345}ú
  {^ direcci¢n_de_mi_variable} = {3}ú

La direcci¢n de una variable puede variar seg£n se vaya ampliando
un programa (a¤adiendo nuevos datos y sentencias al mismo).

En resumen, {el operador ^ accede al valor que est  en la
posici¢n de la memoria del ordenador indicada tras ‚l}, es decir:

  {^ 12345} = {3}ú

Lo que quiere decir que, en la direcci¢n {12345} de la memoria del
ordenador, est  el valor {3}, ya que en esta direcci¢n es donde
se {almacena} el valor de la variable {mi_variable} y ‚se es
su valor.

{/}

El {#1054,s¡mbolo *} puede utilizarse como {sin¢nimo} de {^}
(en el ejemplo anterior {*12345} = {3}).

Los corchetes (s¡mbolos {[ ]}) funcionan de forma similiar al operador
{^}, con la £nica diferencia que acceden al dato cuya direcci¢n se indica
entre ellos (en el ejemplo anterior {[12345]} = {3}).

Los corchetes tambi‚n se utilizan para especificar el ¡ndice en las
tablas y estructuras.

{/}Ver: {#1000,Sintaxis} - {#1085,OFFSET}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1081,^=}

Asignaci¢n operativa. Operaci¢n l¢gica y binaria de {OR (o) exclusivo} ({XOR}).

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ ^=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato el {OR (o) exclusivo} siguiente:

  [{valor_anterior_del_dato}] XOR [{resultado_de_la_expresi¢n}]

Ejemplo: {x=5; x^=3;} -> (x=3)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C};
en cualquier caso una sentencia del tipo {n ^= m;} ser  equivalente a
‚sta otra {n = n XOR m;}.

Ver el operador {#1082,XOR} para m s informaci¢n sobre el {OR (o) exclusivo}.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1082,XOR  ^^}

Operador l¢gico y binario de {OR (o) exclusivo} utilizado en expresiones y
condiciones.

La palabra reservada {XOR} y el s¡mbolo{ ^^} son sin¢nimos.

{XOR l¢gico:} Se eval£an primero las condiciones de la derecha e izquierda
del operador y si {s¢lo una} de ambas es {cierta}, este operador devolver 
{cierto}; en caso contrario el operador devolver  siempre {falso}.

  FALSO  XOR FALSO  = FALSOú
  FALSO  XOR CIERTO = CIERTOú
  CIERTO XOR FALSO  = CIERTOú
  CIERTO XOR CIERTO = FALSOú

Se utiliza para comprobar que se cumplan una, y s¢lo una, de las dos
condiciones que se especifican, por ejemplo:

  {(y>0 XOR x>0)}ú

Para comprobar que la primera variable sea mayor que 0, o bien
('o' exclusivo), que lo sea la segunda (pero no la primera).

{XOR binario:} Eval£a los bits de los resultados de las expresiones anterior
y posterior al operador generando, como resultado, un valor que tendr  a 1
solamente los bits que tuvieran a 1 una, y s¢lo una, de las expresiones.

  0 XOR 0 = 0ú
  0 XOR 1 = 1ú
  1 XOR 0 = 1ú
  1 XOR 1 = 0ú

Esta regla se aplicar  a todos los bits de los operandos (en el lenguaje
son enteros de 32 bits).

{/}

{Nota:} Este operador funciona indistintamente como l¢gico y binario debido
a que en el lenguaje se interpretan las expresiones l¢gicas {ciertas} como las
que tienen el £ltimo bit a 1 (el bit 0, de peso 1), es decir, los n£meros
impares (1, -1, 3, -3, ... ), y como expresiones l¢gicas {falsas} las que
tienen el £ltimo bit a 0 (los n£meros pares: 0, 2, -2, 4, -4, ...).

El operador {XOR} £nicamente dejar  a 1 el £ltimo bit (s¢lo devolver  {cierto}
como resultado} cuando lo tuviera a 1 uno, y s¢lo uno, de ambos operandos
(cuando £nicamente una de las dos expresiones fuera {cierta}).

{/}

{Nota:} El s¡mbolo{ ^} tambi‚n puede utilizarse como un sin¢nimo m s de
{XOR} y{ ^^}.

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1037,Condici¢n} - {#1083,OR}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1083,OR  ||  |}

Operador binario de {suma l¢gica} utilizado en expresiones y
condiciones.

La palabra reservada {OR} y los s¡mbolos{ ||} y{ |} son sin¢nimos.

{OR l¢gico:} Se eval£an primero las condiciones de la derecha e izquierda
del operador y si al menos una de ellas es {cierta}, este operador devolver 
{cierto}, en caso contrario el operador devolver  {falso} (cuando las dos
condiciones sean {falsas}).

  FALSO  OR FALSO  = FALSOú
  FALSO  OR CIERTO = CIERTOú
  CIERTO OR FALSO  = CIERTOú
  CIERTO OR CIERTO = CIERTOú

Se utiliza para comprobar que se cumplan una (cualquiera) de las condiciones
que se establecen, por ejemplo:

  {(x>0 OR y>0)}ú

Para comprobar que al menos una de las dos variables sea mayor que 0. Es
decir, que se cumpla la primera condici¢n {O} la segunda.

{OR binario:} Eval£a los bit de los resultados de las expresiones anterior
y posterior al operador, generando como resultado un valor que tendr  a 1
los bit que tuvieran a 1 cualquiera de las expresiones.

  0 OR 0 = 0ú
  0 OR 1 = 1ú
  1 OR 0 = 1ú
  1 OR 1 = 1ú

Esta regla se aplicar  a todos los bit de los operandos (en el lenguaje
son enteros de 32 bits).

{/}

{Nota:} Este operador funciona indistintamente como l¢gico y binario debido
a que en el lenguaje se interpretan las expresiones l¢gicas {ciertas} como las
que tienen el £ltimo bit a 1 (el bit 0, de peso 1), es decir, los n£meros
impares (1, -1, 3, -3, ... ), y como expresiones l¢gicas {falsas} las que
tienen el £ltimo bit a 0 (los n£meros pares: 0, 2, -2, 4, -4, ...).

El operador {OR} dejar  a 1 el £ltimo bit (devolver  {cierto}
como resultado} cuando lo tuviera a 1 uno (cualquiera) de los operandos (cuando los dos fueran,
al menos, una de las dos expresiones fuera {cierta}).

{/}Ver: {#1000,Sintaxis} - {#1035,Expresi¢n} - {#1037,Condici¢n} - {#1082,XOR}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1084,|=}

Asignaci¢n operativa. Operaci¢n binaria de {suma l¢gica} ({OR}).

Las {#1019,sentencias de asignaci¢n} sirven para calcular expresiones y
{asign rselas} a un dato.

{#1034,<referencia a un dato>} {=} {#1035,<expresi¢n>} {;}

Si se utiliza el s¡mbolo{ |=} en lugar de {=} para realizar la asignaci¢n,
se asignar  al dato la {suma l¢gica} siguiente:

  [{valor_anterior_del_dato}] OR [{resultado_de_la_expresi¢n}]

Ejemplo: {x=5; x|=6;} -> (x=7)

{/}

{Nota:} Este s¡mbolo es una simple abreviatura derivada del {lenguaje C},
en cualquier caso una sentencia del tipo {n |= m;} ser  equivalente a
esta otra {n = n OR m;}.

Ver el operador {#1083,OR} para m s informaci¢n sobre la {suma l¢gica}.

{/}

{Nota:} No se debe confundir este s¡mbolo con el de [{distinto que}] que
se expresa como {#1046,!=}, y sirve para comparar si dos expresiones
difieren en su resultado.

{/}Ver: {#1000,Sintaxis} - {#1019,Asignaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1085,OFFSET}

La palabra reservada {OFFSET} permite obtener la direcci¢n de un
dato dentro de la memoria del ordenador.

Todos los datos de un programa se corresponden con alguna posici¢n
concreta de la memoria en la que est  almacenado su valor; el
operador {OFFSET} permite obtener esta posici¢n como un valor
num‚rico.

Este operador se utiliza, principalmente, en los par metros de algunas
de las funciones del lenguaje; esto se hace para permitir a dichas
funciones que puedan modificar estos par metros.

Si se tiene una variable, por ejemplo denominada {mi_variable},
con el valor {321} y se pasa, como par metro, dicha variable a una funci¢n
par metro, se le est  pasando a la funci¢n el n£mero 321; con esto,
la funci¢n no podr  modificar la variable ya que conoce su valor
pero no {d¢nde est  la variable} (pues puede haber muchos valores
{321} por toda la memoria del ordenador, y no sabr  cu l de ellos
es la variable).

Si a esta funci¢n se le pasa como par metro {OFFSET mi_variable}
se le estar  informando del lugar en el que est  almacenado el
valor de la variable, pudiendo, la funci¢n, acceder a dicho valor para
consultarlo o modificarlo.

Para m s informaci¢n sobre este operador se puede acceder al
{#1079,operador ^} que realiza la operaci¢n inversa al operador
{OFFSET} (es decir, obtiene el valor que hay en una posici¢n determinada
de la memoria).

{/}

El {#1050,s¡mbolo &} puede utilizarse como {sin¢nimo} de la palabra
reservada {OFFSET}.

{/}Ver: {#1000,Sintaxis} - {#1079,^}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1086,BEGIN}

Esta palabra reservada indica el comienzo del programa, proceso o funci¢n.

Es decir, la palabra {BEGIN} se utiliza para separar la zona
de declaraci¢n de datos del programa principal o de un proceso,
de la zona de sentencias.

Es obligatoria la declaraci¢n {BEGIN} (inicio) en el programa
principal y todos los procesos.

Cuando se ejecuta un programa o proceso, ‚ste comenzar  siempre por
la sentencia que venga a continuaci¢n de {BEGIN}.

La sentencia {BEGIN no hace nada}, £nicamente sirve como delimitador
dentro de la estructura de los programas.

{/}

Cada {BEGIN} (inicio) viene relacionado directamente con un
{#1091,END} (fin) que marcar  el final de la zona de sentencias
del programa o proceso.

{/}Ver: {#1000,Sintaxis} - {#1015,C¢digo Principal} - {#1016,PROCESS} - {#1408,FUNCTION}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1087,CASE}

Esta palabra reservada forma parte de la sentencia {#1021,SWITCH};
se utiliza como inicio de las diferentes secciones de sentencias
que pueden ejecutarse o no, dependiendo del resultado de la expresi¢n
evaluada.

Cada {CASE} debe tener una palabra {#1091,END} que indique el
final de la secci¢n.

La sentencia {#1021,SWITCH} eval£a una expresi¢n y el significado
que tiene la palabra {CASE} es "{en el caso de que el resultado de
la expresi¢n sea ..., entonces se deben ejecutar las siguientes
sentencias ...}".

{/}Ver: {#1000,Sintaxis} - {#1021,Sentencia SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1088,DEFAULT}

Esta palabra reservada forma parte de la sentencia {#1021,SWITCH} que
se utiliza como inicio de una secci¢n de sentencias que debe ejecutarse
cuando el resultado de la expresi¢n evaluada no est‚ contemplado en
ninguna de las secciones {#1087,CASE} de la sentencia.

Cada {DEFAULT} debe tener una palabra {#1091,END} que indique el
final de la secci¢n.

La sentencia {#1021,SWITCH} eval£a una expresi¢n; cada secci¢n
{#1087,CASE} de la sentencia contemplar  uno o varios resultados en los
que se debe ejecutar dicha secci¢n y, por £ltimo, si aparece una
secci¢n {DEFAULT} es para expresar "{en el caso de que el resultado de
la expresi¢n no sea ninguno de los anteriores, entonces se deben ejecutar
las siguientes sentencias ...}".

{/}Ver: {#1000,Sintaxis} - {#1021,Sentencia SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1089,DUP}

Esta palabra sirve para definir {#1013,listas de constantes} (valores num‚ricos),
a base de repetir un patr¢n sencillo. Se utiliza para inicializar los
valores iniciales de tablas y estructuras.

Su sintaxis es la siguiente:

<n£mero de veces> {DUP (}<secuencia a repetir>{)}

Es equivalente a poner la <secuencia a repetir> el <n£mero de veces>
que se indica.

Por ejemplo, la secuencia {1, 2, 3, 1, 2, 3, 1, 2, 3} ser¡a equivalente a
la secuencia {3 DUP (1, 2, 3)}.

{/}Ver: {#1000,Sintaxis} - {#1013,Definici¢n de una lista de constantes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1090,ELSE}

Esta palabra forma parte de la sentencia {#1020,IF}, y sirve
para especificar d¢nde comienza el bloque de sentencias que se debe
ejecutar cuando la condici¢n especificada en la sentencia
{#1020,IF} no se cumpla.

El formato de la sentencia {#1020,IF} es el siguiente:

{IF (<}condici¢n{>)}ú
    // C¢digo a ejecutar cuando se cumpla la condici¢nú
{ELSE}ú
    // C¢digo a ejecutar cuando {no} se cumpla la condici¢nú
{END}ú

El significado sem ntico de {ELSE} es "{en el caso contrario ...}".

{/}

La secci¢n {ELSE} es opcional, pudiendo formularse la sentencia {#1020,IF}
de la siguiente forma:

{IF (<}condici¢n{>)}ú
    // C¢digo a ejecutar cuando se cumpla la condici¢nú
{END}ú

Cuando no se requiera que se ejecute ninguna sentencia {en el caso
contrario}.

{/}Ver: {#1000,Sintaxis} - {#1020,Sentencia IF}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1091,END}

Esta palabra reservada marca el final de una de las siguientes sentencias:

  {#1086,BEGIN}ú
  {#1020,IF}ú
  {#1022,WHILE}ú
  {#1021,SWITCH}ú
  {#1087,CASE}ú
  {#1087,DEFAULT}ú
  {#1025,FOR}ú
  {#1043,FROM}ú
  {#1024,LOOP}ú
  {#1030,CLONE}ú

Es decir, la funci¢n de la palabra {END} es {delimitar d¢nde acaba
una sentencia}.

Se debe tener en cuenta que las sentencias se pueden
anidar, es decir, incluir unas dentro de otras, por lo que si no
se estructura bien un programa (tabulando el c¢digo), puede resultar
dif¡cil averiguar a qu‚ sentencia corresponde cada {END}.

Por ejemplo, en el siguiente c¢digo se puede ver claramente a qu‚
sentencia pertenece cada {END}.

{BEGIN}ú
    {IF (x>0)}ú
        {x=x-1;}ú
    {END}ú
{END}ú

Pero este mismo c¢digo podr¡a haberse expresado como sigue:

{BEGIN}ú
    {IF (x>0)}ú
    {x=x-1;}ú
{END}ú
    {END}ú

resultando mucho m s complicada la lectura del programa, aunque
para el compilador del lenguaje {ambos bloques de c¢digo son
exactamente iguales} (el compilador seguir  interpretando que
el primer {END} es el de la sentencia {IF} y el segundo el
del {BEGIN}, aunque ‚stos est‚n tabulados incorrectamente).

{/}Ver: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1092,ID}

La palabra reservada {ID} se utiliza para obtener el {#1039,c¢digo
identificador} de un proceso en tiempo de ejecuci¢n.

Un {#1039,c¢digo identificador} es un valor num‚rico que
{identifica} a cada uno de los porcesos activos en cada momento
(cada uno de los objetos que tenga el juego).

Es decir, {ID} es como una constante num‚rica s¢lo que su valor
ser  diferente para cada proceso que la consulte.

No es posible cambiar el valor de {ID}, ya que es un objeto
£nicamente de lectura.

Normalmente, un proceso accede a este valor cuando quiere informar
a otros procesos de cu l es su {#1039,c¢digo identificador}.

{/}Ver: {#1000,Sintaxis} - {#1039,C¢digos identificadores}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1093,SETUP_PROGRAM}

Esta palabra reservada sirve para designar un tipo especial de
programas, de {configuraci¢n del hardware de sonido}.

Estos programas se identifican por comenzar con la palabra
reservada {SETUP_PROGRAM} en lugar de {#1003,PROGRAM}.

ste es un t¢pico muy avanzado, para usuarios con experiencia.

Se puede observar un programa de este tipo en el directorio {SETUP}
de DIV Games Studio; estos programas, una vez compilados, se incluir n
autom ticamente en las instalaciones del resto de programas, cuando
en el proceso de instalaci¢n se active la casilla "{Incluir setup de sonido}".

{Nota:} En las instalaciones siempre se incluir  el £ltimo programa
de setup que haya sido compilado en DIV Games Studio.

{/}

No obstante, se recuerda que no es imprescindible crear programas
de configuraci¢n del sistema de sonido, ya que los juegos creados con DIV Games
Studio detectar n autom ticamente si el ordenador en el que se
ejecutan tiene una tarjeta de sonido compatible con {Sound Blaster}
o {Gravis Ultrasound}, siempre que ‚sta est‚ apropiadamente configurada.

{/}

Este tipo de programas suelen modificar la {#1104,estructura global
setup}, que es la que controla los par metros del sistema de sonido.

{/}Ver: {#1000,Sintaxis} - {#1104,Estructura setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1094,SIZEOF()}

{SIZEOF(}<nombre del dato>{)}

{Retorna:}

El n£mero de elementos que contiene el dato.

{Descripci¢n:}

La palabra reservada {SIZEOF} se utiliza para calcular el n£mero
de elementos que tiene una tabla o una estructura.

Esta palabra reservada {se utiliza como si fuera una funci¢n} del lenguaje,
indicando, entre par‚ntesis, el {#1001,nombre} del dato y devolviendo el
n£mero de elementos (posiciones) del mismo.

Es posible utilizarla para obtener el n£mero de elementos de una
variable pero, en este caso, {SIZEOF} retornar  siempre {1}
como n£mero de elementos (ya que una variable es un £nico elemento).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_sizeof;

PRIVATE
    tabla1[]=0, 1, 2, 3;
    tabla2[]=4, 5, 6, 7, 8;
    variable=9;

BEGIN
    // ...

    save("help\help.dat", OFFSET tabla1, SIZEOF(tabla1)+SIZEOF(tabla2)+SIZEOF(variable));

    // ...
END
{-}

En este ejemplo se utiliza {SIZEOF} para obtener el n£mero de elementos
de tres datos diferentes; ‚stos son:

{tabla1} de {4} elementos.ú
{tabla2} de {5} elementos.ú
{variable} ({1} elemento).ú

En este caso se utiliza para grabar en el archivo {help.dat} el
contenido de estos tres datos con la funci¢n {#155,save()} que
requiere, como tercer par metro, el n£mero de elementos que se quieren
guardar en el archivo.

En este caso se guardar n {10} elementos en el archivo {help.dat},
que seg£n est n inicializados los datos en el ejemplo ser n los
n£meros del {0} al {9}.

La sentencia {#155,save()} del ejemplo anterior se podr¡a haber
expresado tambi‚n sin utilizar {SIZEOF} de la siguiente forma:

  {save("help\help.dat", OFFSET tabla1, 10);}

La £nica diferencia es que si en el programa del ejemplo se a¤adieran
elementos a alguna de las dos tablas, no har¡a falta modificar la
llamada a la funci¢n {#155,save()}, ya que {SIZEOF} siempre devolver 
el tama¤o actual de las mismas.

{/}Ver: {#1000,Sintaxis} - {#1011,Declaraci¢n de una tabla} - {#1012,Declaraci¢n de una estructura}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1095,STEP}

La palabra reservada {STEP} forma parte de la sentencia {#1043,FROM} y sirve
para indicar el incremento (paso) que se debe hacer en cada iteraci¢n del bucle.

La sentencia {#1043,FROM} implementa un bucle, es decir, un grupo de
sentencias que se van a repetir un n£mero determinado de veces; para
ello, utiliza una variable como contador del n£mero de repeticiones.

Se define el valor inicial de la variable as¡ como el valor final, y el
bucle se repetir  hasta que la variable alcance el valor final, partiendo
del valor inicial.

Por defecto, la variable pasar  por todos los valores num‚ricos enteros
comprendidos entre el valor inicial y el valor final, pero se puede
indicar una declaraci¢n {STEP} para establecer un incremento de la
variable diferente.

Por ejemplo, si se define un bucle en el que la variable {x} va a
recorrer los valores del {1} al {10}, se ejecutar  dicho bucle un
total de {10} veces, pero si se estable el paso ({STEP}) como {2}
el bucle se ejecutar  £nicamente {5} veces, en donde la variable
{x} tomar  los valores {1}, {3}, {5}, {7} y {9}, pues se habr 
establecido que la variable debe incrementarse de {2} en {2}. Este
bucle se implementar¡a de la siguiente forma:

{FROM x=1 TO 10 STEP 2}ú
  // Sentencias que se van a repetir las cinco vecesú
{END}ú

Si se omite la declaraci¢n {STEP} de la sentencia {#1043,FROM}, el
incremento ser  siempre de 1 en 1, sumando 1 a la variable tras cada
iteraci¢n del bucle (o restando 1, en el caso de que el valor final
sea menor que el valor inicial).

{Nota:} Unicamente se pueden establecer incrementos enteros.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1096,TO}

La palabra reservada {TO} forma parte de la sentencia {#1043,FROM} y sirve
para separar las constantes que indican los valores inicial y final que
debe tomar la variable que se utilice como contador del bucle.

La sentencia {#1043,FROM} implementa un bucle, es decir, un grupo de
sentencias que se van a repetir un n£mero determinado de veces; para
ello utiliza una variable como contador del n£mero de repeticiones.

Se define el valor inicial de la variable y el valor final, y el
bucle se repetir  hasta que la variable alcance el valor final, partiendo
del valor inicial.

{Ejemplo:}

  {FROM x=1 TO 10}ú
    // Sentencias que se repetir n 10 vecesú
  {END}ú

Por defecto, la variable pasar  por todos los valores num‚ricos enteros
comprendidos entre el valor inicial y el valor final, pero se puede
indicar una declaraci¢n {#1095,STEP} para establecer un incremento de la
variable diferente.

{/}Ver: {#1000,Sintaxis} - {#1043,Sentencia FROM} - {#1095,STEP}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1097,UNTIL}

La palabra reservada {UNTIL} forma parte de la sentencia {#1023,REPEAT},
cuya sintaxis es, a grandes rasgos, la siguiente:

{#1023,REPEAT}ú
    {#1017,<sentencia>};ú
    ...ú
{UNTIL (<}condici¢n>}{)}

La sentencia {#1023,REPEAT} implementa un bucle, es decir, es capaz
de repetir un grupo de sentencias un n£mero determinado de veces.

El final de la sentencia se determina poniendo la palabra reservada {UNTIL}
seguida de la condici¢n que se debe cumplir para que {se de por finalizada
la sentencia}.

{/}Ver: {#1000,Sintaxis} - {#1023,Sentencia REPEAT}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1100,GLOBAL STRUCT mouse}

{STRUCT mouse;}ú
    {x, y;}                // Coordenadasú
    {graph;}               // C¢digo del gr ficoú
    {file;}                // C¢digo del ficheroú
    {z;}                   // Plano de profundidadú
    {angle;}               //  nguloú
    {size;}                // Tama¤o (%)ú
    {flags;}               // Indicador espejadosú
    {region;}              // Regi¢n de corteú
    {left, middle, right;} // Estado botonesú
    {cursor;}              // Emulaci¢n con cursoresú
    {speed;}               // Velocidad del rat¢nú
{END}ú

Esta estructura global sirve para controlar el rat¢n; contiene
una serie de campos relacionados con la programaci¢n de este
dispositivo, como la posici¢n en pantalla, el gr fico del puntero,
el estado de los botones, etc.

Para acceder a estos campos se debe preceder el nombre del campo
por la palabra {mouse} y el s¡mbolo {#1063,. (punto)}; por ejemplo, para
acceder al campo {x} (coordenada horizontal del puntero del rat¢n)
se debe utilizar {mouse.x}.

{/}

{x}, {y} - Coordenadas horizontal y vertical del rat¢n. Estos dos campos
({mouse.x} y {mouse.y}) ser n los £nicos que necesariamente habr  que leer para
conocer la posici¢n en pantalla del cursor del rat¢n.

Para {posicionar el rat¢n en otras coordenadas} (forzar su posici¢n),
bastar  con asignar las nuevas coordenadas a estos dos campos.

{/}

{graph} - {C¢digo del gr fico} asignado como puntero del rat¢n. Por
defecto {el rat¢n no ser  visible}; para hacerlo visible se debe crear
el gr fico que va a servir de puntero en el {editor gr fico},
cargarlo en el programa (con la funci¢n {#132,load_fpg()}, {#174,load_map()} o {#174,load_pcx()}, seg£n
se haya guardado este gr fico en un {fichero FPG} o en un {archivo MAP/PCX}), y
asignar su {c¢digo de gr fico} a esta variable ({mouse.graph}). Entonces se har 
visible el puntero del rat¢n en pantalla.

En las coordenadas {mouse.x}, {mouse.y} aparecer  el centro del gr fico,
a no ser que se haya definido el {#1136,punto de control} n£mero {0} del mismo
en el {editor gr fico}. Si se define este punto, com£nmente denominado
"{punto caliente del rat¢n}" ({hot spot}), ser  ‚l mismo el que aparezca
en las coordenadas indicadas en los campos {mouse.x} e {mouse.y}.

Por ejemplo, si se crea como dibujo para el puntero del rat¢n la
t¡pica flecha (como el puntero de rat¢n DIV Games Studio), el "punto
caliente" (punto de control n£mero {0}) se definir¡a en la
esquina superior izquierda del gr fico, pues ‚ste es el {punto activo}
dentro del gr fico. Entonces, cuando el rat¢n estuviera, por ejemplo,
en las coordenadas (0, 0), ser¡a la precisamente la "{punta de la flecha}"
la que se situara en dichas coordenadas.

{/}

{file} - {C¢digo del fichero} que contiene el gr fico. En este campo se define
el {c¢digo de fichero} que contiene el gr fico del puntero del rat¢n.
{No es necesario} indicar aqu¡ un valor si el gr fico se carg¢ de un
{archivo MAP o PCX}, o si est  en el primer {archivo FPG} cargado en el
programa. En caso contrario, se deber  asignar a {mouse.file} el
{c¢digo de fichero} que retorn¢ la funci¢n {#132,load_fpg()} al cargar
el fichero que contiene el gr fico del puntero del rat¢n.

{/}

{z} - Prioridad de impresi¢n del gr fico. Indica en qu‚ plano de profundidad
debe pintarse el gr fico del puntero del rat¢n. {Por defecto} este campo
valdr { -512}, lo que implica que {el puntero se ver  por encima del resto
de gr ficos y textos}. Cuanto mayor sea este campo, m s al fondo se situar 
el puntero del rat¢n.

Si se quisiera que un gr fico de un proceso apareciera
por encima del puntero del rat¢n, bastar¡a con asignar a la variable
{#1125,local z} de dicho proceso un n£mero entero menor de{ -512},
por ejemplo{ -600}.

{/}

{angle} -  ngulo con el que se ver  el gr fico del puntero del rat¢n.
El valor de {mouse.angle} por defecto es {0}, lo que implica que no
se ver  rotado este gr fico, a no ser que se asigne un nuevo  ngulo
a este campo.

Se recuerda que los  ngulos se deben especificar en
mil‚simas de grado, por ejemplo, la sentencia {mouse.angle=90000;} har  que el
puntero aparezca rotado {90 grados} (ver el {#1044,uso de  ngulos
en el lenguaje}).

{/}

{size} - Tama¤o del gr fico en porcentaje. Por defecto, este campo
valdr  {100} (el gr fico se ver  al 100% de su tama¤o), y no es
necesario indicar aqu¡ otro valor a no ser que se quiera que el
gr fico se escale (se vea ampliado o reducido).

Si por ejemplo se quisiera que el gr fico apareciera el doble de
grande que su tama¤o original (al 200%), se deber¡a utilizar la sentencia
{mouse.size=200;}.

{/}

{flags} - En este campo se indicar n diferentes valores cuando se
pretenda que el gr fico del rat¢n aparezca espejado (invertido
horizontal o verticalmente), o se quiera visualizarlo como un
gr fico (semi) transparente. Los posibles valores asignables a
la variable {mouse.flags} son:

 {0}-Gr fico normal (valor por defecto).ú
 {1}-Espejado horizontal.ú
 {2}-Espejado vertical.ú
 {3}-Espejado horizontal y vertical (180ø).ú
 {4}-Gr fico transparente.ú
 {5}-Transparente y espejado horizontal.ú
 {6}-Transparente y espejado vertical.ú
 {7}-Transparente, espejado horizontal y vertical.ú

{/}

{region} - Regi¢n de corte del gr fico. A este campo se debe asignar
un valor {£nicamente cuando se quiera que el puntero del rat¢n sea
visible s¢lo dentro de una regi¢n} (una zona rectangular de la pantalla);
para conseguirlo se debe, primero, definir esta regi¢n con la funci¢n
{#106,define_region()} y, despu‚s, asignar a este campo ({mouse.region})
el n£mero de la regi¢n que se ha definido.

Por defecto este valor ser  {0}, que es el n£mero de regi¢n que se
refiere a la pantalla completa, por lo que el gr fico ser  visible
en toda la pantalla.

{/}

{left}, {middle} y {right} - Estos tres campos almacenan valores
l¢gicos ({0} o {1}) seg£n los botones del rat¢n est‚n pulsados o
no (se corresponden con los botones izquierdo, central y derecho
del rat¢n). Normalmente, se activan £nicamente dos botones del rat¢n
({left} y {right}) ignor ndose el estado del bot¢n central. Esto
depende del {driver} (dispositivo de control) del rat¢n que est‚
instalado en el ordenador.

Por ejemplo, para realizar en un programa una acci¢n {cuando se pulse
el bot¢n izquierdo del rat¢n} ({mouse.left}) se debe incluir en el c¢digo
una sentencia como la siguiente:

  {IF (mouse.left)}ú
    // Acci¢n a realizar (sentencias)ú
  {END}ú

{/}

{cursor} - Indica si est  activa la emulaci¢n del rat¢n con las teclas de
los {Cursores} y {Enter}; cuando esta emulaci¢n est‚ activada, se podr 
mover el puntero tanto con el rat¢n como con los cursores. Por defecto,
esta emulaci¢n estar  desactivada ({mouse.cursor=0;}) a no ser que el
programa no pueda detectar un rat¢n conectado al sistema, en cuyo caso
se activar  la emulaci¢n autom ticamente (es decir, si {mouse.cursor} vale
{1} al inicio del programa, es que no hay un rat¢n conectado en el equipo).

{/}

{speed} - Al igual que en el entorno, ahora se puede regular la velocidad
de desplazamiento del puntero del rat¢n en los programas. Este es un valor
entre {0} (velocidad m xima) y {9} (m¡nima), por defecto {mouse.speed}
valdr  {2}.

{/}Ver: {#1200,Datos globales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1101,GLOBAL STRUCT scroll}

{STRUCT scroll[9];}ú
    {x0, y0;}    // Coordenadas del primer planoú
    {x1, y1;}    // Coordenadas del segundo planoú
    {z;}         // Plano de profundidadú
    {camera;}    // {#1039,C¢digo identificador} de la c maraú
    {ratio;}     // Velocidad relativa del segundo planoú
    {speed;}     // Velocidad m xima del primer planoú
    {region1;}   // Primera regi¢n de pantallaú
    {region2;}   // Segunda regi¢n de pantallaú
{END}ú

Esta estructura de {10} registros contiene ciertos campos relacionados
con par metros modificables de las {ventanas de scroll}. Los diez
registros tienen los mismos nombres de campos, pero cada uno de
ellos modifica los par metros de una ventana de scroll diferente
(ya que pueden activarse hasta 10 ventanas de este tipo).

Una {ventana de scroll} se podr¡a definir como una regi¢n de pantalla que
muestra s¢lo una parte de un gr fico m s grande que dicha ventana (este
gr fico suele ser el {decorado} o {fondo} del juego). El {scroll} en s¡
es el movimiento de dicha ventana por el gr fico en cualquier direcci¢n,
visualiz ndose poco a poco el gr fico completo, secci¢n a secci¢n del mismo.

Para que un registro (del {0} al {9}) de la {estructura scroll} tenga sentido,
primero debe activarse dicha {ventana de scroll} (del {0} al {9}) con la
funci¢n {#163,start_scroll} (ver esta funci¢n para m s informaci¢n sobre
las ventanas de scroll}.

Se entiende que los campos de esta estructura son complementarios a los
par metros de llamada de esta £ltima funci¢n.

{/}

{Forma de uso de la estructura scroll:}

Para acceder a estos campos se debe preceder el nombre del campo
por la palabra {scroll}, el n£mero de registro entre corchetes y el s¡mbolo
{#1063,.} (punto).

Por ejemplo, si se inicializaran dos ventanas de scroll, la n£mero 0 y la
n£mero 1, se podr¡a acceder al campo {camera} de ambas ventanas como
{scroll[0].camera} y {scroll[1].camera}, respectivamente. Cuando se acceda a la
ventana n£mero 0 de scroll se puede, adem s, omitir el n£mero de
ventana entre corchetes, es decir, que la variable {scroll.camera} y la variable
{scroll[0].camera} son, a todos los efectos, la misma para el lenguaje.

{/}

{Se muestra a continuaci¢n una descripci¢n detallada de cada campo}

{x0, y0} - Coordenadas del primer plano de scroll, cuando es scroll {NO} es
autom tico (no se ha definido el campo {camera}), {‚stos son los campos que
se deber n modificar para mover el primer plano de la ventana de scroll}.

Estos dos campos almacenan las coordenadas horizontal y vertical de la esquina
superior izquierda de la ventana de scroll (el punto del gr fico del primer
plano que se ver  en la esquina superior izquierda de la ventana).

Cuando se haya definido el campo {camera} de esta estructura, el movimiento
de la ventana de scroll ser  autom tico, por lo que estos campos ser n
s¢lo de lectura; para poder comprobar donde est  situado el scroll en cada
momento (ver la funci¢n {#140,move_scroll()}).

{/}

{x1, y1} - Coordenadas del segundo plano, cuando se haya definido un gr fico
para el segundo plano. Cuando el scroll {NO} es autom tico (no se ha definido
el campo {camera}), {‚stos son los campos que se deber n modificar para mover
el plano de fondo de la ventana de scroll}.

Cuando se haya definido el campo {camera} de esta estructura, el movimiento
de la ventana de scroll ser  autom tico, por lo que estos campos ser n
s¢lo de lectura, determin ndose la velocidad de movimento del segundo plano
en funci¢n del campo {ratio} de esta misma estructura.

{/}

{z} - Prioridad de impresi¢n del scroll, aqu¡ se indica en que plano de profundidad
se debe pintar esta ventana, respecto al resto de procesos. Por defecto, esta
variable valdr  {512}, lo cual quiere decir que como los procesos por defecto
tienen su variable {#1125,local z} a {0}, la ventana de scroll se pintar  en un plano
de profundidad mayor, m s al fondo, visualiz ndose los gr ficos de los procesos
por encima de la ventana. Para variar esta situaci¢n se puede modificar la
variable {z} de la ventana (por ejemplo, ponerla a{ -1}) o la variable {z} de
los procesos (por ejemplo, ponerla a {600}).

{/}

{camera} - Este campo no es necesario inicializarlo, se inicializar  cuando
se quiera que el scroll sea {autom tico}, esto es, que el sistema se encargue
de que ‚ste siga siempre a un proceso (un gr fico del juego). Para ello, se
debe poner en este campo el {#1039,c¢digo identificador} del proceso; s¢lo
con esto, el desplazamiento de la ventana de scroll pasar  a ser controlado
autom ticamente por el sistema, intentando centrar el gr fico de dicho proceso
siempre en la ventana. Este proceso debe tener la variable local {#1122,ctype}
con el valor {#1168,c_scroll}.

Por defecto este campo valdr  {0}, lo que implica que el scroll no seguir  a
ning£n proceso, a no ser que se asigne el {#1039,c¢digo identificador} de uno
a {camera}. Cuando se haga esto, se denominar  a este proceso como el {proceso
c mara} del scroll.

{Nota:} A continuaci¢n se muestra una serie de campos {s¢lo para ventanas de
scroll autom tico}; esto quiere decir que para que dichos campos tengan sentido
(y, por consiguiente, efecto) se debe haber definido previamente el campo
{camera} de esta estructura con el {#1039,c¢digo identificador} del proceso
que se va a centrar en el scroll. Estos valores afectar n a la forma en la
que se va a hacer este seguimiento al proceso denominado {c mara del scroll}.

{/}

{ratio} - {Ventanas de scroll autom tico}. Cuando se hayan definido dos planos
de scroll en la llamada a la funci¢n {#163,start_scroll()}, en este campo
se puede definir la {velocidad de movimiento del plano del fondo} respecto
a la del primer plano. Por defecto, este valor ser  {200} lo que implicar 
que el plano de fondo se mover  a la mitad de velocidad del primer plano;
si se define como {400} se mover  a la cuarta parte (cuatro veces m s lento),
{100} a la misma velocidad, {50} al doble de velocidad que el primer plano, etc.

{/}

{speed} - {Ventanas de scroll autom tico}. Velocidad m xima del primer plano
de scroll, por defecto valdr  {0}, lo que quiere decir que no se impone ning£n
l¡mite de velocidad. Si se impone un l¡mite, especificando el n£mero de puntos m ximo
que puede desplazarse el primer plano por cada imagen del juego, se descentrar 
el {proceso c mara} de la ventana de scroll cuando ‚ste se mueva a una velocidad mayor.

{/}

{region1} - {Ventanas de scroll autom tico}. Regi¢n de bloqueo del scroll, cuyo
valor, por defecto, es{ -1} lo que implica que no hay ninguna regi¢n de bloqueo.
Si se define este campo con un n£mero de regi¢n (una zona rectangular de la
pantalla definida previamente con la funci¢n {#106,define_region()}), entonces
el sistema no mover  el scroll mientras el {proceso c mara} permanezca dentro
de la misma.

{/}

{region2} - {Ventanas de scroll autom tico}. Region exterior del scroll; por
defecto su valor es{ -1}, lo que implica que no hay una regi¢n exterior.
Si se define este campo con un n£mero de regi¢n y se ha definido una {velocidad
m xima} en el campo {speed}, entonces el sistema ignorar  dicho l¡mite de
velocidad cuando el proceso{ c mara} vaya a salirse de esta regi¢n (‚sto se hace para
no perder de vista al proceso (para que su gr fico siempre sea visible dentro
de la ventana de scroll).

{Nota:} Si se definen las dos regiones ({region1} y {region2}), normalmente la regi¢n
1 es menor que la regi¢n 2 (est  contenida en ella), esto implicar  que:

- No se desplazar  el gr fico de fondo (no se har  scroll) mientras el gr fico
del proceso c mara est‚ dentro de la regi¢n 1.

- Si se ha definido una velocidad m xima ({speed}), entonces se har  scroll para
intentar devolver el gr fico del proceso c mara a la regi¢n 1, pero sin sobrepasar
el l¡mite de velocidad impuesto.

- Si el gr fico del proceso c mara intentara salirse de la regi¢n 2, se
ignorar¡a el l¡mite de velocidad impuesto, para no permitirlo.

{/}Ver: {#1200,Datos globales} - {#163,start_scroll()} - {#166,stop_scroll()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1102,GLOBAL STRUCT m7}

{STRUCT m7[9];}ú
    {camera;}   // {#1039,C¢digo identificador} de la c maraú
    {height;}   // Altura de la c maraú
    {distance;} // Distancia de la c maraú
    {horizon;}  // Altura del horizonteú
    {focus;}    // Focal de visi¢nú
    {z;}        // Plano de profundidadú
    {color;}    // Color del exteriorú
{END}ú

Esta estructura de {10} registros contiene ciertos campos relacionados
con par metros modificables de las {ventanas de modo 7}. Los diez
registros tienen los mismos nombres de campos, pero cada uno de
ellos modifica los par metros de una ventana de modo 7 diferente
(ya que pueden activarse hasta 10 ventanas de este tipo).

Una {ventana de modo 7} se podr¡a definir como una regi¢n de pantalla que
muestra un plano gr fico tridimensionalmente abatido. Por ejemplo como
una hoja de papel con un dibujo que pusieramos horizontal, visualiz ndose
en pantalla como un suelo (o techo) virtual.

Para que un registro (del {0} al {9}) de la {estructura m7} tenga sentido,
primero debe activarse dicha {ventana de modo 7} (del {0} al {9}) con la
funci¢n {#162,start_mode7()} (ver esta funci¢n para m s informaci¢n sobre
las ventanas de modo 7}.

Se entiende que los campos de esta estructura son complementarios a los
par metros de llamada de esta £ltima funci¢n. Para poder observar un ejemplo
pr ctico de un modo 7, se puede acceder a la ayuda sobre la funci¢n
{#162,start_mode7()}.

{/}

{Forma de uso de la estructura m7:}

Para acceder a estos campos se debe preceder el nombre del campo
por la palabra {m7}, el n£mero de registro entre corchetes y el s¡mbolo
{#1063,. (punto)}.

Por ejemplo, si se inicializaran dos ventanas de modo 7, la n£mero 0 y la
n£mero 1, se podr¡a acceder a la variable {camera} de ambas ventanas como
{m7[0].camera} y {m7[1].camera}, respectivamente. Cuando se acceda a la
ventana n£mero 0 de modo 7 se puede, adem s, omitir el n£mero de
ventanas entre corchetes, es decir, que la variable {m7.camera} y la variable
{m7[0].camera} son, a todos los efectos, la misma para el lenguaje.

{/}

{Se muestra a continuaci¢n una descripci¢n detallada de cada campo}

{camera} - {#1039,C¢digo identificador del proceso} al que sigue la c mara. Para mover
la c mara que controla la visi¢n del modo 7, £nicamente se debe crear un proceso
de modo 7, un proceso que tenga su variable local {#1122,ctype} {=} {#1169,c_m7}, y poner
su {#1039,c¢digo identificador} en la variable {camera} de esta estructura.
Tras esto, s¡mplemente se deben modificar las variables locales {#1123,x}, {#1124,y} e {#1129,angle} de
este proceso y, por ejemplo, utilizar la funci¢n {#101,advance()} para mover hacia
delante la c mara.

El campo {camera} es {imprescindible} inicializarlo para que
se active la ventana de modo 7; sin este campo, la ventana no puede determinar
desde d¢nde se debe {ver} el plano abatido.

{/}

{height} - Altura de la c mara. Esta variable de la estructura regula la
distancia a la que se sit£a del suelo la c mara, por defecto su valor es {32}.
Cualquier n£mero positivo har  que se sit£e la c mara m s arriba cuanto mayor
sea el n£mero. Si el valor puesto en el campo {height} de esta misma estructura
es negativo, menor que cero, entonces la c mara se situar  por debajo del
plano abatido, mostr ndose un "{techo}" en lugar de un "{suelo}".

Se pueden crear dos modos-7 dentro de la misma regi¢n: uno
como techo y otro como suelo (uno con {height} positiva y otro negativa). En
este caso, es importante fijar la variable {z} de la {#1102,estructura m7} de
ambos para, de esta forma, determinar en qu‚ plano de profundidad se debe
pintar cada uno.

{/}

{distance} - Distancia de la c mara al proceso seguido. El punto de vista
de la c mara siempre se situar  un poco por detr s del proceso cuyo identificador
se ha puesto en el campo {camera} de la estructura. Esto se hace para que se vea el gr fico
del proceso utilizado como c mara, en el caso de que este proceso lo tenga definido
(en su variable local {#1126,graph} o {#1132,xgraph}).

Por defecto, la c mara se situar  a {64} puntos por detr s del proceso. Se
entiende por "detr s", a un punto situado a la distancia indicada del gr fico
en el  ngulo contrario al que est‚ orientado el proceso; por ejemplo, si el
proceso est  mirando a la derecha, 64 puntos a la izquierda del mismo.

{/}

{horizon} - Altura del horizonte. ste es el mismo valor que se indicaba como
£ltimo par metro de la funci¢n {start_mode7()}; su valor inicial ser  el que
se indic¢ en la llamada a esta funci¢n. La utilidad de esta variable es el poder hacer que
suba o baje el horizonte en cada visualizaci¢n (imagen) del juego seg£n las necesidades
de ‚ste.

Al variar la {altura del horizonte} se conseguir  en la {ventana de modo 7}
el efecto de "{mirar hacia arriba}" y "{mirar hacia abajo}".

{/}

{focus} - Focal para la c mara. Esta variable controla la perspectiva de la
c mara; por defecto, su valor es 256 pero se puede poner cualquier valor entre
{0} y {512}, consiguiendo diversos efectos de deformaci¢n del plano
tridimensional.

Es decir, este campo controla el  ngulo que capta el foco de la c mara; cuanto
mayor sea este valor, m s cerca se ver n todos los objetos (procesos) situados
en el plano abatido.

{/}

{z} - Prioridad de impresi¢n del modo 7, aqu¡ se indica en qu‚ plano de profundidad
se debe pintar esta ventana, respecto al resto de procesos. Por defecto, esta
variable valdr  {256} lo cual quiere decir que, como los procesos por defecto
tienen su variable {#1125,local z} a {0}, la ventana de modo 7 se pintar  en un plano
de profundidad mayor, m s al fondo, visualiz ndose los gr ficos de los procesos
por encima de la ventana. Para variar esta situaci¢n se puede modificar la
variable {z} de la ventana (por ejemplo ponerla a{ -1}) o la variable {z} de
los procesos (por ejemplo ponerla a {257}).

{/}

{color} - Color para el exterior del modo 7. Cuando en la llamada a la funci¢n {start_mode7()}
no se especifique ning£n {gr fico exterior} (se ponga a {0} el cuarto
par metro de llamada), esta variable controlar  de qu‚ color se quiere pintar
el exterior, es decir, de qu‚ color debe ser la pantalla m s all  del gr fico
que se est  abatiendo (m s alla de sus l¡mites).

Este campo est  inicializado por defecto a {0} que, normalmente, es el color
negro en la paleta de colores, por lo que, si no se asigna a este campo otro
valor (y no se define un gr fico exterior) se ver  la pantalla en negro m s
all  del plano principal.

{/}Ver: {#1200,Datos globales} - {#162,start_mode7()} - {#165,stop_mode7()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1103,GLOBAL STRUCT joy}

{STRUCT joy;}ú
    {left;}    // Control izquierdaú
    {right;}   // Control derechaú
    {up;}      // Control arribaú
    {down;}    // Control abajoú
    {button1;} // Primer bot¢nú
    {button2;} // Segundo bot¢nú
    {button3;} // Tercer bot¢nú
    {button4;} // Cuarto bot¢nú
{END}ú

Esta estructura global sirve para controlar el {joystick} (palanca de
juegos); contiene una serie de campos l¢gicos relacionados con la programaci¢n
de este dispositivo que son el estado de los botones (si se encuentran pulsados
o no) y el estado de las cuatro direcciones de control principales.

Para acceder a estos campos se debe preceder el nombre del campo
por la palabra {joy} y el s¡mbolo {#1063,. (punto)}, por ejemplo, para
acceder al campo {left} (que indica si se est  pulsando el control izquierda)
se debe utilizar {joy.left}.

{/}

{left} - Este campo estar  a {1} cuando el {joystick} est‚ orientado hacia la
{izquierda}, y a {0} en caso contrario.

{right}  - Este campo estar  a {1} cuando el {joystick} est‚ orientado hacia la
{derecha}, y a {0} en caso contrario.

{up}  - Este campo estar  a {1} cuando el {joystick} est‚ orientado hacia
{arriba}, y a {0} en caso contrario.

{down}  - Este campo estar  a {1} cuando el {joystick} est‚ orientado hacia
{abajo}, y a {0} en caso contrario.

Por ejemplo, para realizar en un programa una acci¢n {cuando se mueva
el joystick hacia la derecha} ({joy.right}) se debe incluir en el c¢digo
una sentencia como la siguiente:

  {IF (joy.right)}ú
    // Acci¢n a realizar (sentencias)ú
  {END}ú

Para las posiciones en diagonal se deben comprobar los dos campos que
conforman esa diagonal; por ejemplo, para realizar una acci¢n cuando el
{joystick} est‚ en la diagonal superior derecha se utilizar  la siguiente
sentencia:

  {IF (joy.up AND joy.right)}ú
    // Acci¢n a realizar (sentencias)ú
  {END}ú

{/}

{button1}, {button2}, {button3} y {button4} - Estos campos indican el estado
de hasta cuatro botones del joystick, estando a {1} cuando el bot¢n respectivo
est‚ pulsado, y a {0} cuando no lo est‚.

Algunos joystick s¢lo tienen 2 botones; en este caso, ser n los botones
n£mero 0 y 1. En ordenadores con dos joystick conectados el segundo joystick
tendr  los botones n£mero 2 y 3.

{/}

{Nota:} Cuando se requiera una lectura anal¢gica del {joystick} (conocer las
coordenadas exactas en las que est  situada la "palanca" del joystick), se
deber  utilizar la funci¢n {#122,get_joy_position()}. Obviamente, esta funci¢n
ser  util £nicamente en {joystick} anal¢gicos, no funcionando en los digitales.

{/}Ver: {#1200,Datos globales} - {#122,get_joy_position()} - {#121,get_joy_button()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1104,GLOBAL STRUCT setup}

{STRUCT setup;}ú
    {card;}     // Tipo de tarjetaú
    {port;}     // Puerto de accesoú
    {irq;}      // Interrupci¢n requeridaú
    {dma;}      // Canal de acceso a memoriaú
    {dma2;}     // Canal de acceso de 16 bitú
    {mixer;}    // Tipo de mezcladorú
    {rate;}     // Frecuencia m xima (bitrate)ú
    {bits;}     // Calidad 8 o 16 bitsú
    {master;}   // Volumen maestro (general)ú
    {sound_fx;} // Volumen de los efectosú
    {cd_audio;} // Volumen de m£sica CDú
{END}ú

Esta estructura de datos es de nivel muy avanzado y no es en absoluto
necesaria para crear ning£n juego, por complejo que ‚ste sea, ya que el
gestor de procesos de DIV Games Studio se encargar , normalmente, del hardware
de sonido de forma transparente.

Todos los campos referentes al hardware de sonido se actualizan de manera
autom tica por el programa si se tiene una tarjeta de sonido, siempre y
cuando se tenga la variable de entorno {BLASTER} o {GRAVIS} debidamente
inicializada.

Esta estructura de un £nico registro contiene una serie de campos divididos
en dos grupos: los primeros para activar nuevos par metros del hardware de
sonido instalado en el ordenador y los segundos para ajustar los diferentes
controles de volumen gestionados por el mezclador ({mixer}) del sistema de
sonido.

{/}

{Importante:}

Para activar los nuevos par metros del hardware de sonido que se introduzcan
en esta estructura se debe llamar a la funci¢n {#175,reset_sound()}.

Para activar los nuevos niveles de volumen que se introduzcan en la estructura
(en los campos {master}, {sound_fx} y {cd_audio}) se debe llamar a la funci¢n
{#178,set_volume()}.

Esta estructura se utiliza generalmente dentro de los programas de configuraci¢n
del sistema de sonido (ver {#1093,setup_program}).

{Nota:} Para acceder a estos campos se debe preceder el nombre del campo
por la palabra {setup} y el s¡mbolo {#1063,. (punto)}; por ejemplo, para
acceder al campo {master} (que indica el nivel de volumen general del mezclador)
se debe utilizar {setup.master}.

{/}

Se muestra, a continuaci¢n, una descripci¢n algo m s detallada de cada uno
de los campos de esta estructura.

{card} - Indica el tipo de tarjeta de sonido instalada en el ordenador.
El programa admite tarjetas de las familias {Sound Blaster} (tm) y {Gravis Ultra
Sound} (tm) y todas las que sean compatibles {100%} con ‚stas.

Los valores que puede tomar este campo son los siguientes, depediendo del tipo
de tarjeta de sonido:

    Sin tarjeta o sin sonido = {0}ú
    Sound Blaster 1.5        = {1}ú
    Sound Blaster 2.0        = {2}ú
    Sound Blaster Pro        = {3}ú
    Sound Blaster 16         = {4}ú
    Sound Blaster AWE        = {5}ú
    Gravis Ultra Sound       = {6}ú
    Gravis Ultra Sound MAX   = {7}ú

{/}

{port} - Indica el puerto de comunicaciones del ordenador en el cual se
deben escribir y leer los datos de la tarjeta de sonido.

Los valores que puede tomar este campo son los siguientes, dependiendo del
puerto asignado al hardware de sonido:

    0x210 = {0}ú
    0x220 = {1}ú
    0x230 = {2}ú
    0x240 = {3}ú
    0x250 = {4}ú
    0x260 = {5}ú

{/}

{irq} - Este campo indica el n£mero de interrupci¢n o IRQ (Interrupt request)
asignado a la tarjeta de sonido activa.

Los valores que puede tomar este campo son, dependiendo de la interrupci¢n
utilizada por la tarjeta, los siguientes:

    IRQ 2   = {0}ú
    IRQ 3   = {1}ú
    IRQ 5   = {2}ú
    IRQ 7   = {3}ú
    IRQ 10  = {4}ú
    IRQ 11  = {5}ú
    IRQ 12  = {6}ú
    IRQ 13  = {7}ú
    IRQ 14  = {8}ú
    IRQ 15  = {9}ú

{/}

{dma} - En este campo se debe indicar el n£mero de canal de acceso directo
a memoria (DMA) que utiliza la tarjeta de sonido.

Este campo puede tomar valores de 0 a 10, dependiendo directamente del n£mero
de canal.

{/}

{dma2} - Algunas tarjetas de sonido tienen disponible un segundo canal de
acceso directo a memoria m s r pido que el anterior, de 16 bits, denominado
com£nmente HDMA, DMA2 o DMA16.

Como el campo anterior de esta estructura, ‚ste podr  tomar valores del 0
al 10 dependiendo del n£mero de canal de 16 bits utilizado por la tarjeta.

{/}

{mixer} - Tipo de mezclador utilizado por el sistema de sonido, puede ser
una de estas dos constantes:

  {fast_mixer} - Mezclador r pido de los canales de sonido (1).ú
  {quality_mixer} - Mezclador de calidad m xima (2).ú

Por defecto, todos los programas tendr n activado el mezclador r pido
({setup.mixer=fast_mixer;}) ya que este es el modo m s r pido, y la diferencia
de calidad no es muy grande.

{/}

{rate} - Frecuencia m xima permitida (bit rate), entre {11025} (calidad de sonido
m¡nima permitida) y {44100} (calidad CD). Por defecto, todos los programas se configuran
a 44100 ({setup.rate=44100;}), no obstante esto puede cambiarse, ya que a mayor calidad, m s lento
ser  el sistema de sonido, y m s tiempo de procesador consume.

Se entiende que el valor especificado en {setup.rate} es la {calidad m xima}
de sonido, lo que quiere decir que todos los efectos de sonido cargados se
adaptar n a esta calidad en caso de tener una mayor. Es decir, que los efectos
grabados a una frecuencia de 11025 seguir n sonando con calidad pobre, aunque
la frecuencia m xima permitida sea mayor.

{/}

{bits} - Resoluci¢n de las muestras de los efectos digitales y m¢dulos musicales,
este campo puede tener uno de estas dos constantes como valores:

  {sound_bits_8} - Muestras de 8 bit.ú
  {sound_bits_16} - Muestras de 16 bit.ú

El efecto es similar al valor especificado en el campo {rate}, los sonidos con {8 bit} suenan
peor (tambi‚n ocupan menos espacio) y los de {16 bit} son de m s calidad. El valor
indicado en {setup.bits} indicar  la profundidad de muestra m xima.

Por defecto, todos los programas activar n las muestras de {16 bit}
({setup.bits=sound_bits_8;)), ya que la diferencia de calidad es m s que notable.

{/}

{master} - Este campo contiene el volumen general o maestro de salida de la
tarjeta. Aqu¡ se debe indicar un n£mero entre 0 (volumen m¡nimo) y 15 (volumen
m ximo). El valor por defecto es {15}, el volumen m ximo.

Si se disminuye el volumen maestro afectar  tanto al volumen de los efectos
de sonido como al volumen de reproducci¢n de la m£sica de cd audio.

{/}

{sound_fx} - Este campo controla el volumen al que los efectos de sonido que
se ejecutan con la funci¢n {#159,sound()} son reproducidos.

Este volumen es independiente del utilizado con las funciones de sonido
siendo, este volumen, general para todos los efectos de sonido y el indicado
en las funciones el espec¡fico para cada sonido.

Este campo tambi‚n puede oscilar entre 0 (volumen m¡nimo) y 15 (volumen
m ximo), siendo el valor por defecto el volumen m ximo.

{/}

{cd_audio} - Este campo controla el volumen de la m£sica que ser  reproducida
a partir de pistas de audio de un CD ROM o de un Compact Disc.

Al igual que los dos campos anteriores, este campo tambi‚n puede oscilar
entre 0 (volumen m¡nimo) y 15 (volumen m ximo) siendo el valor por defecto
el volumen m ximo.

{/}Ver: {#1200,Datos globales} - {#175,reset_sound()} - {#178,set_volume()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1105,GLOBAL timer[]}

{timer[9];} // Contadores de tiempo{/}

sta es una tabla global con 10 posiciones, desde {timer[0]} hasta {timer[9]},
y cada una de estas 10 posiciones es un contador de {cent‚simas de segundo} que
se va incrementando autom ticamente.

Al comienzo del programa estos 10 contadores ser n puestos a cero. Se utilizan
para cronometrar tiempos dentro de un programa, para lo que pueden ser puestos
a cero en cualquier momento.

Se dispone de 10 contadores para que el usuario pueda dedicar cada uno de ellos
a realizar una cuenta diferente dentro del juego; es indiferente cu les de los
10 contadores se utilicen. Normalmente, si el programa necesita un s¢lo contador
(en la mayor¡a de ocasiones) se suele utilizar el n£mero {0} ({timer[0]}), ya
que el lenguaje permite omitir el cero entre corchetes en este caso, es decir,
si £nicamente se necesita un contador, se puede utilizar simplemente {timer}.

Por ejemplo, para implementar un proceso que a los 5 segundos del inicio de
su ejecuci¢n (de haberlo llamado) realizara una acci¢n determinada, se
construir¡a el mismo de una forma similar a ‚sta (utilizando, por ejemplo,
el contador timer[9]):

 {PROCESS proceso_ejemplo();}ú
 {BEGIN}ú
     {timer[9]=0;}ú
     // ...ú
     {LOOP}ú
         {IF (timer[9]>=500)}ú
             // Acci¢n a realizar ...ú
         {END}ú
         // ...ú
         {FRAME;}ú
     {END}ú
 {END}ú

{/}

{Nota 1:} Como la cuenta se realiza en cent‚simas de segundo, en cada imagen del juego
estos contadores se pueden incrementar en {1} cent‚sima, {2}, {3}, {4}, etc., es decir,
en un ejemplo como el anterior no se puede esperar a que {timer[9]} sea
exactamente igual a {500}, ya que una imagen podr¡a indicar {497} cent‚simas
transcurridas (desde su puesta a cero con {timer[9]=0;}) y la siguiente
imagen {502} cent‚simas, sin haber pasado por el valor {500}.

{/}

{Nota 2:} Es tambi‚n importante resaltar que se deben tomar precauciones para que no
haya en el programa varios procesos utilizando el mismo contador para diferentes
fines.

Si, por ejemplo, se creara un {proceso_ejemplo()} (como el anterior), en cada imagen del juego
‚stos no llegar¡an nunca a ejecutar la acci¢n de los cinco segundos, ya que
cada uno de ellos pondr¡a a {0} el contador {timer[9]} al comienzo de su
ejecuci¢n invalidando, de esta forma, la cuenta de los procesos anteriores.

Teniendo en cuenta que el contador timer[9] es {#1006,GLOBAL}, es decir, es el mismo para todos los
procesos del juego, si un proceso lo pone a {0}, lo pondr  a {0} para
el resto de los procesos.

{/}

{Nota 3:} Por £ltimo se debe tener cuidado con las condiciones similares
a la del ejemplo anterior ({IF (timer[9]>=500) ... }) ya que estas condiciones
no se activar n £nicamente {una vez a los 5 segundos}, sino que se activar n
{todas las veces despu‚s de los primeros 5 segundos}.

Para poder comprender mejor el problema, se muestra a continuaci¢n un proceso
que realiza una acci¢n, {£nicamente una vez}, a los cinco segundos de haberse
iniciado su ejecuci¢n.

 {PROCESS proceso_ejemplo();}ú

 {PRIVATE}ú
     {acci¢n_realizada=FALSE;}ú

 {BEGIN}ú
     {timer[9]=0;}ú
     // ...ú
     {LOOP}ú
         {IF (timer[9]>=500) AND NOT acci¢n_realizada)}ú
             // Acci¢n a realizar ...ú
             {acci¢n_realizada=TRUE;}ú
         {END}ú
         // ...ú
         {FRAME;}ú
     {END}ú
 {END}ú

Se utiliza una variable privada denominada {acci¢n_realizada} que, en un
principio, ser  {falsa}. Para realizar la acci¢n ahora se requerir  que
hayan pasado m s de cinco segundos y que {no se haya realizado ya la acci¢n}.
Tras realizar ‚sta, se pondr  por tanto la variable {acci¢n_realizada} a {cierto}.

Para que el ejemplo anterior ejecutara la acci¢n {cada cinco segundos}
(indefinidamente), bastar¡a con volver a poner la sentencia {timer[9]=0;}
tras la {acci¢n a realizar}, no siendo necesaria, en esta caso, la variable
privada {acci¢n_realizada} ya que se necesitar¡an otros {5} segundos para
que {timer[9]} fuera otra vez mayor o igual que {500}.

{/}Ver: {#1200,Datos globales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1106,GLOBAL text_z}

{text_z=-256;} // Plano de profundidad de los textos{/}

En esta variable global se indica el plano de profundidad en el que deben
aparecer los textos en pantalla, esto es, qu‚ debe aparecer por encima de
los textos y qu‚ por debajo.

Los planos de profundidad pueden ser cualquier n£mero entero dentro
del rango ({#1177,min_int} ... {#1178,max_int}) y, cuanto mayor sea el
n£mero, m s al fondo se situar  el texto o gr fico.

Los gr ficos de los procesos tienen su variable {#1125,local z} a {0} por
defecto, los textos {text_z} a{ -256} y el puntero del rat¢n tiene
{#1100,mouse.z} a{ -512} por defecto.

Esto quiere decir que, por defecto, si no se no modifican estos valores,
aparecer n los textos sobre los gr ficos de los procesos y el puntero del
rat¢n sobre los textos.

Si, por ejemplo, se quisiera que aparecieran los textos sobre el puntero
del rat¢n (al rev‚s de lo establecido por defecto), se podr¡an hacer dos cosas:

{a)} Situar el plano del puntero m s abajo que el plano de los textos (un
n£mero mayor), como por ejemplo: {mouse.z=-200;} (ya que{ -200} es un n£mero
mayor que{ -256}).

{b)} Situar el plano de los textos m s arriba que el plano del puntero, como
por ejemplo {text_z=-600;} ya que{ -600} es un n£mero menor que{ -512} y,
por tanto, un plano de profundidad menor (menos profundo).

{/}

{Nota 1:} La variable {text_z} es {#1006,GLOBAL} para todos los textos, es decir, no
se pueden definir textos en diferentes planos de profundidad.

{Nota 2:} Los textos £nicamente pueden imprimirse con la funci¢n {#171,write()}
(textos alfanum‚ricos) o con la funci¢n {#172,write_int()} (valores num‚ricos de variables).

{/}Ver: {#1200,Datos globales} - {#171,write()} - {#172,write_int()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1107,GLOBAL fading}

{fading=FALSE;} // Indicador de fundido de pantalla{/}

Esta variable global indica si se est  realizando un fundido de pantalla
(una variaci¢n gradual de la paleta de colores del juego) en un momento
determinado, cuyo valor ser :

{#1152,false (0)} - Si {no} se est  realizando un fundido.

{#1151,true (1)} - Si se est  realizando un fundido.

La finalidad de esta variable es poder determinar cu ndo ha finalizado un
fundido de pantalla iniciado con las funciones {#110,fade()} o {#112,fade_on()}.

Al utilizar estas funciones se iniciar  un fundido de los colores de la paleta
que se ir n acercando gradualmente a los colores definitivos en las siguientes
im genes del juego, es decir, cada sentencia {#1029,FRAME} se realizar  una
parte del fundido.

Cuando se inicie un fundido, la variable {fading} pasar  autom ticamente a
valer {cierto} (1) y al finalizar ‚ste, volver  de nuevo a su valor original,
{falso} (0).

{/}

{Nota 1:} Generalmente, esta variable se utiliza para controlar a la funci¢n {#110,fade()},
y comprobar si ha terminado de ejecutarse (si ha terminado de realizarse
el fundido); cuando se quiera, por ejemplo, detener la ejecuci¢n del programa
hasta que finalice el fundido, lo que se puede hacer con una sentencia como
la siguiente (justo a continuaci¢n de la llamada a la funci¢n {#110,fade()}):

  {WHILE (fading)}ú
      {FRAME;}ú
  {END}ú

Literalmente esta sentencia define: "{mientras contin£e realiz ndose el
fundido, se debe visualizar otra nueva imagen}".

{Nota 2:} Todos los programas realizan un fundido ({#112,fade_on()}) al
inicio de su ejecuci¢n (autom ticamente), por lo que esta variable se
pondr  a {cierto (1)} al inicio de todos los programas hasta que finalice este
fundido inicial (mientras dure el "{encendido}" de pantalla).

{/}Ver: {#1200,Datos globales} - {#110,fade()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1108,GLOBAL shift_status}

{shift_status=0;} // Estado de las teclas especiales{/}

En esta variable global predefinida se indica el estado de distintas
teclas especiales como pueden ser las teclas [{ALT}], [{CONTROL}], etc.

Cada una de estas teclas tiene asignado un c¢digo que es el siguiente:

Tecla SHIFT o may£sculas derecho          = {1}ú
Tecla SHIFT o may£sculas izquierdo        = {2}ú
Teclas CONTROL                            = {4}ú
Teclas ALT y/o ALT GR                     = {8}ú
Tecla BLOQ DESPL o bloqueo desplazamiento = {16}ú
Tecla BLOQ NUM o de bloque num‚rico       = {32}ú
Tecla BLOQ MAYUS o bloqueo de may£sculas  = {64}ú
Tecla INSERT o inserci¢n                  = {128}ú

La variable {shift_status} contendr  la {suma de todos los c¢digos de las
teclas que est‚n pulsadas o activadas}.

Por ejemplo, si estuviera pulsada la tecla [{ALT}] y activada la tecla
[{BLOQ MAYUS}], la variable {shift_status} tendr¡a el valor {72} (8+64).

Para comprobar si una tecla como [{ALT}] est  pulsada, no se puede comprobar
que {shift_status} sea igual a {8}, ya que ‚sto implicar¡a que [{ALT}] es
la {£nica} tecla especial que est  pulsada o activada.

Para realizar esta comprobaci¢n correctamente se deber¡a realizar de la
siguiente forma:

  {IF (shift_status AND 8 == 8)}ú
      // Est  pulsada la tecla [ALT] ...ú
  {END}ú

{/}

{Nota:} Normalmente, para comprobar si una tecla est  pulsada, se utiliza la
funci¢n {#128,key()}. Pero con esta funci¢n no se puede determinar si
teclas como {BLOQ MAYUS} est n activadas, £nicamente si est n pulsadas o no.

Existen dos variables que contienen el c¢digo de la £ltima tecla que se ha pulsado;
{#1110,scan_code} (c¢digo {scan} de la £ltima tecla pulsada) y {#1109,ascii}
(c¢digo {ascii} de la £ltima tecla pulsada).

{/}Ver: {#1200,Datos globales} - {#128,key()} - {#1109,ascii} - {#1110,scan_code}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1109,GLOBAL ascii}

{ascii=0;} // C¢digo ASCII de la £ltima tecla pulsada{/}

Esta variable global indica siempre el c¢digo ASCII de la {£ltima tecla
pulsada} en la £ltima imagen del juego.

La variable {ascii} estar  a {0} si no se ha pulsado ninguna tecla en la
imagen anterior del juego.

Los c¢digos ASCII son una relaci¢n de car cteres (letras, n£meros y s¡mbolos)
enumerados del {0} al {255} que se han convertido en est ndar. Los c¢digos
inferiores al 32 son los denominados car cteres de control, del 32 al
127 son el juego de car cteres internacional y, a partir del n£mero 128,
aparece el juego de car cteres extendido (seg£n el est ndar de PC). A
continuaci¢n, se muestran los car cteres ASCII internacionales y extendidos.

{Resumen de c¢digos ASCII est ndar del PC}{/}033 21{ !}³097 61{ a}³161 A1{ ¡}³225 E1{ á}ú
034 22{ "}³098 62{ b}³162 A2{ ¢}³226 E2{ â}ú
035 23{ #}³099 63{ c}³163 A3{ £}³227 E3{ ã}ú
036 24{ $}³100 64{ d}³164 A4{ ¤}³228 E4{ ä}ú
037 25{ %}³101 65{ e}³165 A5{ ¥}³229 E5{ å}ú
038 26{ &}³102 66{ f}³166 A6{ ¦}³230 E6{ æ}ú
039 27{ '}³103 67{ g}³167 A7{ §}³231 E7{ ç}ú
040 28{ (}³104 68{ h}³168 A8{ ¨}³232 E8{ è}ú
041 29{ )}³105 69{ i}³169 A9{ ©}³233 E9{ é}ú
042 2A{ *}³106 6A{ j}³170 AA{ ª}³234 EA{ ê}ú
043 2B{ +}³107 6B{ k}³171 AB{ «}³235 EB{ ë}ú
044 2C{ ,}³108 6C{ l}³172 AC{ ¬}³236 EC{ ì}ú
045 2D{ -}³109 6D{ m}³173 AD{ ­}³237 ED{ í}ú
046 2E{ .}³110 6E{ n}³174 AE{ ®}³238 EE{ î}ú
047 2F{ /}³111 6F{ o}³175 AF{ ¯}³239 EF{ ï}ú
048 30{ 0}³112 70{ p}³176 B0{ °}³240 F0{ ğ}ú
049 31{ 1}³113 71{ q}³177 B1{ ±}³241 F1{ ñ}ú
050 32{ 2}³114 72{ r}³178 B2{ ²}³242 F2{ ò}ú
051 33{ 3}³115 73{ s}³179 B3{ ³}³243 F3{ ó}ú
052 34{ 4}³116 74{ t}³180 B4{ ´}³244 F4{ ô}ú
053 35{ 5}³117 75{ u}³181 B5{ µ}³245 F5{ õ}ú
054 36{ 6}³118 76{ v}³182 B6{ ¶}³246 F6{ ö}ú
055 37{ 7}³119 77{ w}³183 B7{ ·}³247 F7{ ÷}ú
056 38{ 8}³120 78{ x}³184 B8{ ¸}³248 F8{ ø}ú
057 39{ 9}³121 79{ y}³185 B9{ ¹}³249 F9{ ù}ú
058 3A{ :}³122 7A{ z}³186 BA{ º}³250 FA{ ù}ú
059 3B{ ;}³123 7B{ {{}}³187 BB{ »}³251 FB{ û}ú
060 3C{ <}³124 7C{ |}³188 BC{ ¼}³252 FC{ ü}ú
061 3D{ =}³125 7D{ {}}}³189 BD{ ½}³253 FD{ ı}ú
062 3E{ >}³126 7E{ ~}³190 BE{ ¾}³254 FE{ ş}ú
063 3F{ ?}³127 7F{ }³191 BF{ ¿}³255 FF{ ÿ}ú
064 40{ @}³128 80{ €}³192 C0{ À}ú
065 41{ A}³129 81{ }³193 C1{ Á}ú
066 42{ B}³130 82{ ‚}³194 C2{ Â}ú
067 43{ C}³131 83{ ƒ}³195 C3{ Ã}ú
068 44{ D}³132 84{ „}³196 C4{ Ä}ú
069 45{ E}³133 85{ …}³197 C5{ Å}ú
070 46{ F}³134 86{ †}³198 C6{ Æ}ú
071 47{ G}³135 87{ ‡}³199 C7{ Ç}ú
072 48{ H}³136 88{ ˆ}³200 C8{ È}ú
073 49{ I}³137 89{ ‰}³201 C9{ É}ú
074 4A{ J}³138 8A{ Š}³202 CA{ Ê}ú
075 4B{ K}³139 8B{ ‹}³203 CB{ Ë}ú
076 4C{ L}³140 8C{ Œ}³204 CC{ Ì}ú
077 4D{ M}³141 8D{ }³205 CD{ Í}ú
078 4E{ N}³142 8E{ }³206 CE{ Î}ú
079 4F{ O}³143 8F{ }³207 CF{ Ï}ú
080 50{ P}³144 90{ }³208 D0{ Ğ}ú
081 51{ Q}³145 91{ ‘}³209 D1{ Ñ}ú
082 52{ R}³146 92{ ’}³210 D2{ Ò}ú
083 53{ S}³147 93{ “}³211 D3{ Ó}ú
084 54{ T}³148 94{ ”}³212 D4{ Ô}ú
085 55{ U}³149 95{ •}³213 D5{ Õ}ú
086 56{ V}³150 96{ –}³214 D6{ Ö}ú
087 57{ W}³151 97{ —}³215 D7{ ×}ú
088 58{ X}³152 98{ ˜}³216 D8{ Ø}ú
089 59{ Y}³153 99{ ™}³217 D9{ Ù}ú
090 5A{ Z}³154 9A{ š}³218 DA{ Ú}ú
091 5B{ [}³155 9B{ ›}³219 DB{ Û}ú
092 5C{ \}³156 9C{ œ}³220 DC{ Ü}ú
093 5D{ ]}³157 9D{ }³221 DD{ İ}ú
094 5E{ ^}³158 9E{ }³222 DE{ Ş}ú
095 5F{ _}³159 9F{ Ÿ}³223 DF{ ß}ú
096 60{ `}³160 A0{  }³224 E0{ à}{/}

Un c¢digo ASCII hace referencia, por tanto, al {car cter que ha sido producido
con la £ltima pulsaci¢n del teclado} (o combinaci¢n de pulsaciones, en casos
como los de las letras acentuadas).

{/}

{Importante:} Existe otra variable global predefinida, denominada {#1110,scan_code}, que
tambi‚n contiene el c¢digo de la £ltima tecla pulsada pero, a diferencia de {ascii},
‚sta £ltima guarda el {c¢digo de rastreo} (scan code) de la tecla, es decir,
indica {qu‚ tecla ha sido pulsada} y no {qu‚ car cter ha sido generado} por
la misma (como {ascii}).

Existe una serie de constantes que designan estos {#1176,c¢digos de teclas} (c¢digos
de rastreo del teclado). Acceda a la ayuda sobre estos {#1176,c¢digos de teclas}
para observar, adem s, un {programa ejemplo} con las variables {ascii} y {scan_code}.

Normalmente, para comprobar si una tecla est  siendo pulsada, se utiliza
simplemente la funci¢n {#128,key()} del lenguaje, que recibe como par metro
uno de estos {#1176,c¢digos de teclas}, y devuelve {0} si la tecla no est 
pulsada o {1} cuando s¡ lo est .

{/}Ver: {#1200,Datos globales} - {#1110,scan_code} - {#128,key()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1110,GLOBAL scan_code}

{scan_code=0;} // C¢digo de rastreo de la £ltima tecla pulsada{/}

Esta variable global indica siempre el c¢digo de rastreo (scan code) de la
{£ltima tecla pulsada} en la £ltima imagen del juego.

La variable {scan_code} estar  a {0} si no se ha pulsado ninguna tecla en la
imagen anterior del juego.

Se utiliza muchas veces esta variable para esperar en un programa a que el
usuario pulse una tecla (cualquiera), con una sentencia como la siguiente:

  {WHILE (scan_code == 0)}ú
      {FRAME;}ú
  {END}ú

Esta sentencia indica que mientras no se haya pulsado una tecla en la
imagen anterior (mientras {scan_code} sea igual a {0}), se deben seguir
visualizando im genes del juego.

Los {c¢digos de rastreo} son simplemente una relaci¢n num‚rica de las
teclas del PC; estos c¢digos pueden variar ligeramente (en alguna tecla)
de un teclado a otro, ya que hay teclados de diferentes idiomas, con un
n£mero variado de teclas, etc.

Sin embargo, se mantienen constantes casi todos los c¢digos de las principales
teclas. Hay predefinida una lista de constantes (sin¢nimos para estos c¢digos)
en el lenguaje que se puede ver accediendo a la ayuda sobre {#1176,c¢digos de
teclas} (o c¢digos de rastreo del teclado); son, precisamente, estos valores
num‚ricos los que ser n asignados a la variable {scan_code} cuando las
respectivas teclas sean pulsadas en el programa.

{/}

{Importante:} Existe otra variable global predefinida, denominada {#1109,ascii}, que
tambi‚n contiene el c¢digo de la £ltima tecla pulsada pero, a diferencia de {scan_code},
‚sta £ltima guarda el {c¢digo ASCII} (car cter) generado por la tecla, es decir,
indica {qu‚ car cter ha generado la £ltima tecla pulsada} y no qu‚ {tecla
ha sido pulsada} (como {scan_code}).

Acceda a la ayuda sobre los {#1176,c¢digos de teclas} para observar un
{programa ejemplo} con las variables {ascii} y {scan_code}.

Normalmente, para comprobar si una tecla est  siendo pulsada se utiliza
simplemente la funci¢n {#128,key()} del lenguaje, que recibe como par metro
uno de estos {#1176,c¢digos de teclas}, y devuelve {0} si la tecla no est 
pulsada o {1} cuando si lo est .

{/}Ver: {#1200,Datos globales} - {#1109,ascii} - {#128,key()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1111,GLOBAL joy_filter}

{joy_filter=10;} // Filtro aplicado al joystick{/}

Esta variable global se utiliza para definir el filtro aplicado a las
coordenadas le¡das del joystick.

Se define como un porcentaje de {0 %} a {99 %}; por defecto {joy_filter}
valdr  {10} (se aplicar  un filtro de un 10%).

La utilidad de aplicar este filtro a las coordenadas del joystick es para
suavizar los movimientos del mismo y evitar posibles "{picos}" en la lectura
de las coordenadas; dichas coordenadas del joystick se deben obtener con la
funci¢n {#122,get_joy_position()}. La variable {joy_filter} £nicamente ser 
de utilidad cuando se est‚ utilizando ‚sta £ltima funci¢n.

Cuanto mayor sea el filtro aplicado m s se suavizar n los movimientos del
mismo, pero tambi‚n se retardar  su respuesta.

Dado que la funci¢n cometida por este "{filtro}" es algo dif¡cil de comprender,
se muestra a continuaci¢n un ejemplo.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_joy_filter;
BEGIN
    write(0, 0, 0, 0, "joy_filter=");
    write_int(0, 70, 0, 0, offset joy_filter);
    write(0, 160, 180, 1, "El gr fico se muestra en las coordenadas del joystick");
    write(0, 160, 190, 1, "Utilice las teclas arriba/abajo para variar el filtro");
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    LOOP
        IF (scan_code==_up AND joy_filter<99)
            joy_filter++;
        END
        IF (scan_code==_down AND joy_filter>0)
            joy_filter--;
        END
        x=get_joy_position(0);
        y=get_joy_position(1);
        FRAME;
    END
END
{-}

Este programa imprime el gr fico de una bola en las coordenadas devueltas
por el joystick principal mediante la funci¢n {#122,get_joy_position()}.

Se puede observar como, para valores peque¤os de {joy_filter}, se producen
muchos "{picos}" (irregularidades) en la lectura, y como para valores muy
grandes (como 95%) se produce una lectura de las coordenadas mucho m s suave
y regular, pero ligeramente retardada.

{Nota:} Es imprescindible tener un joystick (o gamepad) conectado al ordenador
para que esta variable tenga utilidad. Si el joystick se conecta durante la
ejecuci¢n del programa, el sistema no lo detectar  (debe estar conectado desde
el inicio). Ver la variable global {#1112,joy_status}.

{/}Ver: {#1200,Datos globales} - {#122,get_joy_position()} - {#1112,joy_status}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1112,GLOBAL joy_status}

{joy_status=0;} // Estado del joystick{/}

En esta variable gobal se indica el estado del joystick (o gamepad) conectado
al ordenador. Los valores que toma esta variable por defecto son:

{0} - Si el sistema de lectura del joystick est  desactivado. Este valor
quiere decir que no se ha encontrado un joystick conectado al ordenador al
inicio de la ejecuci¢n del programa, o bien que ‚ste ha sido desconectado.

{1} - Si el sistema de lectura del joystick est  activo. ste es el valor
inicial por defecto, pero si se desconecta el joystick (o no se encuentra
ninguno conectado), se desactivar  el sistema de lectura (indicando un {0}
en la variable joy_status).

Si el sistema est  desactivado, se puede volver a activar simplemente asignando
de nuevo un {1} a {joy_status} (con la sentencia {joy_status=1;}), pero si
pasado un tiempo l¡mite no se detecta un joystick, el sistema se volver 
a desactivar.

{/}

Existe un {modo especial} en el que el sistema de lectura del joystick {no
se desactivar  nunca}; este modo se define simplemente {asignando un 2 a
joy_status}.

  {joy_status=2;} // Activa modo especialú

No obstante, se debe tener cuidado ya que si el sistema de lectura del
joystick est  activado de este modo, sin haber un joystick conectado al ordenador, {puede
ralentizarse la ejecuci¢n del juego}.

{/}

{Nota:} La lectura del joystick suele realizarse en los programas accediendo
a la {#1103,estructura global joy} que indica, siempre, la direcci¢n del mismo
y el estado de sus botones (si est n pulsados o no).

{/}Ver: {#1200,Datos globales} - {#1103,Estructura joy} - {#1111,joy_filter}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1113,GLOBAL restore_type}

{restore_type=complete_restore;} // Tipo de restauraci¢n{/}

Esta variable global indica el tipo de restauraci¢n que se debe realizar
tras cada imagen en la pantalla.

Se llama {restauraci¢n del fondo} a recuperar las zonas de pantalla
en las que se han pintado gr ficos o escrito textos en la imagen anterior,
es decir, "{despintar}" los gr ficos y "{desescribir}" los textos (borrarlos).

Hay tres tipos de restauraci¢n aplicables que se corresponden, directamente,
con tres constantes que pueden ser asignadas a la variable {restore_type}.

{#1172,no_restore}       - El m s r pido, no se restaura el fondo (-1)ú
{#1173,partial_restore}  - Medio, restauraciones parciales (0)ú
{#1174,complete_restore} - El m s lento, restauraci¢n completa (1)ú

Por defecto, el valor de {restore_type} es {complete_restore}, es decir,
que si no se indica otro valor en esta variable se realizar  una restauraci¢n
completa de pantalla tras cada imagen del juego.

Esta modalidad de restauraci¢n (completa) es la m s lenta de las tres, por lo
que seguramente se podr  ganar velocidad de ejecuci¢n en el juego (para que vaya
m s fluido en los ordenadores lentos), si se le asigna otro valor a esta variable.
Por ejemplo, para indicar una restauraci¢n parcial, se debe utilizar la siguiente
sentencia:

  {restore_type=partial_restore;}

Con ella se indicar¡a al gestor de procesos de DIV Games
Studio que, tras las siguientes im genes del juego, se debe restaurar
parcialmente el fondo de la pantalla (£nicamente las zonas de pantalla
sobre las que se hayan puesto gr ficos o textos).

La modalidad m s r pida es {no_restore} (no restaurar el fondo de la pantalla);
sin embargo, ‚sta es aplicable solamente cuando el juego se desarrolle dentro de
una ventana de scroll o de modo 7 que ocupe toda la pantalla. En caso
contrario los gr ficos dejar n rastros (de las im genes anteriores) al moverse
por pantalla.

Se puede cambiar la modalidad de restauraci¢n durante la ejecuci¢n de un
programa tantas veces como sea necesario, seg£n los requerimientos de las
fases (o secciones) que se ejecuten en cada momento.

{/}

{Nota:} Existe otra variable global relacionada tambi‚n con la gesti¢n que DIV
Games Studio realiza de la pantalla; ‚sta es {#1114,dump_type} que define
el tipo de {volcado} de im genes que debe realizarse (qu‚ informaci¢n
debe enviarse al monitor tras cada imagen del juego).

{/}Ver: {#1200,Datos globales} - {#1114,dump_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1114,GLOBAL dump_type}

{dump_type=complete_dump;} // Tipo de volcado{/}

Esta variable global indica el tipo de volcado de im genes a pantalla
que se debe realizar en cada imagen del juego.

Se denomina {volcado} a cuando se env¡an las im genes del juego
al monitor (a la memoria de v¡deo de la tarjeta gr fica).

{/}

Hay dos tipos de volcado aplicables que se corresponden, directamente,
con dos constantes que pueden ser asignadas a la variable {dump_type}.

{#1170,partial_dump} - Se realizar n {volcados parciales} si se indica
con la siguiente sentencia:

  {dump_type=partial_dump;}

En este modo, s¢lo se volcar n en pantalla los gr ficos que se actualicen,
que hayan variado respecto a la imagen anterior. Este volcado conviene activarlo
{para ganar velocidad} cuando se programe un juego (o una secci¢n del
mismo) sin una ventana de scroll o modo 7 que ocupe toda la pantalla,
es decir, cuando el juego muestre movimientos de gr ficos sobre un
fondo fijo, o bien cuando las ventanas activas de scroll o modo 7 sean
m s peque¤as que la pantalla.

{#1171,complete_dump} - Se realizar n {volcados completos} si se indica
con la siguiente sentencia:

  {dump_type=complete_dump;}

En este modo, se volcar  toda la pantalla sin importar si los gr ficos han
cambiado o no. ste es m s lento que el {volcado parcial}, sin embargo es
el que se debe utilizar cuando el juego tenga una ventana de scroll o modo 7
que ocupe toda la pantalla.

{/}

Por defecto, el valor de {dump_type} es {complete_dump}, es decir,
que si no se indica otro valor en esta variable se realizar n {volcados
completos} de la pantalla tras cada imagen del juego (lo que suele ser
{m s lento} que realizar volcados parciales).

Se puede cambiar la modalidad de volcado durante la ejecuci¢n de un
programa tantas veces como sea necesario, seg£n los requerimientos de las
fases (o secciones) que se ejecuten en cada momento.

{/}

{Nota:} Existe otra variable global relacionada tambi‚n con la gesti¢n que DIV
Games Studio realiza de la pantalla; ‚sta es {#1113,restore_type} que define
el tipo de {restauraci¢n} que debe realizarse en la pantalla tras cada imagen
del juego (qu‚ gr ficos o qu‚ textos deben ser borrados).

{/}Ver: {#1200,Datos globales} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1115,GLOBAL max_process_time}

{max_process_time=500;} // Tiempo m ximo de ejecuci¢n{/}

Los programas est n dotados de un mecanismo {anti-bloqueo} que
har  que el gestor de procesos de DIV Games Studio interrumpa su
ejecuci¢n cuando un proceso supere el {tiempo m ximo de ejecuci¢n}
en una imagen del juego.

Este tiempo m ximo es el que se indica en la variable global
{max_process_time} en {cent‚simas de segundo}; su valor por
defecto es de {500 cent‚simas} ({5 segundos}).

Es decir, cuando un proceso tarde m s tiempo del aqu¡ indicado en
ejecutar una sentencia {#1029,FRAME} (que indica que el proceso
est  ya preparado para la siguiente imagen del juego), se producir 
un error de ejecuci¢n.

{Nota:} La utilidad que tiene la posibilidad de cambiar esta variable, asign ndole
un nuevo valor, es para que en los programas en los que exista un
proceso, que deba estar realizando c lculos durante bastante tiempo,
no se produzca este error.

Para indicar al gestor de procesos, por ejemplo, que no se debe
interrumpir un proceso, a no ser que est‚ m s de 30 segundos de
ejecuci¢n en una imagen se debe utilizar una sentencia como la
siguiente:

  {max_process_time=3000;}

Ya que 30 segundos son 3000 cent‚simas de segundo.

{/}

{Importante:} Se debe tener en cuenta que no todos los ordenadores
tardan lo mismo en realizar los c lculos del programa, por lo que hay que definir este valor
con cierto margen, para que no se supere el {tiempo m ximo de ejecuci¢n}
cuando el juego sea ejecutado en ordenadores m s lentos.

{/}Ver: {#1200,Datos globales} - {#1029,Sentencia FRAME}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1116,LOCAL STRUCT reserved}

{STRUCT reserved;}ú
    {process_id;}     // Identificador del procesoú
    {id_scan;}        // Indice de procesosú
    {process_type;}   // Tipo de procesoú
    {type_scan;}      // Indice de tiposú
    {status;}         // Estado del procesoú
    {param_offset;}   // Direcci¢n de los par metrosú
    {program_index;}  // Contador de programaú
    {is_executed;}    // Proceso ejecutadoú
    {is_painted;}     // Proceso pintadoú
    {distance_1;}     // Reservado modo 7ú
    {distance_2;}     // Reservado modo 7ú
    {frame_percent;}  // Porcentaje de imagenú
    {box_x0, box_y0;} // Inicio del gr fico del procesoú
    {box_x1, box_y1;} // Final del gr fico del procesoú
    {m8_object;}      // Objeto dentro del mundo m8ú
    {old_ctype;}      // Antiguo Ctypeú
    {f_count;}        // Contador de anidamiento de funci¢nú
    {caller_id;}      // Proceso o funci¢n llamadora (0 si fu‚ el kernel)ú
    {stack_pointer;}  // Puntero de pila del procesoú
{END}ú

En esta estructura se guardan distintas {variables de uso interno}
(utilizadas por el {gestor de procesos de DIV Games Studio}).

Son variables locales reservadas para el sistema. No es necesario
conocer estas variables ya que la gran mayor¡a no son de utilidad
en la creaci¢n de programas.

{Importante:} Modificar los valores de estas variables provocar ,
muy probablemente, un {bloqueo} del ordenador, un funcionamiento
indebido del {gestor de procesos} o problemas al utilizar muchas
de las funciones internas. No se asume ninguna responsabilidad
por tanto, sobre los posibles problemas derivados del uso indebido
de la estructura {reserved}.

{/}

Se mostrar , por tanto, una {breve descripci¢n} de cada uno de estos
campos, £nicamente con fines documentativos.

{process_id} - {#1039,C¢digo identificador} del proceso; este valor se
obtiene normalmente con la palabra reservada {#1092,ID} y no se
debe modificar el valor de este campo.

{id_scan} - Se utiliza internamente al detectar las colisiones para
guardar registro del {#1039,c¢digo identificador} del £ltimo proceso que ha
colisionado con el proceso actual.

{process_type} - Tipo del proceso actual, que se
obtiene normalmente con el operador {#1042,TYPE}, indicando el nombre
del proceso a continuaci¢n (ver {#1042,Tipos de procesos}).

{type_scan} - Se utiliza internamente para detectar colisiones
u obtener c¢digos identificadores de procesos de un tipo determinado.

{status} - Estado actual del proceso. Los valores que puede
adoptar este campo son los siguientes:

  {0} - proceso inexistente.ú
  {1} - proceso que ha recibido una se¤al {s_kill}.ú
  {2} - proceso vivo o despierto (s_wakeup).ú
  {3} - proceso dormido (s_sleep).ú
  {4} - proceso congelado (s_freeze).ú

{param_offset} - Direcci¢n de la memoria del ordenador en la que
est n situados los par metros que ha recibido el proceso.

{program_index} - Contador de programa. Direcci¢n de la memoria del
ordenador en la que se encuentra la primera sentencia que debe
ejecutar el proceso en la siguiente imagen.

{is_executed} - Indica si este proceso ha sido ya ejecutado en la
imagen actual.

{is_painted} - Indica si el gr fico del proceso ha sido ya pintado
en la imagen actual del juego.

{distance_1} - Distancia vertical del proceso (reservado para procesos
que se visualicen en una ventana de modo 7).

{distance_2} - Distancia horizontal del proceso (ocurre lo mismo que en la
sentencia anterior).

{frame_percent} - Porcentaje de la siguiente imagen completado por
el proceso; ‚ste valor ser  de utilidad cuando se utilice la sentencia
{#1029,FRAME} indicando un porcentaje. En caso contrario valdr  simplemente
0 (0%) cuando el proceso no ha sido ejecutado y 100 (100%) cuando ya lo
haya sido.

{box_x0, box_y0} - Coordenada superior izquierda del gr fico en la
imagen anterior del juego (donde se situ¢ el gr fico en coordenadas
de pantalla).

{box_x1, box_y1} - Coordenada inferior derecha del gr fico en la
imagen anterior del juego.

{m8_object} - N£mero de objeto dentro de un modo 8, se indica un ordinal
relativo al mapa de sectores.

{old_ctype} - Antiguo valor de la variable local ctype, se utiliza para
controlar cambios de  mbito en las coordenadas de un proceso.

{f_count} - Contador de anidamiento de funcion, para controlar el n£mero
de retornos y poder nivelar la pila para cada proceso.

{caller_id} - C¢digo identificador del proceso o funcion que ha invocado
a este (0 si fu‚ el kernel qui‚n lanz¢ este proceso en esta imagen).

{stack_pointer}  - Puntero de pila local de cada proceso, mantiene la
direcci¢n de la pila a la entrada del proceso, con los par metros apilados.

{/}Ver: {#1201,Datos locales} - {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1117,LOCAL father}

{father;} // {#1039,C¢digo identificador} del proceso padre{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {father}.

Esta variable contiene siempre el {#1039,c¢digo identificador} del proceso
que cre¢ (llam¢) al proceso actual (el que posee esta variable), es
decir, indica qu‚ proceso fue el que lo invoc¢.

Dentro del lenguaje se denomina proceso padre al que llama a otro
proceso, y proceso hijo al que ha sido llamado. Para m s informaci¢n
ver las {#1041,jerarqu¡as de procesos} en el lenguaje.

El {gestor de procesos} de DIV es el proceso denominado {div_main}
y es el encargado de crear el proceso principal del programa ({PROGRAM})
al comienzo de la ejecuci¢n del juego. Por lo tanto, ‚ste ser  el padre
del programa principal, as¡ como el padre de todos los procesos
que queden hu‚rfanos (procesos cuyo padre haya muerto o finalizado
antes que ellos, ver {#1040,estados de un proceso}).

{/}

{Nota:} El {#1039,c¢digo identificador} del proceso hijo se indica
en la variable local predefinida {#1118,son}.

{/}Ver: {#1201,Datos locales} - {#1039,C¢digo identificador} - {#1041,Jerarquias de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1118,LOCAL son}

{son=0;} // {#1039,C¢digo identificador} del proceso hijo{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {son}.

Esta variable contiene siempre el {#1039,c¢digo identificador} del
{£ltimo} proceso que ha creado (llamado) el proceso actual, es decir,
indica cu l es el {£ltimo} proceso invocado.

Dentro del lenguaje se denomina proceso padre al que llama a otro
proceso, y proceso hijo al que ha sido llamado. Para m s informaci¢n
ver las {#1041,jerarqu¡as de procesos} en el lenguaje.

Esta variable estar  por defecto a {0} hasta que el proceso realice
una llamada a otro proceso, momento en el cual se crear  el nuevo proceso
indicando su {#1039,c¢digo identificador} en {son}.

{/}

{Nota:} El {#1039,c¢digo identificador} del proceso padre se indica
en la variable local predefinida {#1117,father}.

{/}Ver: {#1201,Datos locales} - {#1039,C¢digo identificador} - {#1041,Jerarqu¡as de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1119,LOCAL smallbro}

{smallbro=0;} // {#1039,C¢digo identificador} del hermano menor{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {smallbro}.

Esta variable contiene siempre el {#1039,c¢digo identificador} del
siguiente proceso que cre¢ el padre del proceso actual tras ‚l, es
decir, cuando el proceso que invoc¢ al actual invocara a alg£n otro
despu‚s, esta variable indicar  cu l.

A este proceso se le denomina {hermano menor} dentro del lenguaje.
Para m s informaci¢n ver las {#1041,jerarqu¡as de procesos} en el lenguaje.

Esta variable estar  por defecto a {0} hasta que el proceso padre
realice una llamada a otro proceso, momento en el cual se crear  el
nuevo proceso (el hermano menor de ‚ste), indicando su {#1039,c¢digo
identificador} en {smallbro} (de "small brother").

{/}

{Nota:} El {#1039,c¢digo identificador} del {hermano mayor} se indica
en la variable local predefinida {#1120,bigbro}.

{/}Ver: {#1201,Datos locales} - {#1039,C¢digo identificador} - {#1041,Jerarqu¡as de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1120,LOCAL bigbro}

{bigbro=0;} // {#1039,C¢digo identificador} del hermano mayor{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {bigbro}.

Esta variable contiene siempre el {#1039,c¢digo identificador} del
proceso que cre¢ el padre justo antes de crear al proceso actual, es
decir, cuando el proceso que invoc¢ al actual hubiera creado otro
antes, ‚sta variable indicar  cu l.

A este proceso se le denomina {hermano mayor} dentro del lenguaje.
Para m s informaci¢n ver las {#1041,jerarqu¡as de procesos} en el
lenguaje.

Esta variable estar  a {0} si el proceso padre (el que invoc¢ al
proceso actual) no hubiera creado ning£n otro antes. En caso de
que hubiera creado uno, o m s de uno, {bigbro} (de "big brother")
indicar¡a el {#1039,c¢digo identificador} del £ltimo de ellos.

{/}

{Nota:} El {#1039,c¢digo identificador} del {hermano menor} se indica
en la variable local predefinida {#1119,smallbro}.

{/}Ver: {#1201,Datos locales} - {#1039,C¢digo identificador} - {#1041,Jerarqu¡as de procesos}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1121,LOCAL priority}

{priority=0;} // Nivel de prioridad del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {priority}.

En la preparaci¢n de cada imagen todos los procesos ser n ejecutados en
el orden de prioridad establecido por la variable local {priority}.

Cuanto mayor sea el valor de {priority} en un proceso, antes ser 
procesado ‚ste en cada imagen. El valor de priority puede fijarse
como cualquier n£mero entero dentro del rango ({#1177,min_int} ...
{#1178,max_int}); por ejemplo, para establecer el nivel de prioridad
de un proceso a {10} se debe utilizar la siguiente sentencia:

  {priority=10;}

Todos los procesos activos en el programa que tengan {el mismo nivel
de prioridad} ser n ejecutados en un {orden indeterminado} que,
adem s, puede variar de unas ejecuciones del juego a otras.

Por defecto la variable local {priority} estar  inicializada a {0}
en todos los procesos creados en el programa, por lo que ‚stos
podr n ser ejecutados en cualquier orden, si no se define el valor
de esta variable.

Si se fija la {priority} de un s¢lo proceso a un
n£mero positivo, como 1, ‚ste ser  ejecutado antes que el resto
de los procesos, y si se fija a un n£mero negativo, como -1, entonces
ser  ejecutado tras el resto (suponiendo que la variable {priority}
del resto no se ha modificado, por lo que sigue valiendo {0}).

{Cuando se debe fijar la prioridad de los procesos}{/}

Cuando un proceso necesite utilizar en sus c lculos datos de otro
proceso, suele ser conveniente que se ejecute tras ‚l, definiendo
su prioridad m s baja, para que al leer los datos del otro proceso,
‚stos ya est‚n actualizados.

Por ejemplo, si el proceso {B} debe situar su gr fico 8 puntos m s
abajo que el gr fico del proceso {A}, se debe fijar la prioridad
de {A} mayor que la de {B}, para que ‚ste se ejecute primero.

De esta forma, cuando el proceso {B} obtenga su coordenada {y} sumando
8 a la del proceso {A}, se realice este c lculo con la coordenada {y} del proceso {A}
ya actualizada para la siguiente imagen (para asegurar que en cada imagen
primero se fijar  la coordenada {y} del proceso {A} y despu‚s la
del proceso {B}).

Para conseguir ‚sto, como ambas prioridades estar n por defecto a {0}, bastar¡a con
definir la prioridad de {A} como {1}, o bien definir la prioridad
de {B} como{ -1}.

{/}

{Nota:} El nivel de prioridad del proceso no tiene nada que ver
con el plano de profundidad en el que aparece su gr fico en pantalla,
ya que ‚ste se indica en la variable {#1125,local z}. Es decir, que
un gr fico se procese antes no implica que su gr fico se pinte antes.

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1122,LOCAL ctype}

{ctype=c_screen;} // Sistema de coordenadas{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {ctype}.

En esta variable se indica el {sistema de coordenadas} utilizado por
el proceso, es decir, c¢mo deben ser interpretadas las coordenadas
del proceso (contenidas en las variables locales {#1123,x} e {#1124,y}).

Se pueden utilizar tres sistemas de coordenadas diferentes,
que se corresponden directamente con tres constantes que pueden ser asignadas
a la variable {ctype}.

  {#1167,c_screen} - Coordenadas de pantallaú
  {#1168,c_scroll} - Coordenadas de scrollú
  {#1169,c_m7}     - Coordenadas de modo 7ú
  {#1412,c_m8}     - Coordenadas de modo 8ú

{El valor por defecto de ctype es} {#1167,c_screen}, el utilizado para que
las coordenadas del gr fico del proceso se interpreten como referidas
a la pantalla, donde la esquina superior izquierda es la (0, 0).

Se asignar  {#1168,c_scroll} a {ctype} con la siguiente sentencia:

 {ctype=c_scroll;}

Para que las coordenadas del
gr fico del proceso se interpreten como referidas a una ventana de
scroll, a coordenadas sobre el gr fico del primer plano.

Se asignar  {#1169,c_m7} a {ctype} con la siguiente sentencia:

 {ctype=c_m7;}

Para que las coordenadas del
gr fico del proceso se interpreten como referidas a una ventana de
modo 7, a coordenadas sobre el gr fico principal, abatido tridimensionalmente
en dicha ventana.

Se asignar  {#1412,c_m8} a {ctype} con la siguiente sentencia:

 {ctype=c_m8;}

Para que las coordenadas del
gr fico del proceso se interpreten como referidas a una ventana de
modo 8, a coordenadas sobre un mapa de sectores tridimensional.

{/}

{Nota:} Existe otra variable local que tambi‚n afecta al modo en el
que deben ser interpretadas las coordenadas del proceso; ‚sta es
{#1135,resolution} y establece la resoluci¢n (escala) en la que se
definen las coordenadas.

{/}Ver: {#1201,Datos locales} - {#1167,c_screen} - {#1168,c_scroll} - {#1169,c_m7} - {#1412,c_m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1123,LOCAL x}

{x=0;} // Coordenada horizontal del gr fico{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {x}.

La variables locales {x} e {#1124,y} de los procesos definen d¢nde
debe situarse el gr fico de los mismos (definido en la variable local
{#1126,graph}).

La variable local {x} define la {coordenada horizontal} del proceso,
que se puede definir como un n£mero entero dentro del rango ({#1177,min_int} ...
{#1178,max_int}), situ ndose las coordenadas positivas hacia la derecha
y las negativas hacia la izquierda.

Por defecto, estas coordenadas se especificar n en {puntos} (p¡xeles),
referidos a coordenadas de pantalla, donde la esquina superior izquierda
es el punto situado en ({0}, {0}).

{Tipo de coordenadas}{/}

Hay varios sistemas de coordenadas que pueden ser utilizados por los
procesos y que se definen con la variable local {#1122,ctype}, el
sistema por defecto son las coordenadas relativas a la pantalla.

{Resoluci¢n de las coordenadas}{/}

La variable local {#1135,resolution} indica la precisi¢n de las coordenadas
del proceso; por defecto, esta variable valdr  {0} y las coordenadas ({x}, {#1124,y})
se especifican en puntos.

Cuanto mayor sea el valor de {#1135,resolution}, m s peque¤a (y precisa) ser 
la unidad en la que se interpretan las coordenadas, a continuaci¢n se
muestran algunos ejemplos:

{resolution=1;} - Las coordenadas se especifican en puntos.

{resolution=10;} - Se especifican en d‚cimas de puntos.

{resolution=100;} - Se especifican en cent‚simas de puntos.

{resolution=2;} - Se especifican en mitades de punto.

...

{/}

{Nota:} Se puede definir para cada proceso un tipo y resoluci¢n de coordenadas
diferente, as¡ como cambiarlos en tiempo de ejecuci¢n cuando sea
necesario.

{/}

{Importante:} Cuando se sit£a un gr fico en unas coordenadas determinadas,
normalmente ser  el {centro} del gr fico el que se sit£e en dichas
coordenadas.

Esto se puede cambiar definiendo en el {editor gr fico} el {#1136,punto
de control} n£mero {0} del gr fico del proceso (cuyo {c¢digo de gr fico}
se indica en la variable {#1126,graph}).

Si se ha definido el punto de control, ser  ‚ste el que se sit£e en
las coordenadas especificadas.

Por ejemplo, si se sit£a el punto de control {0} en la esquina
superior izquierda del gr fico y, posteriormente, se pone el gr fico
en las coordenadas (100, 100), se posicionar  la esquina superior
izquierda del gr fico en dichas coordenadas.

{/}Ver: {#1201,Datos locales} - {#1122,ctype} - {#1135,resolution}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1124,LOCAL y}

{y=0;} // Coordenada vertical del gr fico{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {y}.

La variables locales {#1123,x} e {y} de los procesos definen d¢nde
debe situarse el gr fico de los mismos (definido en la variable local
{#1126,graph}).

La variable local {y} define la {coordenada vertical} del proceso,
que se puede definir como un n£mero entero dentro del rango ({#1177,min_int} ...
{#1178,max_int}), situ ndose las coordenadas positivas hacia abajo
y las negativas hacia arriba.

Por defecto, estas coordenadas se especificar n en {puntos} (p¡xeles),
referidos a coordenadas de pantalla, donde la esquina superior izquierda
es el punto situado en ({0}, {0}).

{Tipo de coordenadas}{/}

Hay varios sistemas de coordenadas que pueden ser utilizados por los
procesos y que se definen con la variable local {#1122,ctype}, el
sistema por defecto son las coordenadas relativas a la pantalla.

{Resoluci¢n de las coordenadas}{/}

La variable local {#1135,resolution} indica la precisi¢n de las coordenadas
del proceso; por defecto, ‚sta variable valdr  {0} y las coordenadas ({#1123,x},{y})
se especifican en puntos.

Cuanto mayor sea el valor de {#1135,resolution}, m s peque¤a (y precisa) ser 
la unidad en la que se interpretan las coordenadas, a continuaci¢n se
muestran algunos ejemplos:

{resolution=1;} - Las coordenadas se especifican en puntos.

{resolution=10;} - Se especifican en d‚cimas de puntos.

{resolution=100;} - Se especifican en cent‚simas de puntos.

{resolution=2;} - Se especifican en mitades de punto.

...

{/}

{Nota:} Se puede definir para cada proceso un tipo y una resoluci¢n de coordenadas
diferente, as¡ como cambiarlos en tiempo de ejecuci¢n cuando sea
necesario.

{/}

{Importante:} Cuando se sit£a un gr fico en unas coordenadas determinadas,
normalmente ser  el {centro} del gr fico el que se sit£e en dichas
coordenadas.

sto se puede cambiar definiendo en el {editor gr fico} el {#1136,punto
de control} n£mero {0} del gr fico del proceso (cuyo {c¢digo de gr fico}
se indica en la variable {#1126,graph}).

Si se ha definido el punto de control, ser  ‚ste el que se sit£e en
las coordenadas especificadas.

Por ejemplo, si se sit£a el punto de control {0} en la esquina
superior izquierda del gr fico y, posteriormente, se pone el gr fico
en las coordenadas (100, 100), se posicionar  la esquina superior
izquierda del gr fico en dichas coordenadas.

{/}Ver: {#1201,Datos locales} - {#1122,ctype} - {#1135,resolution}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1125,LOCAL z}

{z=0;} // Plano de profundidad del gr fico del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {z}.

La variable local {z} define en qu‚ plano de profundidad debe situarse
el gr fico del proceso en la pantalla (el gr fico se define en la variable
local {#1126,graph}). Es decir, qu‚ debe aparecer por encima del gr fico
del proceso y qu‚ por debajo.

Los planos de profundidad pueden ser cualquier n£mero entero dentro
del rango ({#1177,min_int} ... {#1178,max_int}), y cuanto mayor sea el
n£mero, m s al fondo se situar  el gr fico (a mayor profundidad).

{/}

Por defecto, los planos de profundidad est n dispuestos de la siguiente
forma:

{ (+) Mayor profundidad}

{ +512} - Ventanas de scroll (ver {#1101,scroll[].z})ú
{ +256} - Ventanas de modo 7 (ver {#1102,m7[].z})ú
{  0}   - Gr ficos de los procesos (local {z})ú
{ -256} - Textos (ver {#1106,text_z})ú
{ -512} - Puntero del rat¢n (ver {#1100,mouse.z})ú

{ (-) Menor profundidad}

Es decir, la variable local {z} que define el plano de profundidad
de los gr ficos de los procesos estar  inicializada a {0}. Los gr ficos
de los procesos se situar n debajo del puntero del rat¢n
y los textos, y sobre las ventanas de scroll y modo 7 (si no se
modifican los valores por defecto).

{/}

Todos los objetos (textos, gr ficos, ventanas, ...) que se sit£en
en el mismo plano de profundidad aparecer n en pantalla (al superponerse
unos sobre otros) en un {orden indeterminado}, que puede variar de
unas ejecuciones del programa a otras.

Si se quisiera, por ejemplo, que el gr fico de un proceso apareciera
sobre todos los objetos del programa, se podr¡a fijar para el mismo
un plano de profundidad por encima del resto (como -1000}, con la
siguiente sentencia:

  {z=-1000;}

Inicialmente, todos los procesos tienen su variable {z} igual a {0},
luego los gr ficos de los procesos aparecer n en cualquier orden
si no se define en qu‚ plano debe situarse cada uno.

Se puede variar el plano de profundidad de un proceso (asignando un
nuevo valor a su variable {z}) tantas veces como sea necesario dentro
de un programa.

Los planos de profundidad del resto de objetos (ventanas, textos
y puntero del rat¢n) tambi‚n pueden variarse en cualquier momento
del programa.

{/}

{Nota 1:} Los procesos que pertenezcan a una {ventana de scroll} (que tengan
su variable {#1122,ctype}{=}{#1168,c_scroll}) se pintar n en el
{plano de profundidad de la ventana de scroll}; no obstante, dentro
de dicha ventana, todos los gr ficos de los procesos aparecer n
{ordenados por su plano de profundidad}.

Es decir, el plano de profundidad del proceso (indicado como siempre
en la variable {z}) ser  entonces {relativo a la ventana de scroll}
en la que aparece el proceso (ver {#163,start_scroll()}).

{/}

{Nota 2:} Los procesos que pertenezcan a una {ventana de modo 7} (que tengan
su variable {#1122,ctype}{=}{#1167,c_m7}) aparecer n en dicha ventana
{ordenados por estricto orden de profundidad en el plano tridimensional}
ignor ndose el valor de su variable local {z}.

El £nico sentido que tiene la variable local {z} en procesos de un
{modo 7} es definir el orden en el que deben superponerse los
procesos que est‚n {exactamente} en las mismas coordenadas del plano
abatido, es decir, si se sit£an dos procesos en el plano tridimensional
en las mismas coordenadas entonces se podr , con la variable {z},
definir cu l de ellos debe aparecer sobre el otro (ver {#162,start_mode7()}).

{/}Ver: {#1201,Datos locales} - {#1100,mouse.z} - {#1101,scroll[].z} - {#1102,m7[].z} - {#1106,text_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1126,LOCAL graph}

{graph=0;} // C¢digo del gr fico del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {graph}.

Normalmente, la mayor¡a de procesos se corresponden con un objeto
gr fico visualizado en pantalla que se situar  en las coordenadas
indicadas en las variables locales {#1123,x} e {#1123,y}. Se debe
definir qu‚ gr fico es el correspondiente a dicho proceso asignando
un {c¢digo de gr fico} a la variable local {graph}.

Por defecto, esta variable valdr  {0} lo que implica que no se
visualizar  ning£n gr fico para este proceso.

Los gr ficos se deben crear primero en el {editor gr fico} de DIV
Games Studio (con la opci¢n "{Nuevo...}" del men£ de mapas) y, despu‚s,
se pueden guardar en un {archivo MAP o PCX} (que contendr  este gr fico),
o en un {fichero FPG} junto a otros gr ficos (se puede crear un
fichero nuevo con la opci¢n "{Nuevo...}" del men£ de ficheros).

Es decir, los gr ficos utilizados en un programa pueden provenir de
un {archivo MAP o PCX} (que contiene un s¢lo gr fico) o de un {fichero FPG}
(que puede contener muchos gr ficos).

{Nota:} Un mismo gr fico puede ser utilizado por muchos procesos a
la vez en un programa.

{Archivos MAP o PCX}{/}

Para utilizar en el programa un gr fico de un {archivo MAP o PCX} se debe
cargar este llamando a las funciones {#174,load_map()} o {#174,load_pcx()}, que devolver n
el {c¢digo del gr fico} que se debe ser asignado a la variable {graph}.

Normalmente se utiliza una variable {#1006,GLOBAL} para guardar este
{c¢digo de gr fico} y despu‚s se asigna ‚sta a la variable {graph}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_graph;

GLOBAL
    gr fico1;

BEGIN
    gr fico1=load_map("help\help.map");

    graph=gr fico1; // Se define el gr fico del proceso.

    LOOP
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
{-}

Si bien en el ejemplo anterior se podr¡a haber prescindido de la variable
global {gr fico1} y haber asignado directamente el c¢digo devuelto
por la funci¢n {#174,load_map()} a la variable {graph} con la siguiente
sentencia:

  {graph=load_map("help\help.map");}

los {c¢digos de gr fico} que devuelve esta funci¢n son simplemente
n£meros enteros a partir de {1000}.

{Ficheros FPG}{/}

Para incluir un gr fico que se ha realizado en el {editor gr fico}
en un {fichero FPG} de debe {arrastrar la ventana del gr fico a la
ventana del fichero} (pulsar en el gr fico, moverse hasta el fichero
y soltar), entonces el programa pedir  el {c¢digo del gr fico}, con lo que se
debe introducir aqu¡ un n£mero entero entre {1} y {999}.

Para utilizar entonces el gr fico en un programa, se debe primero
cargar el {fichero FPG} que lo contiene con la funci¢n {#132,load_fpg()}
y, despu‚s, asignar el {c¢digo del gr fico} a la variable {graph}.

Se muestra, a continuaci¢n, un ejemplo es necesario saber antes que
un gr fico de una {bola marr¢n} se introdujo en el {fichero HELP.FPG}
indicando el {c¢digo de gr fico 100}.

{#9999,Programa ejemplo:}
PROGRAM ejemplo_graph;
BEGIN
    load_fpg("help\help.fpg");

    graph=100; // Se define el gr fico del proceso.

    LOOP
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
{-}

Se pueden cargar {varios ficheros FPG} en un programa; en ese caso
se deber  indicar, adem s del {c¢digo del gr fico} en la variable local
{graph}, el {c¢digo de fichero} que devuelve la funci¢n {#132,load_fpg()}
en la variable local {#1131,file}.

Si s¢lo se carga un fichero ‚sto no ser  necesario, ya que la variable
{#1131,file} vale {0} por defecto en todos los procesos y {0} ser  siempre
el {c¢digo del primer fichero} que se cargue en el programa.

{/}

Existen m s variables locales relacionadas con el gr fico de un
proceso, las principales son las siguientes:

  {graph}  - C¢digo del gr ficoú
  {#1131,file}   - C¢digo del ficheroú
  {#1123,x}, {#1124,y}   - Coordenadas del gr ficoú
  {#1125,z}      - Plano de profundidadú
  {#1129,angle}  -  ngulo del gr ficoú
  {#1128,size}   - Tama¤o del gr ficoú
  {#1127,flags}  - Espejados y transparenciasú
  {#1130,region} - Ventana de visualizaci¢nú

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1127,LOCAL flags}

{flags=0;} // Indicador de espejados y transparencia{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {flags}.

La variable local {flags} indica los espejados y transparencias con
los que se imprimir  el gr fico del proceso; los posibles valores son:

 {0}-Gr fico normal.ú
 {1}-Espejado horizontal.ú
 {2}-Espejado vertical.ú
 {3}-Espejado horizontal y vertical (180ø).ú
 {4}-Gr fico transparente.ú
 {5}-Transparente y espejado horizontal.ú
 {6}-Transparente y espejado vertical.ú
 {7}-Transparente, espejado horizontal y vertical.ú

El valor por defecto de la variable {flags} es {0}, es decir, que si
no se modifica el gr fico se mostrar  opaco (sin transparencia) y
sin espejar.

Se definen a continuaci¢n los t‚rminos de {espejado} y {transparencia}:

- {Espejado horizontal}, el gr fico se invertir  horizontalmente, es
decir, si estaba mirando hacia la izquierda, mirar  a la derecha y
viceversa.

- {Espejado vertical}, el gr fico se invertir  verticalmente, es
decir, si estaba mirando hacia arriba, mirar  hacia abajo y
viceversa.

- {Transparencia} (o {ghost-layering}), el gr fico se mostrar  semitransparente,
es decir, se podr  ver lo que haya detr s del gr fico, como si ‚ste
fuera una cristalera de colores, en contraposici¢n a los gr ficos
opacos que se muestran normalmente.

Por ejemplo, para que el gr fico de un proceso se muestre transparente
se debe utilizar la siguiente sentencia:

  {flags=4;}

{/}

{Nota:} El gr fico de un proceso se debe indicar asignando un {c¢digo
de gr fico} a la variable local {#1126,graph}.

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1128,LOCAL size}

{size=100;} // Tama¤o (en porcentaje) del gr fico{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {size}.

La variable local {size} define el tama¤o en el que se debe ver el
gr fico del proceso, en un porcentaje relativo a su tama¤o original.

El valor por defecto de esta variable ser  {100} (100%) para todos
los procesos, y cuando sea modificado el gr fico se {escalar }
(reduci‚ndose o ampli ndose) para ajustarse al nuevo tama¤o.

Es decir, para mostrar el gr fico al {doble} de su tama¤o se deber 
especificar un {200%}, lo que se har  con la siguiente sentencia:

  {size=200;}

Por lo tanto, si este valor es menor que {100} el gr fico se ver 
m s peque¤o, y si es mayor, m s grande.

En un principio no hay ning£n l¡mite para el tama¤o del gr fico, pero
si se pone la variable local {size} a {0} (0%), entonces no se ver 
el gr fico del proceso.

{/}

{Nota:} El gr fico de un proceso se debe indicar asignando un {c¢digo
de gr fico} a la variable local {#1126,graph}.

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1129,LOCAL angle}

{angle=0;} //  ngulo del gr fico del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {angle}.

La variable local {angle} define el  ngulo en el que se debe ver el
gr fico del proceso, indicando un  ngulo respecto al gr fico original
en {mil‚simas de grado} (ver {#1044,Uso de  ngulos en el lenguaje}).

El valor por defecto de esta variable ser  {0} (0 grados) para todos
los procesos, pero cuando sea modificado el gr fico se {rotar } para
ajustarse al nuevo  ngulo.

El  ngulo puede definirse como cualquier n£mero entero dentro del
rango ({#1177,min_int} ... {#1178,max_int}).

Se muestran a continuaci¢n algunos ejemplos de los  ngulos que
definen ciertos valores en la variable local {angle} (se recuerda
que los  ngulos se expresan en {mil‚simas} de grado):

      ...ú
 { -180000} - {#1044,Angulo} hacia la izquierdaú
 {  -90000} - {#1044,Angulo} hacia abajoú
 {  -45000} - {#1044,Angulo} de la diagonal abajo/derechaú
 {       0} - {#1044,Angulo} hacia la derechaú
 {  +45000} - {#1044,Angulo} de la diagonal derecha/arribaú
 {  +90000} - {#1044,Angulo} hacia arribaú
 { +180000} - {#1044,Angulo} hacia la izquierdaú
 { +270000} - {#1044,Angulo} hacia abajoú
      ...ú

{Importante:} Cuando se pretenda rotar el gr fico de un proceso,
{es conveniente dibujarlo orientado hacia la derecha}, ya que as¡ es
como se mostrar  por defecto (con la variable local {angle} igual
a {0}).

De esta forma, cuando se especifique otro  ngulo, el gr fico
aparecer  orientado exactamente hacia ‚l.

Por ejemplo, para que un gr fico que ha sido dibujado hacia la
derecha se vea orientado hacia arriba (hacia el  ngulo de 90 grados),
bastar  con indicar la siguiente sentencia:

  {angle=90000;} // 90 mil‚simas de grado (90 grados).

Es decir, si un gr fico se dibujara orientado hacia otro  ngulo,
por ejemplo hacia abajo, quedar¡a orientado hacia abajo por defecto,
{en el  ngulo 0}, lo que puede provocar confusiones a la hora de
orientar el gr fico hacia otro  ngulo.

{/}

Para hacer que el gr fico de un proceso avance sus coordenadas ({#1123,x}, {#1124,y})
hacia su  ngulo (el especificado en la variable local {angle} del proceso)
una distancia determinada, se puede utilizar la funci¢n {#101,advance()}.

{/}

{Nota:} El gr fico de un proceso se debe indicar asignando un {c¢digo
de gr fico} a la variable local {#1126,graph}.

{/}Ver: {#1201,Datos locales} - {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1130,LOCAL region}

{region=0;} // Regi¢n de pantalla asignada al proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {region}.

La variable local {region} define en qu‚ zona de pantalla debe ser
visible el gr fico del proceso, indicando el {n£mero de regi¢n}.

Una regi¢n es una zona rectangular de pantalla, como una ventana,
que est  asociada a un n£mero.

Por defecto, esta variable valdr  {0} en todos los procesos haciendo
referencia a la {regi¢n n£mero 0} que es {la pantalla entera}.

Es decir, que por defecto los gr ficos de los procesos ser n visibles
en toda la pantalla (en cualquier punto de la misma en el que est‚n).

En un principio, £nicamente est  definida la {regi¢n numero 0}.
Para definir nuevas regiones de pantalla se debe utilizar la funci¢n
{#106,define_region()}.

{/}

Por ejemplo, para que el gr fico de un proceso fuera visible s¢lo
dentro de una caja de 100 por 100 puntos situada en la esquina superior
izquierda de la pantalla (en las coordenadas 0, 0), primero se deber¡a
definir la nueva regi¢n la siguiente forma, suponiendo que se defina
la regi¢n n£mero {1}:

  {define_region(1, 0, 0, 100, 100);}

y, despu‚s, se deber¡a asignar el n£mero de regi¢n ({1}) a la variable
local {region} del proceso con la siguiente sentencia:

  {region=1;}

Las regiones pueden redefinirse en cualquier momento dentro de un
programa; esto es, se pueden cambiar de posici¢n o de tama¤o siempre
que sea necesario.

{/}

{Nota:} El gr fico de un proceso se debe indicar asignando un {c¢digo
de gr fico} a la variable local {#1126,graph}.

{/}Ver: {#1201,Datos locales} - {#106,define_region()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1131,LOCAL file}

{file=0;} // C¢digo del fichero del gr fico del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {file}.

La variable local {file} indica, en los casos en los que se hayan cargado
varios {ficheros FPG} de gr ficos en un programa, cu l es el fichero
que contiene el gr fico que est  utilizando el proceso.

El gr fico de un proceso se debe indicar asignando un {c¢digo
de gr fico} a la variable local {#1126,graph}.

Si £nicamente se ha cargado un fichero en el programa, no ser  necesario
asignar ning£n valor a {file}, ya que el {c¢digo del primer fichero cargado}
ser  el {0} y ‚ste es el valor por defecto de la variable.

Si el gr fico se ha cargado con las funciones {#174,load_map()} o {#174,load_pcx()}, tampoco
ser  necesario asignar ning£n valor a {file}, ya que los gr ficos cargados
con estas funciones se utilizan como si pertenecieran al fichero n£mero {0}
(al primero que se cargue en el programa).

Cuando se cargue m s de un fichero, se debe indicar en cada proceso
en cu l de ellos se encuentra su gr fico; esto se debe hacer asignando
el {c¢digo de fichero} que ha devuelto la funci¢n {#132,load_fpg()}
(al cargar dicho {fichero FPG}) a la variable local {file}.

{Nota:} Normalmente, si se cargan varios ficheros en un programa secuencialmente,
el primero tendr  el c¢digo {0}, el segundo el {1}, el tercero el {2} y, as¡ sucesivamente.

{/}

En general, es una buena pr ctica, si se utilizan varios ficheros,
tener el mismo n£mero de variables globales (denominadas por ejemplo
{fichero1}, {fichero2}, ...) que contengan el c¢digo de cada uno de
los ficheros, para utilizarlas en los procesos a la hora de definir
su variable {file} (el {fichero FPG} que se debe emplear).

Las variables se definir¡an dentro de la secci¢n {#1006,GLOBAL} de la
siguiente forma:

  {GLOBAL}ú
      {fichero1;} // C¢digo del primer ficheroú
      {fichero2;} // C¢digo del segundoú
      ...

Despu‚s, se les asignar¡a a estas variables los {c¢digos de fichero}
al cargar ‚stos con la funci¢n {#132,load_fpg()} de la siguiente
forma (suponiendo que el nombre de los ficheros es {nombre1.fpg},
{nombre2.fpg}, etc.):

  {fichero1=load_fpg("nombre1.fpg");} // Carga de ficherosú
  {fichero2=load_fpg("nombre2.fpg");}ú
  ...

Generalmente, esta carga de ficheros se realiza al inicio del programa;
posteriormente, dentro de cada proceso, solamente habr¡a que definir
el fichero utilizado con la siguiente sentencia (suponiendo que el proceso
utilice gr ficos contenidos en el fichero {nombre1.fpg}):

  {file=fichero1;} // Se utiliza el primer ficheroú

{/}

{Nota:} Se recuerda que definir la variable local {file} no sirve para nada,
a no ser que tambi‚n se asigne un {c¢digo de gr fico} a la variable local
{#1126,graph}.

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1132,LOCAL xgraph}

{xgraph=0;} // OFFSET de la tabla gr fica del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {xgraph}.

Esta variable es de nivel avanzado, por lo que requiere cierta experiencia
para su utilizaci¢n.

La variable local {xgraph} ({extended graphic}) sirve para utilizar
{gr ficos m£ltiples}. Para definir el gr fico de un proceso como un
{conjunto de gr ficos} de los cuales se debe ver {el m s acorde con
el  ngulo del proceso} (especificado en la variable local {#1129,angle}).

Es decir, si se define la variable {xgraph}, {se ignorar  la }variable local
{#1126,graph} que normalmente define el gr fico del proceso y se
utilizar  un gr fico u otro en funci¢n de la variable {#1129,angle}.

Por lo tanto, al cambiar el  ngulo del proceso {ya no aparecer 
el gr fico del proceso rotado}, sino que utilizar  este  ngulo como
seleccionador del gr fico del proceso (dentro del conjunto definido).

Por defecto la variable {xgraph} valdr  {0} en todos los procesos,
lo que indica que ‚stos no van a utilizar {gr ficos m£ltiples}.

{/}

La utilidad de los gr ficos m£ltiples reside en poder realizar juegos
en {perspectiva}, donde un cambio de  ngulo en un proceso no implica
una rotaci¢n de su gr fico, sino el cambio del gr fico por otro dibujado
con otra {perspectiva} (dibujado con otro  ngulo dentro de dicha perspectiva).

{Forma de empleo de los gr ficos m£ltiples}{/}

1 - En primer lugar se deben realizar los diferentes dibujos que van
a representar al gr fico del proceso con diferentes  ngulos en la
perspectiva. stos ser n un n£mero finito de vistas del gr fico, como
puede ser {4}, {8}, {12}, etc., (o cualquier otro n£mero entero mayor que {1}).

Se debe tener en cuenta que si se definen 4 vistas, se estar  definiendo
una vista diferente cada 90 grados, si se definen 8 vistas, cada 45
grados, etc.

2 - Se deben ordenar dichos gr ficos seg£n su  ngulo; primero el gr fico
que se corresponder  con el  ngulo 0 (hacia la derecha) y, despu‚s,
el resto en sentido contrario a las agujas del reloj.

3 - Se debe crear una tabla, generalmente {#1006,GLOBAL}, inicializada
con los siguientes valores:

  {N£mero de vistas del gr fico},ú
  {C¢digo del gr fico para el } ngulo {0 (primera vista)},ú
  {C¢digo del siguiente  ngulo (segunda vista)},ú
  ...

{Nota:} Esta tabla debe ser de datos simples (de tipo {#1402,INT}, enteros
de 32 bit con signo).

Es indiferente el nombre que se le de a dicha tabla, por ejemplo,
si se define un gr fico m£ltiple con 4 vistas, que deben ser los
gr ficos con el c¢digo 10, 11, 12, y 13, la definici¢n de la tabla
podr¡a ser:

  {GLOBAL}ú
      {tabla_gr fico1[]=4, 10, 11, 12, 13;}ú
      ....

4 - Por £ltimo, se debe asignar la direcci¢n de esta tabla dentro
de la memoria del ordenador a la variable local {xgraph} del proceso,
lo que se har¡a con la siguiente sentencia (dentro del proceso en cuesti¢n):

  {xgraph=OFFSET tabla_gr fico1;}

El operador {#1085,OFFSET} sirve para obtener la direcci¢n en la
memoria de un dato del programa.

{/}

Una vez definido el {gr fico m£ltiple}, el sistema utilizar  en
cada imagen del juego el gr fico correspondiente al  ngulo {que
m s se aproxima al  ngulo del proceso} (el indicado en su variable
{#1129,angle}).

Para desactivar el sistema de {gr ficos m£ltiples} en un proceso,
simplemente se debe volver a poner a {0} la variable {xgraph}.

{Importante:} Si dentro de la tabla que define el conjunto de gr ficos
se pone alg£n c¢digo de gr fico con {signo negativo}, entonces aparecer 
este gr fico {espejado horizontalmente}, es decir, si el gr fico
estaba mirando hacia la derecha, aparecer  mirando hacia la izquierda,
y viceversa.

{/}

{Nota:} El sistema de gr ficos m£ltiples se suele utilizar en las
{ventanas de modo 7}, ya que en el plano tridimensional abatido los
gr ficos se deben ver de distinta forma seg£n el  ngulo desde el que
se miren.

Para m s informaci¢n sobre esta t‚cnica, ver la funci¢n {#162,start_mode7()}
utilizada para activar una {ventana de modo 7} en el programa.

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1133,LOCAL height}

{height=0;} // Altura del gr fico (en el modo 7){/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {height}.

La variable local {height} se utiliza {exclusivamente} en los procesos
que pertenecen a {ventanas de modo 7}, es decir, procesos que tienen
su sistema de coordenadas dentro de una ventana tridimensional (su
variable local {#1122,ctype}={#1169,c_m7}).

Se utiliza para definir la altura a la que deben situarse los gr ficos
de los procesos sobre el plano tridimensional. No se utiliza para esto
la variable {#1125,local z}, porque ‚sta sigue utiliz ndose para definir
el plano de profundidad de los gr ficos (aunque ahora £nicamente sea
£til para procesos situados en las mismas coordenadas).

La altura del proceso puede definirse como cualquier n£mero entero dentro
del rango ({#1177,min_int} ... {#1178,max_int}), si bien se suelen
utilizar normalmente n£meros positivos, ya que la altura ({height})
del suelo es la {0} y los procesos se sit£an por encima de ‚ste.

El valor por defecto de la variable {height} es {0} para todos los
procesos, lo que quiere decir que si no se especifica otro valor,
los gr ficos de los procesos aparecer n justo sobre el suelo del
{modo 7} (sobre el plano tridimensionalmente abatido).

En un principio se situar  en la altura indicada en {height} la {base
del gr fico} del proceso, a no ser que se defina el {#1136,punto de
control} n£mero {0}, en cuyo caso ser  este punto el que se sit£e
en esa altura.

{Nota:} Para m s informaci¢n sobre las {ventanas de modo 7} y c¢mo situar
gr ficos dentro de estas ventanas, se debe ver la ayuda sobre la funci¢n
{#162,start_mode7()} que es la utilizada para activarlas en el programa.

{/}

En los procesos que no son de {modo 7} se puede utilizar esta variable
con cualquier otra finalidad, ya que el sistema la ignorar  por completo.

{/}Ver: {#1201,Datos locales} - {#162,start_mode7()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1134,LOCAL cnumber}

{cnumber=0;} // N£meros de ventanas de scroll o modo 7{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {cnumber}.

La variable local {cnumber} se utiliza {exclusivamente} cuando en un juego
aparezcan varias {ventanas de scroll} o varias {ventanas de modo 7}
simult neamente en pantalla.

- Para m s informaci¢n sobre las {ventanas de scroll}, se debe ver la
ayuda sobre la funci¢n {#163,start_scroll()}, que es la utilizada para
activarlas en el programa.

- Para m s informaci¢n sobre las {ventanas de modo 7}, se debe ver la
ayuda sobre la funci¢n {#162,start_mode7()}, que es la utilizada para
activarlas en el programa.

{/}

La utilidad de {cnumber} reside en indicar {en cu les de estas ventanas
debe verse el gr fico del proceso}. Evidentemente, esta variable se
debe definir s¢lo en procesos visibles dentro de las {ventanas
de scroll} o de las {ventanas de modo 7}; para el resto de procesos
(los procesos de pantalla o los que no tengan gr fico) esta variable
carece de utilidad.

{Si el proceso debe verse en todas las ventanas}, entonces no ser 
necesario modificar esta variable, ya que el valor por defecto de
{cnumber} (que es {0}) indica precisamente esto.

Puede activarse hasta {10} ventanas, tanto de un tipo como del otro,
con los n£meros del {0} al {9}. Existen diez constantes predefinidas
que se utilizan para definir el valor de {cnumber}; estas son
{#1175,c_0, c_1, c_2, ..., c_9} y se corresponden directamente con
las {10} posibles ventanas de estos tipos.

Se debe asignar a {cnumber la suma de las constantes} correspondientes
a las {ventanas en las que el proceso debe ser visible}.

Por ejemplo, si en un programa hay {4 ventanas de scroll} que son
las n£mero {0}, {1}, {2} y {3}, y se quiere definir que un proceso determinado
debe ser visible tan s¢lo dentro de las ventanas {0} y {2}, se
debe utilizar para esto la siguiente sentencia:

  {cnumber=c_0+c_2;}

El valor de {cnumber} puede variarse durante la ejecuci¢n del proceso
siempre que sea necesario.

{/}

{Nota:} Se recuerda que para que el gr fico del proceso se vea en
todas las ventanas no es necesario hacer nada, ya que ‚sta es la
opci¢n por defecto.

{/}Ver: {#1201,Datos locales} - {#1175,c_0...c_9}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1135,LOCAL resolution}

{resolution=0;} // Resoluci¢n de las coordenadas del proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {resolution}.

Normalmente, las coordenadas de un proceso (indicadas en las variables
locales {#1123,x} e {#1124,y}) se definen en puntos (de pantalla).

La variable local {resolution} se debe utilizar cuando se quieran definir
las coordenadas en {unidades m s peque¤as} que el punto.

Es decir, que esta variable indica la precisi¢n de las coordenadas
del proceso.

Por defecto la variable valdr  {0} y las coordenadas se
especificar n en puntos.

Cuanto mayor sea el valor de {#1135,resolution}, m s peque¤a (y precisa)
ser  la unidad en la que se interpretan las coordenadas; a continuaci¢n
se muestran algunos ejemplos:

{resolution=1;} - Las coordenadas se especifican en puntos (al igual
que con {resolution=0}, que es el valor por defecto).

{resolution=10;} - Se especifican en d‚cimas de puntos.

{resolution=100;} - Se especifican en cent‚simas de puntos.

{resolution=2;} - Se especifican en mitades de punto.

...

Por ejemplo, un proceso situado en {160}, {100} con {resolution} igual a
{0} (o {1}), estar  en la misma posici¢n que un proceso situado en
{1600}, {1000} y con {resolution} igual a {10}.

El valor de {resolution} se define normalmente como un {n£mero
entero positivo m£ltiplo de 10} (10, 100, 1000, ...).

{/}

En resumen, cuando se defina el valor de {resolution}, el gestor de
procesos de DIV Games Studio {dividir } las coordenadas de los procesos
entre {resolution} a la hora de pintar los gr ficos de los mismos
en pantalla.

{/}

{Importante:} Se deben extremar las precauciones cuando en un programa
existan varios procesos con diferentes resoluciones de coordenadas,
ya que algunas funciones, como {#117,get_dist()} (para obtener la
distancia entre dos procesos), devolver n {resultados incorrectos}
cuando se est‚ accediendo a dos procesos que utilicen diferente
resoluci¢n de coordenadas.

Suele ser conveniente que todos los procesos activos en el juego,
al menos todos los que interact£en entre ellos (se detecten, modifiquen
o puedan colisionar) utilicen la misma resoluci¢n.

{/}Ver: {#1201,Datos locales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1136,Puntos de control}

{+141,0}Los {puntos de control} se definen dentro del {editor gr fico}
con la barra de puntos de control, indicada con este icono.{-}

Para acceder al {editor gr fico} basta con hacer "{doble-click}" con
el rat¢n (dos pulsaciones seguidas del bot¢n izquierdo del rat¢n)
sobre un gr fico dentro del entorno (sobre una ventana de un mapa).

Los {puntos de control} son simplemente puntos que pueden localizarse
dentro de un gr fico, para diferentes funciones.

La {barra de puntos de control} permite situar hasta {1000} puntos
diferentes dentro de un gr fico, cada uno ser  identificado por su
n£mero (del {0} al {999}).

Para situar uno de estos puntos, basta con seleccionar el {n£mero de
punto} con los {iconos flecha izquierda} y {flecha derecha} y, despu‚s,
pulsar sobre el gr fico.

Para {borrar} (deseleccionar) un punto de control, se debe volver a
pulsar sobre el mismo en el gr fico una segunda vez.

{/}

El £nico {punto de control} que utiliza el sistema es el punto de
control n£mero {0} (el primero); ‚ste es el punto que define cu l
es el {centro virtual del gr fico} y que tiene m£ltiples aplicaciones
dentro del lenguaje.

Cuando no se defina el {punto de control n£mero 0}, el sistema
actuar  como si el centro virtual del gr fico fuera el {centro real
del mismo} (un punto situado en la mitad del ancho y la mitad del
alto del gr fico).

{/}

{Nota:} Una vez definidos los puntos de control, para que ‚stos tengan
efecto dentro de un programa, debe grabarse el {archivo MAP} (en los
archivos PCX no se pueden guardar los puntos de control) o volverse
a incluir el gr fico en el {fichero FPG} arrastr ndolo hasta el mismo
(seg£n cu l de ambos se cargue en el programa).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1150,Modos de v¡deo}

Constantes: {m320x200} ... {m1024x768}
{/}

Esta constantes sirven para indicar el modo de v¡deo en la funci¢n
{#157,set_mode()}. La lista completa de constantes es la siguiente:

    m320x200ú
    m320x240ú
    m320x400ú
    m360x240ú
    m360x360ú
    m376x282ú
    m640x400ú
    m640x480ú
    m800x600ú
    m1024x768ú

Cada constante indica el modo de v¡deo de la siguiente manera: primero,
la letra {m} y, luego, la resoluci¢n horizontal y vertical del modo separadas por
una {x}.

Los valores definidos para dichas constantes son los siguientes.

    m320x200  = 320200ú
    m320x240  = 320240ú
    m320x400  = 320400ú
    m360x240  = 360240ú
    m360x360  = 360360ú
    m376x282  = 376282ú
    m640x400  = 640400ú
    m640x480  = 640480ú
    m800x600  = 800600ú
    m1024x768 = 1024768ú

{/}

{Nota:} Adem s de estos modos de v¡deo est ndar, la estructura global
{#1415,video_modes} contiene una lista de todos los modos compatibles con
el est ndar VESA encontrados en el adaptador de v¡deo del sistema.

{/}Ver: {#1202,Constantes} - {#157,set_mode()} - {#1415,video_modes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1151,true}

Constante: {true}
{/}

Esta constante se utiliza para indicar valores {ciertos}, para inicializar variables l¢gicas o
definir par metros l¢gicos, es decir, que deben ser evaluados como una condici¢n.

Su valor es {1}, y como en el lenguaje se interpretan como {ciertos} todos
los n£meros {impares}, ‚sta constante ser  evaluada como una condici¢n
que siempre se cumple ({cierta}).

{/}

La constante {#1152,false} es la opuesta a ‚sta: la utilizada para
indicar valores l¢gicos {falsos}.

{/}Ver: {#1202,Constantes} - {#1152,false}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1152,false}

Constante: {false}
{/}

Esta constante se utiliza para indicar valores {falsos}, para inicializar variables l¢gicas o
definir par metros l¢gicos, es decir, que deben ser evaluados como una condici¢n.

Su valor es {0}, y como en el lenguaje se interpretan como {falsos} todos
los n£meros {pares}, esta constante ser  evaluada como una condici¢n
que nunca se cumple ({falsa}).

{/}

La constante {#1152,true} es la opuesta a ‚sta: la utilizada para
indicar valores l¢gicos {ciertos}.

{/}Ver: {#1202,Constantes} - {#1151,true}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1153,s_kill}

Constante: {s_kill}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {0}.

Esta se¤al transmite a los procesos la orden imperativa {kill}
(muerte). Se utiliza para eliminar procesos en el programa
(para hacer desaparecer ciertos objetos del juego).

Es decir, al enviarle una se¤al {s_kill} a un proceso, ‚ste ser 
eliminado y ya no aparecer  en las siguientes im genes del juego.

Una constante relacionada directamente con ‚sta es {#1157,s_kill_tree}, con la
diferencia de que, al enviar esta se¤al, se eliminar  al proceso indicado y
a sus {hijos}, que son los procesos que ‚ste hubiera creado.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa, es:

    {s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1157,s_kill_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1154,s_wakeup}

Constante: {s_wakeup}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {1}.

Esta se¤al transmite a los procesos la orden imperativa {wakeup}
(despierta). Se utiliza para devolver al estado normal los procesos
que han sido dormidos (con la se¤al {#1155,s_sleep}), o congelados
(con la se¤al {#1156,s_freeze}).

Es decir, al enviarle una se¤al {s_wakeup} a un proceso, ‚ste ser 
reactivado en las siguientes im genes del juego (se volver  a ver
y a procesar).

Una constante relacionada directamente con ‚sta es {#1158,s_wakeup_tree}, con la
diferencia de que, al enviar esta se¤al, se despertar  al proceso indicado y
a sus {hijos}, que son los procesos que ‚ste hubiera creado.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa, es:

    {#1153,s_kill}ú
    {s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú


{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1158,s_wakeup_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1155,s_sleep}

Constante: {s_sleep}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {2}.

Esta se¤al transmite a los procesos la orden imperativa {sleep}
(duerme). Se utiliza para dormir a un proceso. Un proceso dormido
no aparecer  en las siguientes im genes del juego, pero no ser 
eliminado, como con la se¤al {#1153,s_kill}, sino que podr  volver
a {despertarse} en cualquier momento con una se¤al {#1154,s_wakeup}.

Es decir, al enviarle una se¤al {s_sleep} a un proceso, ‚ste dejar 
de aparecer en las siguientes im genes del juego (hasta que sea
despertado o eliminado).

Una constante relacionada directamente con ‚sta es {#1159,s_sleep_tree}, con la
diferencia de que, al enviar esta se¤al, se dormir  al proceso indicado y
a sus {hijos}, que son los procesos que ‚ste hubiera creado.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa, es:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1159,s_sleep_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1156,s_freeze}

Constante: {s_freeze}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {3}.

Esta se¤al transmite a los procesos la orden imperativa {freeze}
(congelar). Se utiliza para congelar (inmovilizar) a un proceso.
Un proceso congelado seguir  apareciendo en las siguientes im genes
del juego, pero no ser  procesado, por lo que permanecer  inm¢vil.
Este proceso podr  volver a {activarse} en cualquier momento si se
le env¡a una se¤al {#1154,s_wakeup}.

Es decir, al enviarle una se¤al {s_freeze} a un proceso, ‚ste dejar 
de procesar (interpretar sus sentencias) en las siguientes im genes
del juego (hasta que sea activado o eliminado con {#1153,s_kill}).

Una constante relacionada directamente con ‚sta es {#1160,s_freeze_tree}, con la
diferencia de que, al enviar esta se¤al, se congelar  al proceso indicado y
a sus {hijos}, que son los procesos que ‚ste hubiera creado.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa es:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1160,s_freeze_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1157,s_kill_tree}

Constante: {s_kill_tree}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {100}.

Esta se¤al se utiliza para que un proceso y todos los procesos
que ‚ste haya creado sean {eliminados} envi ndoles la orden imperativa
{kill} (muerte). Es una versi¢n de la se¤al {#1153,s_kill}, que
elimina al proceso, pero no a los procesos que ‚ste haya creado.

Es decir, con {s_kill_tree} se {eliminar } al proceso y a toda su
descendencia, con lo que ya no aparecer  ninguno de ellos en las
siguientes im genes del juego.

La lista completa de las constantes que utilizadas como se¤ales, pueden
ser enviadas a los diferentes procesos de un programa es:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1153,s_kill}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1158,s_wakeup_tree}

Constante: {s_wakeup_tree}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {101}.

Esta se¤al se utiliza para que un proceso y todos los procesos
que ‚ste haya creado sean {despertados} envi ndoles la orden imperativa
{wakeup} (despertar). Es una versi¢n de la se¤al {#1154,s_wakeup}, que
despierta al proceso, pero no a los procesos que ‚ste haya creado.

Es decir, con {s_wakeup_tree} se {despertar } al proceso y a toda su
descendencia, volviendo todos estos procesos a su estado normal en las
siguientes im genes del juego.

Se puede despertar (reactivar) a procesos que han sido {dormidos}
con la se¤al {#1159,s_sleep_tree} o {congelados} con la se¤al
{#1160,s_freeze_tree}.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa es:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1154,s_wakeup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1159,s_sleep_tree}

Constante: {s_sleep_tree}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {102}.

Esta se¤al se utiliza para que un proceso y todos los procesos
que ‚ste haya creado sean {dormidos} envi ndoles la orden imperativa
{sleep} (dormir). Es una versi¢n de la se¤al {#1155,s_sleep}, que
duerme al proceso, pero no a los procesos que ‚ste haya creado.

Es decir, con {s_sleep_tree} se {dormir } al proceso y a toda su
descendencia, desapareciendo todos estos procesos en las
siguientes im genes del juego (pero sin ser eliminados).

Se puede despertar (reactivar) a estos procesos {dormidos}
con la se¤al {#1158,s_wakeup_tree}.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa es:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1155,s_sleep}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1160,s_freeze_tree}

Constante: {s_freeze_tree}
{/}

Esta constante se utiliza como par metro de la funci¢n
{#158,signal()} (para mandar se¤ales a los procesos).
Su valor es {103}.

Esta se¤al se utiliza para que un proceso y todos los procesos
que ‚ste haya creado sean {congelados} (inmovilizados) envi ndoles la orden imperativa
{freeze} (congelar). Es una versi¢n de la se¤al {#1156,s_freeze}, que
congela al proceso, pero no a los procesos que ‚ste haya creado.

Es decir, con {s_freeze_tree} se {congelar } al proceso y a toda su
descendencia, dejando de procesar todos estos procesos en las
siguientes im genes del juego (quedar n inmovilizados, pues no
ejecutar n sus sentencias).

Se puede descongelar (reactivar) a estos procesos {congelados}
con la se¤al {#1158,s_wakeup_tree}.

La lista completa de las constantes que utilizadas como se¤ales pueden
ser enviadas a los diferentes procesos de un programa es:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {s_freeze_tree}ú

{/}Ver: {#1202,Constantes} - {#158,signal()} - {#1156,s_freeze}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1161,all_text}

Constante: {all_text}
{/}

Esta constante se usa como par metro de la funci¢n {#107,delete_text()},
para eliminar {todos} los textos visualizados en el programa con las
funciones {#171,write()} y {#172,write_int()}.

Es decir, para que desaparezcan todos los textos que aparecen en
pantalla se debe ejecutar la siguiente sentencia:

  {delete_text(all_text);}

El valor que tiene asignado esta constante es {0}.

{/}Ver: {#1202,Constantes} - {#107,delete_text()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1162,all_sound}

Constante: {all_sound}
{/}

Esta constante se usa como par metro de la funci¢n {#167,stop_sound()},
para parar {todos} los efectos de sonido previamente activados con la
funci¢n {#159,sound()}.

Es decir, para detener todos los canales de sonido activos en un momento
determinado se debe ejecutar la siguiente sentencia:

  {stop_sound(all_sound);}

El valor que tiene asignado esta constante es{ -1}.

{/}Ver: {#1202,Constantes} - {#167,stop_sound()} - {#159,sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1163,g_wide}

Constante: {g_wide}
{/}

Esta constante se usa como par metro de la funci¢n {#126,graphic_info()},
para pedir informaci¢n sobre el {ancho} (en puntos) de un gr fico determinado.
Su valor es {0}.

Las constantes que pueden utilizarse como par metros de esta funci¢n son:

    {g_wide}ú
    {#1164,g_height}ú
    {#1165,g_x_center}ú
    {#1166,g_y_center}ú

{/}Ver: {#1202,Constantes} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1164,g_height}

Constante: {g_height}
{/}

Esta constante se usa como par metro de la funci¢n {#126,graphic_info()},
para pedir informaci¢n sobre el {alto} (en puntos) de un gr fico determinado.
Su valor es {1}.

Las constantes que pueden utilizarse como par metros de esta funci¢n son:

    {#1163,g_wide}ú
    {g_height}ú
    {#1165,g_x_center}ú
    {#1166,g_y_center}ú

{/}Ver: {#1202,Constantes} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1165,g_x_center}

Constante: {g_x_center}
{/}

Esta constante se usa como par metro de la funci¢n {#126,graphic_info()},
para pedir informaci¢n sobre el {centro horizontal} de un gr fico determinado.
Su valor es {2}.

El {centro horizontal} de un gr fico ser  la mitad del ancho (en puntos),
si no se ha definido en la herramienta de dibujo el {#1136,punto de control}
n£mero {0} (centro del gr fico).

Las constantes que pueden utilizarse como par metros de esta funci¢n son:

    {#1163,g_wide}ú
    {#1164,g_height}ú
    {g_x_center}ú
    {#1166,g_y_center}ú

{/}Ver: {#1202,Constantes} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1166,g_y_center}

Constante: {g_y_center}
{/}

Esta constante se usa como par metro de la funci¢n {#126,graphic_info()},
para pedir informaci¢n sobre el {centro vertical} de un gr fico determinado.
Su valor es {3}.

El {centro vertical} de un gr fico ser  la mitad del alto (en puntos),
si no se ha definido en la herramienta de dibujo el {#1136,punto de control}
n£mero {0} (centro del gr fico).

Las constantes que pueden utilizarse como par metros de esta funci¢n son:

    {#1163,g_wide}ú
    {#1164,g_height}ú
    {#1165,g_x_center}ú
    {g_y_center}ú

{/}Ver: {#1202,Constantes} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1167,c_screen}

Constante: {c_screen}
{/}

Esta constante se utiliza para asignarla a la variable local predefinida
{#1122,ctype} que sirve para definir el tipo de coordenadas que
tendr  un proceso. Su valor es {0}.

{Este es el valor por defecto de} {#1122,ctype}, el utilizado para que
las coordenadas del gr fico del proceso se interpreten como referidas
a la pantalla, donde la esquina superior izquierda es la (0, 0).

Existen otras constantes utilizadas para otros sistemas de coordenadas,
la lista completa es la siguiente:

    {c_screen} - Coordenadas de pantallaú
    {#1168,c_scroll} - Coordenadas de scrollú
    {#1169,c_m7}     - Coordenadas de modo 7ú
    {#1412,c_m8}     - Coordenadas de modo 8ú

{/}Ver: {#1202,Constantes} - {#1122,ctype}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1168,c_scroll}

Constante: {c_scroll}
{/}

Esta constante se utiliza para asignarla a la variable local predefinida
{#1122,ctype} que sirve para definir el tipo de coordenadas que
tendr  un proceso. Su valor es {1}.

ste es el valor asignado a {#1122,ctype} para que
las coordenadas del gr fico del proceso se interpreten como referidas
a una ventana de scroll, a coordenadas sobre el gr fico
del primer plano.

Para m s informaci¢n sobre las {ventanas de scroll}, se puede acceder
a la funci¢n {#163,start_scroll()} utilizada para activarlas.

Existen otras constantes utilizadas para otros sistemas de coordenadas,
la lista completa es la siguiente:

    {#1167,c_screen} - Coordenadas de pantallaú
    {c_scroll} - Coordenadas de scrollú
    {#1169,c_m7}     - Coordenadas de modo 7ú
    {#1412,c_m8}     - Coordenadas de modo 8ú

{/}Ver: {#1202,Constantes} - {#1122,ctype} - {#163,start_scroll()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1169,c_m7}

Constante: {c_m7}
{/}

Esta constante se utiliza para asignarla a la variable local predefinida
{#1122,ctype} que sirve para definir el tipo de coordenadas que
tendr  un proceso. Su valor es {2}.

ste es el valor asignado a {#1122,ctype} para que
las coordenadas del gr fico del proceso se interpreten como referidas
a una ventana de modo 7, a coordenadas sobre el gr fico
principal, abatido tridimensionalmente en dicha ventana.

Para m s informaci¢n sobre las {ventanas de modo 7}, se puede acceder
a la funci¢n {#162,start_mode7()}, utilizada para activarlas.

Existen otras constantes utilizadas para otros sistemas de coordenadas,
la lista completa es la siguiente:

    {#1167,c_screen} - Coordenadas de pantallaú
    {#1168,c_scroll} - Coordenadas de scrollú
    {c_m7}     - Coordenadas de modo 7ú
    {#1412,c_m8}     - Coordenadas de modo 8ú

{/}Ver: {#1202,Constantes} - {#1122,ctype} - {#162,start_mode7()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1170,partial_dump}

Constante: {partial_dump}
{/}

Esta constante se utiliza para asignarla a la variable global predefinida
{#1114,dump_type} que sirve para definir el tipo de volcado que se har  a
pantalla. Su valor es {0}.

Se utiliza en la siguiente sentencia:

  {dump_type=partial_dump;}

Con esta sentencia se indica al gestor de procesos de DIV Games
Studio que los siguientes volcados deben ser {parciales}.

Se denomina {volcado} al procedimiento de enviar las im genes del juego
al monitor (a la memoria de v¡deo de la tarjeta gr fica).

Hay dos tipos de volcados:

{Parcial}: S¢lo se volcar n en pantalla los gr ficos que se actualicen,
que hayan variado respecto a la imagen anterior. Este volcado conviene activarlo
{para ganar velocidad} cuando se programe un juego (o una secci¢n del
mismo) sin una ventana de scroll o modo 7 que ocupe toda la pantalla,
es decir, cuando el juego muestre movimientos de gr ficos sobre un
fondo fijo, o bien cuando las ventanas activas de scroll o modo 7 sean
m s peque¤as que la pantalla.

{Completo}: Se volcar  toda la pantalla, sin importar si los gr ficos han
cambiado o no. ste es el volcado por defecto y {es m s lento que el
volcado parcial}, sin embargo, es el que se debe utilizar cuando el
juego tenga una ventana de scroll o modo 7 que ocupe toda la pantalla.

{/}

La otra constante que se utiliza para designar el tipo de volcado es
{#1171,complete_dump} que, al contrario de ‚sta, define un volcado {completo}.

{/}Ver: {#1202,Constantes} - {#1114,dump_type} - {#1171,complete_dump}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1171,complete_dump}

Constante: {complete_dump}
{/}

Esta constante se utiliza para asignarla a la variable global predefinida
{#1114,dump_type} que sirve para definir el tipo de volcado que se har  a
pantalla. Su valor es {1}.

ste es el {valor por defecto} de la variable {#1114,dump_type}.
Para establecer este valor se debe utilizar la siguiente sentencia:

  {dump_type=complete_dump;}

Con esta sentencia se indica al gestor de procesos de DIV Games
Studio que los siguientes volcados deben ser {completos}.

Se denomina {volcado} al proceso de enviar las im genes del juego
al monitor (a la memoria de v¡deo de la tarjeta gr fica).

Hay dos tipos de volcados:

{Parcial}: S¢lo se volcar n en pantalla los gr ficos que se actualicen,
que hayan variado respecto a la imagen anterior. Este volcado conviene activarlo
{para ganar velocidad} cuando se programe un juego (o una secci¢n del
mismo) sin una ventana de scroll o modo 7 que ocupe toda la pantalla,
es decir, cuando el juego muestre movimientos de gr ficos sobre un
fondo fijo, o bien cuando las ventanas activas de scroll o modo 7 sean
m s peque¤as que la pantalla.

{Completo}: Se volcar  toda la pantalla, sin importar si los gr ficos han
cambiado o no. ste es el volcado por defecto y {es m s lento que el
volcado parcial}, sin embargo, es el que se debe utilizar cuando el
juego tenga una ventana de scroll o modo 7 que ocupe toda la pantalla.

{/}

La otra constante que se utiliza para designar el tipo de volcado es
{#1170,partial_dump} que, al contrario de ‚sta, define un volcado {parcial}.

{/}Ver: {#1202,Constantes} - {#1114,dump_type} - {#1170,partial_dump}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1172,no_restore}

Constante: {no_restore}
{/}

Esta constante se utiliza para asignarla a la variable global predefinida
{#1113,restore_type} que sirve para definir el tipo de restauraci¢n
que se debe aplicar al fondo de la pantalla tras cada imagen del juego.
Su valor es{ -1}.

Se denomina {restauraci¢n del fondo} a recuperar las zonas de pantalla
en las que se han pintado gr ficos o escrito textos en la imagen anterior,
es decir, "{despintar}" los gr ficos y "{desescribir}" los textos (borrarlos).

Para establecer este valor se debe utilizar la siguiente sentencia:

  {restore_type=no_restore;}

Con esta sentencia se indica al gestor de procesos de DIV Games
Studio que tras las siguientes im genes del juego {no es necesario
que se restaure el fondo de pantalla}.

Si no se restaura el fondo, se {ganar  velocidad} de ejecuci¢n en
el juego (ir  m s fluido en los ordenadores lentos). Pero esta
modalidad de restauraci¢n ({no_restore}) es aplicable £nicamente
en juegos o secciones de los mismos, en los que {exista una ventana
de scroll o de modo 7 que ocupe la pantalla completa}.

Los tres tipos de restauraci¢n aplicables se corresponden con
estas tres constantes:

{no_restore}       - El m s r pido, no se restaura el fondoú
{#1173,partial_restore}  - Medio, restauraciones parcialesú
{#1174,complete_restore} - El m s lento, restauraci¢n completaú

{/}Ver: {#1202,Constantes} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1173,partial_restore}

Constante: {partial_restore}
{/}

Esta constante se utiliza para asignarla a la variable global predefinida
{#1113,restore_type} que sirve para definir el tipo de restauraci¢n
que se debe aplicar al fondo de la pantalla tras cada imagen del juego.
Su valor es{ 0}.

Se denomina {restauraci¢n del fondo} a recuperar las zonas de pantalla
en las que se han pintado gr ficos o escrito textos en la imagen anterior,
es decir, "{despintar}" los gr ficos y "{desescribir}" los textos (borrarlos).

Para establecer este valor se debe utilizar la siguiente sentencia:

  {restore_type=partial_restore;}

Con esta sentencia se indica al gestor de procesos de DIV Games
Studio que, tras las siguientes im genes del juego, {se deben restaurar
£nicamente las zonas de pantalla en las que se hayan pintado
gr ficos o escrito textos}.

Esta modalidad de restauraci¢n ({partial_restore}) es m s r pida que una restauraci¢n
completa (opci¢n por defecto), pero debe aplicarse £nicamente en
juegos, o secciones de los mismos, en los que {NO exista una ventana
de scroll o de modo 7 que ocupe la pantalla completa}.

Los tres tipos de restauraci¢n aplicables se corresponden con
estas tres constantes:

{#1172,no_restore}       - El m s r pido, no se restaura el fondoú
{partial_restore}  - Medio, restauraciones parcialesú
{#1174,complete_restore} - El m s lento, restauraci¢n completaú

{/}Ver: {#1202,Constantes} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1174,complete_restore}

Constante: {complete_restore}
{/}

Esta constante se utiliza para asignarla a la variable global predefinida
{#1113,restore_type} que sirve para definir el tipo de restauraci¢n
que se debe aplicar al fondo de la pantalla tras cada imagen del juego.
Su valor es{ 1}.

Se denomina {restauraci¢n del fondo} a recuperar las zonas de pantalla
en las que se han pintado gr ficos o escrito textos en la imagen anterior,
es decir, "{despintar}" los gr ficos y "{desescribir}" los textos (borrarlos).

{ste es el valor por defecto de la variable} {#1113,restore_type} y,
de las tres modalidades de restauraci¢n disponible, es la {m s lenta}.
Para establecer este valor se debe utilizar la siguiente sentencia:

  {restore_type=complete_restore;}

Con esta sentencia se indica al gestor de procesos de DIV Games
Studio que tras las siguientes im genes del juego {se debe restaurar
completamente el fondo de la pantalla}.

Esta modalidad de restauraci¢n ({complete_restore}) es la m s
lenta de todas (y es la opci¢n por defecto), por lo que puede
cambiarse por otra para {ganar velocidad} de ejecuci¢n en el juego
(con lo que ir  m s fluido en los ordenadores lentos).

En realidad, esta modalidad interesa £nicamente en juegos, o secciones
de los mismos, que {no} tengan una ventana de scroll o de modo 7 que ocupe
toda la pantalla, pero que tengan una gran cantidad de gr ficos
movi‚ndose por pantalla.

Los tres tipos de restauraci¢n aplicables se corresponden con
estas tres constantes:

{#1172,no_restore}       - El m s r pido, no se restaura el fondoú
{#1173,partial_restore}  - Medio, restauraciones parcialesú
{complete_restore} - El m s lento, restauraci¢n completaú

{/}Ver: {#1202,Constantes} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1175,N£meros de ventana}

Constantes: {c_0} ... {c_9}
{/}

Estas constantes se utilizan para asignarlas a la variable local predefinida
{#1134,cnumber} que sirve para definir las ventanas de scroll o modo 7
en las que debe aparecer el gr fico de un proceso.

{sto ser  necesario solamente cuando se hayan activado varias ventanas
de scroll o varias ventanas de modo 7, y NO se quiera que el gr fico
del proceso se visualice en todas ellas}.

Pueden definirse hasta 10 ventanas de estos tipos, con los n£meros
del {0} al {9}, y que se corresponder n directamente con las constantes
{c_0}, {c_1}, {c_2} ... {c_9}.

Para que el gr fico de un proceso aparezca s¢lo en una de estas
ventanas, se debe asignar la constante correspondiente a su variable
local {#1134,cnumber}. Por ejemplo, si se quisiera que el gr fico
de un proceso apareciera £nicamente en la ventana n£mero 3 (de scroll
o modo 7), se deber¡a incluir en su c¢digo la siguiente sentencia:

  {cnumber=c_3;}

Si se quiere que el gr fico de un proceso aparezca en varias ventanas
de estas ventanas, entonces se deber n sumar las constantes.
Por ejemplo, para que un proceso aparezca en las ventanas 0, 4, y 5
se realizar  la siguiente asignaci¢n:

  {cnumber=c_0+c_4+c_5;}

Para que el gr fico aparezca en todas las ventanas, basta con asignar
un {0} a la variable {#1134,cnumber}. Aspecto que no ser  necesario si
esta variable no se ha modificado, pues ‚se es su valor por defecto.

Los valores a los que equivalen estas constantes se corresponden
con las siguientes potencias de 2:

    {c_0} = 1   scroll / modo 7 n£mero 0ú
    {c_1} = 2   scroll / modo 7 n£mero 1ú
    {c_2} = 4   scroll / modo 7 n£mero 2ú
    {c_3} = 8   scroll / modo 7 n£mero 3ú
    {c_4} = 16  scroll / modo 7 n£mero 4ú
    {c_5} = 32  scroll / modo 7 n£mero 5ú
    {c_6} = 64  scroll / modo 7 n£mero 6ú
    {c_7} = 128 scroll / modo 7 n£mero 7ú
    {c_8} = 256 scroll / modo 7 n£mero 8ú
    {c_9} = 512 scroll / modo 7 n£mero 9ú

{/}Ver: {#1202,Constantes} - {#1134,cnumber}.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1176,C¢digos de las teclas}

Constantes: {C¢digos de las teclas}
{/}

Estas constantes se utilizan normalmente como par metro de la
funci¢n {#128,key()}, para indicar qu‚ tecla es la que se desea
saber si est  pulsada.

Tambi‚n se pueden utilizar para comparar la variable global
{#1110,scan_code}, que contiene el c¢digo de la £ltima tecla que
se ha pulsado, con estos valores.

Normalmente, para designar a cada constante se suele usar el car cter {_}
(subrayado) seguido del nombre de la tecla, por ejemplo para la tecla [{A}],
la constante referida a su c¢digo ser  {_a}.

La lista completa de estas constantes, con sus respectivos valores,
es la siguiente (seg£n la disposici¢n est ndar del teclado):

{_esc}         = 1   [ESC] o escapeú
{_f1}          = 59  [F1] o funci¢n 1ú
{_f2}          = 60  [F2] o funci¢n 2ú
{_f3}          = 61  [F3] o funci¢n 3ú
{_f4}          = 62  [F4] o funci¢n 4ú
{_f5}          = 63  [F5] o funci¢n 5ú
{_f6}          = 64  [F6] o funci¢n 6ú
{_f7}          = 65  [F7] o funci¢n 7ú
{_f8}          = 66  [F8] o funci¢n 8ú
{_f9}          = 67  [F9] o funci¢n 9ú
{_f10}         = 68  [F10] o funci¢n 10ú
{_f11}         = 87  [F11] o funci¢n 11ú
{_f12}         = 88  [F12] o funci¢n 12 (TRAZADOR)ú
{_prn_scr}     = 55  [IMPR PANT] o impresi¢n pantallaú
{_scroll_lock} = 70  [BLOQ DESPL] o bloqueo desplazamientoú

{_wave}        = 41  Tecla [§] o [¦]ú
{_1}           = 2   Tecla con el n£mero "1"ú
{_2}           = 3   Tecla con el n£mero "2"ú
{_3}           = 4   Tecla con el n£mero "3"ú
{_4}           = 5   Tecla con el n£mero "4"ú
{_5}           = 6   Tecla con el n£mero "5"ú
{_6}           = 7   Tecla con el n£mero "6"ú
{_7}           = 8   Tecla con el n£mero "7"ú
{_8}           = 9   Tecla con el n£mero "8"ú
{_9}           = 10  Tecla con el n£mero "9"ú
{_0}           = 11  Tecla con el n£mero "0"ú
{_minus}       = 12  Tecla con el s¡mbolo "?"ú
{_plus}        = 13  Tecla con el s¡mbolo "¨"ú

{_backspace}   = 14  Tecla de borrado ( <- )ú
{_tab}         = 15  Tecla de tabulador [TAB]ú
{_q}           = 16  Tecla con la letra "Q"ú
{_w}           = 17  Tecla con la letra "W"ú
{_e}           = 18  Tecla con la letra "E"ú
{_r}           = 19  Tecla con la letra "R"ú
{_t}           = 20  Tecla con la letra "T"ú
{_y}           = 21  Tecla con la letra "Y"ú
{_u}           = 22  Tecla con la letra "U"ú
{_i}           = 23  Tecla con la letra "I"ú
{_o}           = 24  Tecla con la letra "O"ú
{_p}           = 25  Tecla con la letra "P"ú
{_l_brachet}   = 26  Tecla [^] o [`]ú
{_r_brachet}   = 27  Tecla [*] o [+]ú
{_enter}       = 28  [ENTER] (Intro o Retorno)ú

{_caps_lock}   = 58  [BLOQ MAYUS] o bloqueo may£sculasú
{_a}           = 30  Tecla con la letra "A"ú
{_s}           = 31  Tecla con la letra "S"ú
{_d}           = 32  Tecla con la letra "D"ú
{_f}           = 33  Tecla con la letra "F"ú
{_g}           = 34  Tecla con la letra "G"ú
{_h}           = 35  Tecla con la letra "H"ú
{_j}           = 36  Tecla con la letra "J"ú
{_k}           = 37  Tecla con la letra "K"ú
{_l}           = 38  Tecla con la letra "L"ú
{_semicolon}   = 39  Tecla con la letra "¥"ú
{_apostrophe}  = 40  Tecla [{{}]ú
{_backslash}   = 43  Tecla [{}}]ú

{_l_shift}     = 42  [SHIFT] o may£sculas izquierdoú
{_z}           = 44  Tecla con la letra "Z"ú
{_x}           = 45  Tecla con la letra "X"ú
{_c}           = 46  Tecla con la letra "C"ú
{_v}           = 47  Tecla con la letra "V"ú
{_b}           = 48  Tecla con la letra "B"ú
{_n}           = 49  Tecla con la letra "N"ú
{_m}           = 50  Tecla con la letra "M"ú
{_comma}       = 51  Tecla [;] o [,]ú
{_point}       = 51  Tecla [:] o [.]ú
{_slash}       = 51  Tecla [_] o [-]ú
{_r_shift}     = 54  [SHIFT] o may£sculas derechoú

{_control}     = 29  Teclas [CONTROL]ú
{_alt}         = 56  Tecla [ALT] o [ALT GR]ú
{_space}       = 57  [SPACE] o barra espaciadoraú

{_ins}         = 82  [INSERT] o insertarú
{_home}        = 71  [INICIO] o inicio de p ginaú
{_pgup}        = 73  [RE PAG] o retroceso de p ginaú
{_del}         = 83  [SUPR] o suprimirú
{_end}         = 79  [FIN] o fin de p ginaú
{_pgdn}        = 81  [AV PAG] o avance de p ginaú

{_up}          = 72  Cursor para arribaú
{_down}        = 80  Cursor para abajoú
{_left}        = 75  Cursor para izquierdaú
{_right}       = 77  Cursor para derechaú

{_num_lock}    = 69  [BLOQ NUM] o bloqueo num‚ricoú
{_c_backslash} = 53  S¡mbolo [/] del teclado num‚ricoú
{_c_asterisk}  = 55  S¡mbolo [*] del teclado num‚ricoú
{_c_minus}     = 74  S¡mbolo [-] del teclado num‚ricoú
{_c_home}      = 71  [INICIO] del teclado num‚ricoú
{_c_up}        = 72  Cursor arriba del teclado num‚ricoú
{_c_pgup}      = 73  [RE PAG] del teclado num‚ricoú
{_c_left}      = 75  Cursor izquierda del teclado num‚ricoú
{_c_center}    = 76  Tecla [5] del teclado num‚ricoú
{_c_right}     = 77  Cursor derecha del teclado num‚ricoú
{_c_end}       = 79  [FIN] del teclado num‚ricoú
{_c_down}      = 80  Cursor abajo del teclado num‚ricoú
{_c_pgdn}      = 81  [AV PAG] del teclado num‚ricoú
{_c_ins}       = 82  [INS] del teclado num‚ricoú
{_c_del}       = 83  [SUPR] del teclado num‚ricoú
{_c_plus}      = 78  S¡mbolo [+] del teclado num‚ricoú
{_c_enter}     = 28  [ENTER] del teclado num‚ricoú

Resulta indiferente utilizar estas constantes o los valores num‚ricos
que representan, es decir, se puede llamar a la funci¢n {#128,key()},
para comprobar si est  pulsada la tecla [{A}], como {key(_a)} o bien
como {key(30)} (se puede comprobar en la lista anterior que {30} es
el valor num‚rico de la constante {_a}).

{/}

{Importante:} Algunos de estos c¢digos pueden diferir en ciertos
teclados, en caso de duda se puede ejecutar el siguiente programa
ejemplo, que muestra en pantalla una tabla, correspondiente con la
funci¢n {#128,key()} (indicando los {c¢digos de las teclas que est n
pulsadas} en cada momento), adem s de los valores de las variables
{#1110,scan_code}, {#1109,ascii} y {#1108,shift_status} (relacionados
igualmente con la lectura del teclado).

{#9999,Programa ejemplo:}
PROGRAM ejemplo_c¢digos_del_teclado;

GLOBAL
    teclas[128];

BEGIN
    write(0, 0, 0, 0, "C¢digos de las teclas pulsadas, seg£n key()");
    FROM x=0 TO 127;
        write_int(0, (x%16)*20, (x/16)*10+20, 0, OFFSET teclas[x]);
    END
    write(0, 0, 160, 0, "C¢digo de la £ltima tecla pulsada (scan_code):");
    write_int(0, 320, 160, 2, OFFSET scan_code);
    write(0, 0, 180, 0, "C¢digo ASCII de la £ltima tecla (ascii):");
    write_int(0, 320, 180, 2, OFFSET ascii);
    write(0, 0, 190, 0, "Estado de las teclas especiales (shift_status):");
    write_int(0, 320, 190, 2, OFFSET shift_status);
    LOOP
        FROM x=1 TO 127;
            IF (key(x))
                teclas[x]=x;
            ELSE
                teclas[x]=0;
            END
        END
        FRAME;
    END
END
{-}

Este programa se puede utilizar (pulsando con el rat¢n sobre el
texto "{Programa ejemplo:}" y despu‚s la tecla [{F10}]) para
averiguar el c¢digo que tiene alguna tecla en concreto.

Despu‚s podr  utilizarse dicho c¢digo num‚rico como par metro de la
funci¢n {#128,key()}, para comprobar en el juego si dicha tecla est 
pulsada en un momento determinado.

{/}Ver: {#1202,Constantes} - {#128,key()} - {#1110,scan_code} - {#1109,ascii} - {#1108,shift_status}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1177,min_int}

Constante: {min_int}
{/}

Esta constante define el valor m¡nimo que puede almacenar cualquier
dato en este lenguaje. Este valor es{ -2147483648}.

Todos los datos son {enteros} con signo de 32 bits en este lenguaje.
Por ello, £nicamente se pueden manejar n£meros enteros dentro del rango
({ -2147483648} ...{ +2147483647} ).

Cuando el resultado de una operaci¢n aritm‚tica exceda dicho rango,
el sistema no advertir  de ning£n error, por lo que se deben extremar
las precauciones para que ‚sto no suceda.

{/}Ver: {#1202,Constantes} - {#1178,max_int}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1178,max_int}

Constante: {max_int}
{/}

Esta constante define el valor m ximo que puede almacenar cualquier
dato en este lenguaje. Este valor es{ 2147483647}.

Todos los datos son {enteros} con signo de 32 bits en este lenguaje, de ah¡
que, £nicamente, se pueden manejar n£meros enteros dentro del rango
({ -2147483648} ...{ +2147483647} ).

Cuando el resultado de una operaci¢n aritm‚tica exceda dicho rango,
el sistema no advertir  de ning£n error, por lo que se deben extremar
las precauciones para que esto no suceda.

{/}Ver: {#1202,Constantes} - {#1177,min_int}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1179,pi}

Constante: {pi}
{/}

Esta constante define la equivalencia en {mil‚simas de grado} de la
constante matem tica {pi} (aproximadamente {3.14159265} radianes).

Su valor es {180000} mil‚simas de grado (180 grados), equivalente a
{pi radianes}.

Se suele utilizar para definir  ngulos; por ejemplo, se podr¡a
definir {180 grados} como {pi},{ -90 grados} como{ -pi/2},
{45 grados} como {pi/4}, etc.

{/}Ver: {#1202,Constantes} - {#1044,Uso de  ngulos en el lenguaje}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1200,Datos globales predefinidos}

A continuaci¢n se describe cada uno de los datos globales predefinidos.

{#1413,STRUCT dirinfo}         - Lista de archivos de un directorioú
{#1414,STRUCT fileinfo}        - Informaci¢n sobre un archivoú
{#1103,STRUCT joy}             - Par metros del joystickú
{#1102,STRUCT m7[9]}           - Control de las ventanas de modo 7ú
{#1411,STRUCT m8[9]}           - Control de las ventanas de modo 8ú
{#1100,STRUCT mouse}           - Par metros del rat¢nú
{#1410,STRUCT net}             - Par metros del hardware de redú
{#1101,STRUCT scroll[9]}       - Control de las ventanas de scrollú
{#1104,STRUCT setup}           - Control de la tarjeta de sonidoú
{#1415,STRUCT video_modes[31]} - Modos de v¡deo disponiblesú

{#1409,argc}             - N£mero de argumentosú
{#1409,argv[]}           - Argumentos del programaú
{#1109,ascii}            - Lectura de c¢digos ASCII del tecladoú
{#1416,channel[31]       - Canales de sonidoú
{#1418,draw_z}           - Plano de profundidad de las primitivasú
{#1114,dump_type}        - Tipo de volcado de la pantallaú
{#1107,fading}           - Indicador de fundido de pantallaú
{#1426,fps}              - N£mero de im genes por segundoú
{#1111,joy_filter}       - Filtro aplicado al joystickú
{#1112,joy_status}       - Estado del joystickú
{#1115,max_process_time} - Tiempo m ximo de ejecuci¢n de un procesoú
{#1419,num_video_modes}  - N£mero de modos de v¡deo detectadosú
{#1113,restore_type}     - Tipo de restauraci¢n de la pantallaú
{#1110,scan_code}        - Lectura de c¢digos del tecladoú
{#1108,shift_status}     - Estado de las teclas especialesú
{#1106,text_z}           - Plano de profundidad de los textosú
{#1105,timer[9]}         - Contadores de tiempoú
{#1420,unit_size}        - Tama¤o de la unidad de lectura/escrituraú
{#1417,vsync}            - Esperar al retrazo verticalú

{/}Ver: {#1202,Constantes} - {#1201,Datos locales} - {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1201,Datos locales predefinidos}

A continuaci¢n se describe cada uno de los datos locales predefinidos.

{#1116,STRUCT reserved} - Par metros internos de los procesosú

{#1129,angle}           -  ngulo del gr fico del procesoú
{#1120,bigbro}          - Identificador del hermano mayor del procesoú
{#1134,cnumber}         - N£meros de ventanas de scroll o modo 7ú
{#1122,ctype}           - Tipo de coordenadas utilizadas por el procesoú
{#1117,father}          - Identificador de padre del procesoú
{#1131,file}            - C¢digo del fichero del gr fico del procesoú
{#1127,flags}           - Indicadores de espejado y transparenciaú
{#1126,graph}           - C¢digo del gr fico asignado al procesoú
{#1133,height}          - Altura del proceso en ventanas de modo 7ú
{#1424,m8_nextsector}   - Sector hacia el que se dirige el procesoú
{#1423,m8_sector}       - N£mero de sector en el que est  el procesoú
{#1425,m8_step}         - Altura que puede subir el procesoú
{#1422,m8_wall}         - Pared del mapa contra la que se colisionaú
{#1121,priority}        - Prioridad de ejecuci¢n del procesoú
{#1421,radius}          - Radio de los procesos de modo 8ú
{#1130,region}          - Regi¢n de pantalla asignada al procesoú
{#1135,resolution}      - Resoluci¢n de las coordenadas del procesoú
{#1128,size}            - Tama¤o del gr fico del procesoú
{#1119,smallbro}        - Identificador del hermano peque¤o del procesoú
{#1118,son}             - Identificador del hijo del procesoú
{#1132,xgraph}          - OFFSET de la tabla gr fica del procesoú
{#1123,x}               - Coordenada horizontal del procesoú
{#1124,y}               - Coordenada vertical del procesoú
{#1125,z}               - Plano de profundidad del gr fico del procesoú

{/}Ver: {#1202,Constantes} - {#1200,Datos globales} - {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1202,Constantes predefinidas}

A continuaci¢n se describe cada una de las constantes predefinidas.

{#1176,_a, _b, _c, ...}       - C¢digos del tecladoú
{#1400,_case_sensitive}       - Distingir may£sculas y min£sculasú
{#1400,_extended_conditions}  - Condiciones complejasú
{#1400,_free_sintax}          - Sint xis libreú
{#0231,_hidden}               - Archivo ocultoú
{#1400,_ignore_errors}        - Ignorar todos los erroresú
{#1400,_max_process}          - N£mero m ximo de procesosú
{#1400,_no_check}             - No comprobar errores de ejecuci¢nú
{#1400,_no_id_check}          - No comprobar los identificadoresú
{#1400,_no_null_check}        - No comprobar accesos a NULLú
{#1400,_no_optimization}      - No optimizar el c¢digoú
{#1400,_no_range_check}       - No comprobar el rangoú
{#1400,_no_strfix}            - No ampliar las cadenas de textoú
{#0231,_normal}               - Archivo normalú
{#1400,_simple_conditions}    - Condiciones simplesú
{#0231,_subdir}               - Subdirectorioú
{#0231,_system}               - Archivo de sistemaú
{#0231,_volid}                - Etiqueta de volumenú
{#0250,all_drawing}           - Indicador de todas las primitivasú
{#1162,all_sound}             - Indicador de todos los sonidosú
{#1161,all_text}              - Indicador de todos los textosú
{#1175,c_0 .. c_9}            - Indicadores de ventanasú
{#1169,c_m7}                  - Coordenadas de ventana de modo7ú
{#1412,c_m8}                  - Coordenadas de ventana de modo8ú
{#1167,c_screen}              - Coordenadas de pantallaú
{#1168,c_scroll}              - Coordenadas de ventana de scrollú
{#1171,complete_dump}         - Volcado de fondo completoú
{#1174,complete_restore}      - Restauraci¢n de pantalla completaú
{#1152,false}                 - Valores falsoú
{#1104,fast_mixer}            - Mezclado r pidoú
{#1164,g_height}              - Indicador de altoú
{#1163,g_wide}                - Indicador de anchoú
{#1165,g_x_center}            - Indicador de centro horizontalú
{#1166,g_y_center}            - Indicador de centro verticalú
{#1150,m320x200 .. m1024x768} - Modos de v¡deoú
{#1178,max_int}               - Valor m ximo de datosú
{#1177,min_int}               - Valor m¡nimo de datosú
{#1172,no_restore}            - Restauraci¢n de pantalla desactivadaú
{#1170,partial_dump}          - Volcado de fondo parcialú
{#1173,partial_restore}       - Restauraci¢n de pantalla parcialú
{#1179,pi}                    - Valor matem tico de piú
{#1104,quality_mixer}         - Mezclado de calidadú
{#1160,s_freeze_tree}         - Se¤al de congelar procesos e hijosú
{#1156,s_freeze}              - Se¤al de congelar procesosú
{#1157,s_kill_tree}           - Se¤al de matar procesos e hijosú
{#1153,s_kill}                - Se¤al de matar procesos ú
{#1159,s_sleep_tree}          - Se¤al de dormir procesos e hijosú
{#1155,s_sleep}               - Se¤al de dormir procesosú
{#1158,s_wakeup_tree}         - Se¤al de despertar procesos e hijosú
{#1154,s_wakeup}              - Se¤al de despertar procesosú
{#0227,seek_cur}              - Posici¢n actual del archivoú
{#0227,seek_end}              - Posici¢n final del archivoú
{#0227,seek_set}              - Comienzo del archivoú
{#1104,sound_bits_16}         - Muestras de 16 bitú
{#1104,sound_bits_8}          - Muestras de 8 bitú
{#1151,true}                  - Valor verdaderoú

{/}Ver: {#1200,Datos globales} - {#1201,Datos locales} - {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1291,Comandos en el entorno gr fico}

{Comandos en el entorno gr fico}

{/}

{ALT+X}         - Salir del entorno gr fico al sistema operativo.ú
{ESC+Control}   - Salir directamente del entorno y de los programas.ú

{ALT+S}         - Ejecutar una sesi¢n del sistema operativo MS-DOS.ú

{ESC}           - Para anular o cancelar un cuadro de di logo.ú
{TAB}           - Para elegir el control seleccionado de una ventana o cuadro.ú
{Enter}         - Para activar el control seleccionado.ú

{F1}            - Invocar la ventana de ayuda.ú

{F2}            - Guardar el programa seleccionado.ú
{F4}            - Abrir un programa.ú
{F10}           - Guardar y ejecutar el programa seleccionado.ú
{F11}           - Compilar el programa seleccionado.ú
{F12}           - Guardar y trazar el programa seleccionado.ú

{Control+ALT+P} - Grabar una captura del entorno gr fico (DIV_*.PCX)ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1292,Comandos comunes en los juegos}

{Comandos comunes en los juegos}

{/}

{ALT+X}        - Salir del juego.ú
{ESC+Control}  - Salir del juego.ú

{Contro+ALT+P} - Grabar una captura del juego (SNAP*.PCX)ú
{F12}          - Invocar al trazador de programas.ú
{Pausa}        - Detener el juego moment neamente.ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1293,Comandos en el trazador de programas}

{Comandos en el trazador de programas}

{/}

{Cursores}  - Movimiento por el listado.ú
{Re.P g.}   - P gina anterior.ú
{Av.Pag.}   - Siguiente p gina.ú

{F4}        - Ejecutar hasta llegar a la l¡nea seleccionada.ú
{F5}        - Ver el listado de un proceso.ú
{F6}        - Ejecutar el proceso actual.ú
{F7}        - Ver o editar datos.ú
{F8}        - Trazar sentencia.ú
{F9}        - Fijar un punto de ruptura.ú
{F10}       - Ejecutar la siguiente sentencia o llamada a proceso.ú
{F11}       - Ver los perfiles de tiempo del programa.ú
{F12}       - Invocar al trazador / Avanzar im genes.ú

{F}             - Ejectuar hasta la siguiente imagen.ú

{TAB}           - Seleccionar bot¢n.ú
{Enter}         - Activar bot¢n.ú
{ESC}           - Salir del trazador.ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1294,Comandos en el editor de programas}

{Comandos en el editor de programas}

{/}

{Comandos gen‚ricos}

{/}

{F5}        - Saltar al inicio de un proceso del programa.ú
{Control+Z} - Ampliar la ventana de programa seleccionada.ú

{/}

{Comandos de movimiento y edici¢n b sicos}

{/}

{Cursores}                  - Movimiento b sico del cursor.ú
{Inicio}                    - Saltar al inicio de la l¡nea.ú
{Fin}                       - Saltar al final de la l¡nea.ú
{Av.P g.}                   - Siguiente p gina.ú
{Re.P g.}                   - P gina anterior.ú
{Insertar}                  - Conmutar entre inserci¢n y sobreescritura.ú
{Suprimir}                  - Borrar el car cter del cursor.ú
{Borrar}                    - Borrar el car cter anterior al cursor.ú
{TAB}                       - Saltar a la siguiente tabulaci¢n.ú
{May£sculas+TAB}            - Destabular.ú
{Control+Borrar, Control+Y} - Borrar l¡nea actual.ú
{Control+Derecha}           - Siguiente palabra.ú
{Control+Izquierda}         - Palabra anterior.ú
{Control+Re.P g.}           - Saltar al inicio del programa.ú
{Control+Av.P g.}           - Saltar al final delprograma.ú
{Control+Inicio}            - Saltar al incio de la p gina.ú
{Control+Fin}               - Saltar al final de la p gina.ú

{/}

{Comandos de b£squeda y sustituci¢n}

{/}

{ALT+F, Control+F}     - Buscar un texto.ú
{ALT+N, F3, Control+L} - Repetir b£squeda.ú
{ALT+R, Control+R}     - Sustituir texto.ú

{/}

{Comandos de bloques tipo QEDIT}

{/}

{ALT+A}        - Marcar el inicio o final de un bloque permanente.ú
{ALT+U}        - Desmarcar el bloque permanente.ú
{ALT+C}        - Copiar el bloque a la posici¢n actual.ú
{ALT+M}        - Mover el bloque a la posici¢n actual.ú
{ALT+D, ALT+G} - Borrar el bloque.ú

{/}

{Comandos de bloques tipo EDIT}

{/}

{May£sculas+Movimiento}    - Marcar bloque vol til (Teclas de movimiento:
{Cursores, Control + Derecha, Control + Izquierda, Re.P g, Av.P g., Inicio,
Fin}).ú

{May£sculas+Insertar} - Pegar bloque.ú
{Control+Insertar}    - Copiar bloque.ú
{May£sculas+Suprimir} - Cortar bloque.ú

{Control+X}           - Cortar bloque.ú
{Control+C}           - Copiar bloque.ú
{Control+V}           - Pegar bloque.ú

{Suprimir}            - Borrar bloque.ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1295,Comandos en el editor gr fico}

{Comandos en el editor gr fico}

{/}

{Comandos gen‚ricos}

{/}

{F1}                    - Invocar la ventana de ayuda.ú

{ESC}                   - Salir del editor gr fico.ú

{Cursores, OP/QA}       - Movimiento del cursor.ú
{Barra espaciadora}     - Equivale a pulsar con bot¢n izquierdo del rat¢n.ú
{May£sculas+Movimiento} - Movimiento de 8 en 8 puntos.ú
{May£sculas+Bot¢n izq.} - Coger color de pantalla.ú

{W, S}                  - Elegir color dentro de la gama actual.ú
{May£sculas+W, S}       - Elegir gama actual.ú
{Control+Cursores}      - Elegir color y gama.ú

{Borrar}                - Deshacer.ú
{May£sculas+Borrar}     - Repetir acci¢n (rehacer).ú

{0}                     - Seleccionar el color transparente.ú
{B}                     - Resaltar el color transparente.ú
{C}                     - Ventana de colores.ú
{M}                     - Ventana de m scara.ú
{T}                     - Seleccionar pincel.ú
{U}                     - Seleccionar textura.ú
{X}                     - Visualizar textura.ú
{Z}                     - Cambiar nivel de ampliaci¢n.ú

{/}

{Comandos de selecci¢n de herramienta}

{/}

{F2}             - L piz, para el trazo a mano alzada.ú
{F3}             - L¡neas rectas.ú
{F4}             - Multil¡nea, l¡neas encadenadas.ú
{F5}             - Curvas b‚zier.ú
{F6}             - Multicurva, curvas encadenadas.ú
{F7}             - Rect ngulos y cajas.ú
{F8}             - C¡rculos y circunferencias.ú
{F9}             - Spray de pintura.ú
{F10}            - Relleno de superficies.ú
{F11}            - Edici¢n de bloques.ú
{F12}            - Deshacer y rehacer acciones.ú
{May£sculas+F1}  - Escribir textos.ú
{May£sculas+F2}  - Situar puntos de control.ú
{May£sculas+F3}  - Barra de punteado.ú

{/}

{Comandos espec¡ficos}

{/}

{Control}  - Mover selecci¢n (barra: seleccionar bloque).ú
{Control}  - Igualar ancho y alto (barras: rect ngulos y c¡rculos).ú
{D}        - Difuminar (barras: l piz, l¡neas, curvas y spray).ú
{H}        - Esconder cursor (barra: mover bloque).ú
{K}        - Copiar a ventana (barra: seleccionar bloque).ú
{ +, -}    - Variar tensi¢n (barra: multicurva).ú
{ +, -}    - Cambiar punto de control (barra: putos de control).ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1300,Preguntas comunes sobre DIV}

{¨Donde puedo encontrar m s informaci¢n sobre DIV?}

Existen muchos usuarios que est n apoyando el programa con p ginas en
Internet, estas se pueden acceder a partir de {WWW.DIVGAMES.COM},
que es la p gina oficial del producto. Adem s existen {listas de correo}
donde se solucionan problemas, y canales de CHAT sobre el lenguaje de
programaci¢n (el canal{ #div} de IRC Hispano).

{¨Como obtener ayuda sobre ... ?}

Todas las opciones accesibles desde cualquier men£ de opciones se describen
exclusivamente en el {manual de usuario} de DIV Games Studio 2.

{¨Como resolver un problema de configuraci¢n?}

Para problemas de sonido, instalaciones incompletas, etc., vea el apartado
de {#2003,resoluci¢n de problemas} de esta ayuda electr¢nica.

{¨Cuales son las mejoras de esta versi¢n?}

Estas se dividen en dos grupos: las {#2001,novedades del lenguaje}
(explicadas en esta {ayuda}), y las {#2002,novedades del entorno} (explicadas
en el {manual de usuario}).

{¨Porqu‚ me dice "No se reconoce el tipo de fichero"?}

Es posible que est‚ intentando cargar un archivo con el men£ incorrecto, es
decir, el men£ de paletas s¢lo sirve para cargar paletas, el de ficheros s¢lo
para cargar ficheros de gr ficos (grupos de gr ficos), el de programas para
cargar programas o archivos de texto, etc.

Tambi‚n es posible que est‚ intentando cargar un mapa PCX o BMP True Color,
esta versi¢n de DIV £nicamente puede trabajar a 256 colores, no siendo posible
importar este tipo de archivos. Deber  convertir el gr fico que quiere cargar
en DIV a 256 colores con otra herramienta primero.

{¨Como se debe arrastrar un gr fico?}

Para arrastrar un gr fico se debe pulsar con el bot¢n izquierdo del rat¢n sobre
la ventana del mapa, pero no sobre la barra de t¡tulo, sino sobre el propio
gr fico contenido en la ventana. Despu‚s bastar  con mover el rat¢n hasta la
posici¢n en la que se desea dejar el gr fico y soltar entonces el bot¢n izquierdo
(se pueden arrastrar mapas a ficheros, a la papelera, al tapiz de fondo, a otros
mapas o al generador de fuentes).

{¨Como extraer un gr fico contenido en otro?}

{+126,0}Se debe acceder a la barra de edici¢n de bloques para seleccionar
la parte del gr fico que se quiere extraer. La selecci¢n se puede realizar
de varias formas, como un rect ngulo, dibujando el contorno, etc.{-}

{+133,0}Una vez realizada la selecci¢n aparecer n algunos iconos nuevos
en la barra de herramientas, entre ellos el icono de {cortar a ventana}.
Al pulsar sobre este icono {se crea una nueva ventana de mapa} en el escritorio
{y se pega la zona seleccionada} en el mismo.{-}

{¨Como se cortan y copian gr ficos?}

{+126,0}Ver tambi‚n la pregunta anterior. Para cortar y mover gr ficos se debe acceder
a la {barra de edici¢n de bloques}, dentro del programa de dibujo,
seleccionando el icono que muestra unas tijeras.

Desde el escritorio se pueden realizar algunas operaciones, como copiar
un gr fico a otro, esto se puede hacer arrastrando el primer gr fico hasta
el segundo. Tambi‚n se puede crear una copia de un gr fico si se arrastra
el mismo hasta el tapiz de fondo (una zona del escritorio que no contenga
ninguna ventana).

{¨Que debo hacer si el sistema se vuelve inestable?}

DIV Games Studio es un programa muy complejo y, aunque es bastante
s¢lido en su ejecuci¢n, puede que el alg£n equipo de alg£n error
al realizar una acci¢n determinada, o bien se bloquee el ordenador.

En estos casos, para volver el sistema a su estado original, debe
cargar DIV desde la l¡nea de comandos de MSDOS indicando el
par metro{ /SAFE} (introduciendo el comando D.EXE /SAFE desde el directorio
en el que se instal¢ el programa), para entrar en el "Modo a prueba
de fallos".

{¨Que debo hacer para aprender a programar?}

Los conceptos b sicos no se explican en esta ayuda, sino en el manual
de usuario de DIV Games Studio 2, en los cap¡tulos 4, 5 y 6.

Adem s se puede aprender mucho de los ejemplos de las funciones del
lenguaje (ver la lista de funciones en la ayuda sobre el lenguaje)
y de los tutoriales, que son unos mini-juegos muy sencillos y
dise¤ados para facilitar el aprendizaje del lenguaje (estos tutoriales
se pueden encontrar en el directorio PRG\TUTOR de DIV Games Studio 2).

{¨C¢mo se cargan los gr ficos en los juegos?}

En un juego se pueden utilizar los gr ficos contenidos en los mapas
(archivos MAP o PCX), carg ndolos de uno en uno con las funciones
{#174,load_map()} o {#174,load_pcx}, o bien metiendo varios gr ficos
en un fichero FPG de gr ficos y carg ndolos despu‚s con la funci¢n
{#132,load_fpg()}, esta £ltima opci¢n tiene la ventaja de que se pueden
cargar y descargar muchos gr ficos de golpe en el juego.

Despu‚s se suelen utilizar los gr ficos para asign rselos a la variable
{#1126,LOCAL graph} de los procesos del juego.

{¨Como mostrar un nuevo gr fico en un juego?}

Para crear un nuevo gr fico o "sprite" en un juego, se debe primero
crear un nuevo proceso ({#1016,PROCESS}) con las ¢rdenes que regir n
el comportamiento del mismo en el juego, despu‚s cada vez que se
quiera crear un proceso de dicho tipo, se deber  llamar al proceso
(ver como se hace una {#1033,llamada a un proceso}).

{¨Como eliminar un proceso?}

Para eliminar o "matar" a un proceso del juego, se puede ejecutar
una sentencia {#1028,RETURN} desde el mismo o bien, desde otro
proceso, enviarle una se¤al s_kill (ver la funci¢n {#158,signal()},
que es la empleada para esto).

{¨Cuales son las funciones para manejar el rat¢n?}

El rat¢n no se controla con ninguna funci¢n, sino con la estructura global
{#1100,mouse}, puede acceder a la ayuda sobre {lenguaje} / {datos globales}
para ver el resto de estructuras que controlan otros aspectos importantes de
los juegos.

{¨De donde carga todos los archivos DIV?}

Cuando en un programa se llama a una funci¢n como load_fpg( ... )
el gestor interno de DIV intenta localizar este archivo siguiendo
el siguiente esquema (supongamos que se intenta cargar el archivo
"DIR\FICHERO.EXT"):

- Primero se sit£a donde se encuentra el ejecutable (EXE) del juego,
o en el directorio principal de DIV (donde est  D.EXE) en caso de
estar ejecutando el juego desde el entorno.

- Despu‚s se intenta abrir desde este directorio el archivo seg£n
se ha especificado a la funci¢n ("DIR\FICHERO.EXT").

- En caso de no poder cargar este fichero, se intentar  cargar el
fichero dentro de un directorio que tenga como nombre la extensi¢n
del propio fichero, es decir "EXT\DIR\FICHERO.EXT".

- Si tampoco se ha encontrado este, se probar  a cargar el fichero
sin indicar ninguna ruta, es decir "FICHERO.EXT".

- Y por £ltimo, si no se ha localizado el fichero en ninguno de los
anteriores directorios, se intentar  buscar directamente en el
directorio cuyo nombre coincide con la extensi¢n del fichero, obviando
la ruta de acceso que se le pas¢ a la funci¢n, es decir "EXT\FICHERO.EXT".

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1301,Ayuda sobre la calculadora}

{¨Como funciona?}

La calculadora incluida en el entorno tiene un funcionamiento ligeramente
diferente a las calculadoras convencionales, est  pensada para programadores,
y por ello funciona como un evaluador de expresiones.

Su uso es muy sencillo, basta con escribir la expresi¢n matem tica y pulsar
la tecla {Enter}. Pulsando {F1} se acceder  siempre a esta p gina de ayuda.

Por ejemplo, puede teclear en la calculadora la expresi¢n 2+2 y pulsar {Enter};
aparecer  un 4 en el cuadro de resultados. Para introducir una nueva expresi¢n
debe borrarse previamente la anterior, lo que puede hacerse pulsando la tecla {ESC}.

Es posible introducir expresiones complejas, utilizando par‚ntesis {( )} para indicar
las prioridades en los c lculos.

{/}

Los {operadores} que pueden utilizarse en las expresiones de la calculadora son
los siguientes (se indican todos los sin¢nimos aceptados de cada operador):

{ + -}      Suma y Resta.ú
{ * /}      Multiplicaci¢n y divisi¢n.ú
{ % MOD}    M¢dulo, o resto de una divisi¢n entera.ú
{ < <<}     Rotaci¢n binaria a la izquierda.ú
{ > >>}     Rotaci¢n a la derecha.ú
{ ^ ^^ XOR} OR exclusivo binario.ú
{ | || OR}  OR binario.ú
{ & && AND} AND binario.ú
{ ! NOT}    Negaci¢n binaria.ú
{ SQRT}     Raiz cuadrada.ú

{/}

La calculadora disponen de dos casillas que pueden alterar su {modo de
funcionamiento}. Estas opciones son las siguientes:

{Int} - Si se activa esta casilla, todas las operaciones se realizar n
internamente en variables enteras, como en el lenguaje DIV. Por ejemplo,
el resultado de dividir 8/3 ser  2.

{Hex} - Cuando esta casilla est‚ activada, el resultado se mostrar  en el
sistema hexadecimal. Tambi‚n se pueden introducir n£meros en este sistema
dentro de las expresiones precedidos de '{0x}' (como en el lenguaje).

{/}

{Nota:} En el escritorio pueden tenerse abiertas tantas calculadoras como sean
necesarias, de forma que se puedan mantener visibles de forma simult nea varias
expresiones diferentes.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1400,Opciones de compilaci¢n}

Estas opciones modifican la forma en la que DIV interpreta un programa y el c¢digo
que genera para ‚l. Normalmente no ser  necesario especificar ninguna opci¢n.

Para a¤adir una o varias de estas opciones a un programa se debe especificar como
la primera sentencia del mismo  (comentarios al margen) la palabra
{COMPILER_OPTIONS} seguida de los nombres de las opciones incluidas.

Si se incluyen varias opciones, deben aparecer separadas por comas, a¤adiendo
siempre un punto y coma al final (tras la ultima opci¢n).

{/}

{Opciones de compilaci¢n disponibles:}

{_max_process=x}

Donde x es un n£mero entero positivo. Define el n£mero de
procesos simult neos m ximo permitidos en ejecuci¢n. Esto
puede hacerse una vez completado un programa (cuando se
sepa cuantos procesos puede llegar a tener a la vez), para
ahorrar memoria en ejecuci¢n. En caso de no definirse este
valor, se reservar  un m¡nimo de 1 Mb (y un m ximo de 2 Mb)
para la memoria del programa.

{_extended_conditions}

Permite utilizar asignaciones dentro de una condici¢n (como:
{IF(id2=get_id(...))...)}; esto estaba permitido por defecto en la
primera versi¢n. Esta opci¢n puede ser necesaria para que
muchos programas de la primera versi¢n funcionen en la
segunda.

{_simple_conditions}

Interpreta el s¡mbolo = como una comparaci¢n, cuando
aparece dentro de una condici¢n. Este es un caso opuesto al
anterior (e incompatible con ‚l), al incluir esta opci¢n se permitir 
hacer comparaciones como {IF(x=0)...}, en lugar de interpretarlo
como una asignaci¢n del valor 0 a la variable x.

{_case_sensitive}

Diferencia en todos los nombres entre may£sculas y
min£sculas. En caso de activarse esta opci¢n {Abc} y {abc} ser n
dos nombres diferentes. Es importante saber que, en este caso,
todas las palabras reservadas del lenguaje ({program}, {loop},
{frame}, {if}, ...) deber n ponerse en letras min£sculas.

{_ignore_errors}

Prohibe la aparici¢n de mensajes de error durante la
ejecuci¢n del programa. La mayor¡a de errores ser n ignorados
(como errores de memoria, si no se encuentra un fichero,
divisiones por cero, etc.) , se desaconseja el uso de esta opci¢n
pero, en caso de querer incluirse, debe hacerse £nicamente en
los programas ya finalizados, suficientemente probados, y sin
errores conocidos, antes de realizar una instalaci¢n (ver las
consideraciones finales).

{_free_sintax}

Permite usar una sintaxis libre. Con esta opci¢n no ser n
necesarios los s¡mbolos {;} (punto y coma) del final de las
sentencias y se podr n obviar los par‚ntesis de las condiciones
en las sentencias como {IF}, {WHILE} o {UNTIL}. Por ejemplo, en
este modo se dar n por v lidas sentencias como: {IF a<0 a=0
END} (ver antes las consideraciones finales).

{_no_strfix}

No terminar autom ticamente las cadenas de texto. Cuando
se mete un car cter en un dato de tipo {#1406,STRING} se genera
c¢digo para, cuando este se inserte m s alla del final de la
cadena, a¤adir espacios en blanco hasta el mismo y el car cter
{NUL} (ascii 0) al final de la cadena. Esta opci¢n deshabilita esta
caracter¡stica.

{_no_optimization}

No optimizar el c¢digo generado. Por defecto se optimizan los
programas, tanto en velocidad como en tama¤o. Esta opci¢n
puede incluirse para deshabilitar estas optimizaciones. Es
decir, si se especifica esta opci¢n, los programas ir n m s lentos
y ocupar n m s memoria.

{_no_range_check}

No comprobar accesos fuera de rango en tablas y
estructuras. El compilador genera c¢digo para comprobar en
tiempo de ejecuci¢n que las expresiones utilizadas como ¡ndices
de una tabla o estructura est n dentro de los l¡mites permitidos,
para emitir un error cuando se acceda fuera de rango. Esta
opci¢n prohibe que se genere dicho c¢digo.

{_no_id_check}

No comprobar la validez de un c¢digo identificador. El
compilador tambi‚n genera c¢digo para comprobar la validez de
un identificador cuando se utiliza este para acceder a la variable
local de otro proceso (como en {id2.graph}). Si se especifica esta
opci¢n al comienzo del programa, no se realizar n estas
comprobaciones.

{_no_null_check}

No comprobar los accesos a punteros nulos ({NULL
POINTER}). Deshabilitar las comprobaciones de accesos a
memoria con punteros nulos o no definidos. Incluyendo esta
opci¢n no se generar  c¢digo para proteger estos accesos de
lectura o escritura a memoria.

{_no_check}

No realizar ninguna de las comprobaciones de seguridad.
Esta opci¢n engloba a las tres anteriores, y prohibe al compilador
generar c¢digo para comprobar cualquier tipo de operaci¢n
an¢mala en tiempo de ejecuci¢n. Los programas pueden ganar
velocidad, pero no se recomienda utilizar estas opciones a no ser
que se trate de programas ya finalizados y sin errores.

{/}

Para utilizar estas opciones, por ejemplo, se podr¡a comenzar un programa con la
siguiente sentencia:

{COMPILER_OPTIONS _max_process=64,_no_id_check;}

En este caso se indicar¡a al compilador que reservara memoria para que, en la
ejecuci¢n del programa pudieran haber 64 procesos simult neamente, y no se
comprobar¡a la validez de los identificadores en los accesos a variables locales de
otros procesos (lo que puede ser £til en programas que utilicen mucho estos accesos,
siempre que el programador tenga la suficiente experiencia como para estar seguro de
lo que hace).

{/}

{Importante: Consideraciones sobre algunas opciones.}

{1.} Los usuarios nuevos en DIV o no muy experimentados en la programaci¢n pueden
simplificar un poco las condiciones con la opci¢n {_simple_conditions}, de forma se
puedan comparar dos valores con el s¡mbolo {=} (adem s de con el s¡mbolo {==}). En
cambio, los usuarios que ya hubieran programado con la primera versi¢n y con
m s experiencia, probablemente preferir n activar la opci¢n
{_extended_conditions} de forma que se puedan crear condiciones complejas, con
asignaciones dentro de las mismas.

{2.} Las opciones {_ignore_error} y todas las variantes de {_no_check} deben utilizarse
£nicamente por programadores con mucha experiencia, y solo en la versi¢n final
del programa. Si no se recomienda su uso, es porque pueden producirse errores
graves de ejecuci¢n, siendo adem s muy dif¡cil averiguar cual ha sido la causa
determinante.

{3.} Los programas ya est n optimizados en general (el c¢digo generado es un {60%}
m s r pido que en la primera versi¢n), y no se conseguir n grandes variaciones en
la velocidad de ejecuci¢n con ninguna de estas opciones. Se pueden utilizar los
{perfiles de tiempo} del trazador para ver la repercusi¢n de cada una.

{4.} La opci¢n {_ignore_errors} suele ser poco conveniente, siempre ser  mejor utilizar
la funci¢n {#240,ignore_error()} para ignorar, en todo caso, algunos errores
determinados de forma selectiva.

{5.} El uso de una sintaxis libre (con {_free_sintax}) tambi‚n tiene sus peligros. Ya que
que los saltos de l¡nea y espacios en blanco carecen de significado, y pueden
producirse interpretaciones indebidas en algunos casos. Por ejemplo, en la
sentencia: {IF derecha ++x END}, el compilador interpretar  que el s¡mbolo{ ++} es el
postincremento de {derecha}, en lugar del preincremento de {x} (aunque el s¡mbolo
este unido a esta £ltima variable). Otro caso similar podr¡a pasar al utilizar punteros
al estilo C, con estas dos asignaciones consecutivas:  {a=1 *ptr=2}, el compilador
las interpretar¡a como: {a=(1*ptr)=2} (aunque estuvieran en lineas diferentes).
Aunque en general, si no se utilizan preincrementos o punteros al estilo C, no
habr n problemas con la sintaxis libre (y tambi‚n se pueden utilizar par‚ntensis o
puntos y coma en puntos concretos, para solucionar estos peque¤os problemas).

{6.} En cambio la opci¢n {_max_process} (que es la £nica que debe aparecer seguida
de un s¡mbolo {=} y un n£mero) se recomienda sin ning£n tipo de reservas. Si se
conoce el n£mero de procesos que pueden llegar a haber a la vez en un programa,
se podr  reservar menos memoria para ellos (quedando esta libre para gr ficos,
sonidos, etc.).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1401,Tipos de datos}

Al margen de los datos ya conocidos de la primera versi¢n (que ahora se conocen
como {#1402,INT}), existen datos de los tipos {#1406,STRING} (cadenas de texto), {#1403,WORD} (enteros
positivos de 16 bit), {#1404,BYTE} (enteros positivos de 8 bit) y {#1405,POINTER} (punteros, de todos
estos tipos). Adem s se pueden definir tablas y estructuras (tambi‚n de cualquiera de
estos tipos) de 2 o 3 dimensiones (ver la {#1011,declaraci¢n de una tabla}).

{#1402,INT} - Datos num‚ricos enteras entre -2147483648 y +2147483647 ({#1177,min_int} ... {#1178,max_int}).

{#1403,WORD} - Datos num‚ricos enteros entre 0 y 65535 (enteros de 16 bit sin signo).

{#1404,BYTE} - Datos num‚ricos enteros entre 0 y 255 (enteros de 8 bit sin signo).

{#1405,POINTER} - Punteros a datos de cualquier otro tipo.

{#1406,STRING} - Cadenas de texto (tablas de car cteres de 8 bit sin signo, entre 0 y 255)

{/}

{Nota:} La palabra reservada {INT} puede omitirse, ya que todos los datos ser n de este tipo por
defecto (enteros de 32 bit con signo).

{/}Ver: {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1402,Datos de tipo INT}

Datos num‚ricos enteras entre -2147483648 y +2147483647 (valores definidos
en las constantes {#1177,min_int} ... {#1178,max_int}).

Este es el dato de tipo b sico del lenguaje, cuaundo no se especifique el
{tipo de un dato}, este ser  {INT}.

{/}Ver: {#1401,Tipos de datos} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1403,Datos de tipo WORD}

Datos num‚ricos enteros entre 0 y 65535 (enteros de 16 bit sin signo).

Las tablas de tipo {WORD} pueden significar un importante ahorro de memoria,
respecto a las tablas de tipo {#1402,INT} (ocupan {2 veces menos} memoria). Pero
{ser n m s r pidas las operaciones con datos de tipo} {#1402,INT}.

Ver la {#1407,alineaci¢n de datos en memoria}, donde se muestra la ocupaci¢n
de memoria de los diferentes tipos de datos.

{/}Ver: {#1401,Tipos de datos} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1404,Datos de tipo BYTE}

Datos num‚ricos enteros entre 0 y 255 (enteros de 8 bit sin signo).

Las tablas de tipo {#1404,BYTE} pueden significar un importante ahorro de memoria,
respecto a las tablas de tipo {#1402,INT} (ocupan {4 veces menos memoria}). Pero
{ser n m s r pidas las operaciones con datos de tipo} {#1402,INT}.

Ver la {#1407,alineaci¢n de datos en memoria}, donde se muestra la ocupaci¢n
de memoria de los diferentes tipos de datos.

{/}Ver: {#1401,Tipos de datos} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1405,Datos de tipo POINTER}

Punteros a datos de cualquier otro tipo ({#1402,INT}), {#1403,WORD},
{#1404,BYTE} y {#1406,STRING}).

Los punteros en el lenguaje DIV tienen un funcionamiento ligeramente diferente a
otros lenguajes de programaci¢n, son m s sencillos de utilizar.

Estos punteros se utilizan como si fueran tablas m¢viles, es decir, tablas a las que se
les puede decir donde deben situarse, asign ndoles un {#1085,OFFSET} (de otro dato) a estos
punteros. Entonces se podr  acceder a los datos situados en dicha posici¢n como
{puntero[¡ndice]}, tanto para lectura como para escritura de los valores.

{/}

{Diferentes datos de tipo puntero:}

{INT POINTER} - Puntero a datos enteros. La palabra INT puede omitirse, declarando
un puntero a {INT} simplemente como {POINTER nombre;}.

{WORD POINTER} - Puntero a una lista o tabla de datos de tipo {WORD}.

{BYTE POINTER} - Puntero a una lista o tabla de datos de tipo {BYTE}.

{STRING POINTER} - Puntero a una cadena de texto contenida en un {STRING}.

{STRUCT POINTER} - Puntero a una estructura, deben declararse como {STRUCT
POINTER nombre_estructura <nombre>;}. Donde {<nombre>} ser  el puntero.

{/}

Por ejemplo, si en un programa existen varias tablas de tipo {WORD} (declaradas como
{WORD t1[9], t2[9], t3[9];}), se puede definir un puntero denominado {ptr}
que permita acceder a cualquiera de ellas (como {WORD POINTER ptr};). Para
referirse a una de las tablas se le debe asignar la direcci¢n de la misma al puntero
(como con {ptr = OFFSET t1;}). A partir de ese momento, se podr  acceder a los
valores de la tabla con el puntero (se podr  acceder a {t1[n]} como {ptr[n]}).

El funcionamiento de los punteros {#1402,INT}), {#1403,WORD} y {#1404,BYTE} es practicamente id‚ntico
(permiten acceder a una lista de datos consecutivos).

Los punteros {#1406,STRING} permiten acceder £nicamente a una sola cadena de texto (a
todos los caracteres de la misma).

En la declaraci¢n de los punteros {#1012,STRUCT} debe indicarse el nombre de la estructura
a la que van a referir, ya que solo podr n acceder a un tipo de estructura. No
obstante, tras asignarle el {#1085,OFFSET} de la estructura (o el de cualquier registro de la
misma), permitir n el acceso a todos los campos y a los sucesivos registros, como si
el puntero se tratara de una estructura convencional.

{Nota:} Para declarar un puntero a una estructura es imprescindible haber declarado antes la
misma. Bastar  con una declaraci¢n en la que se indiquen los diferentes campos, no
es necesario definir el n£mero de registros de la estructura.

{/}

{Limitaci¢n en el acceso de los punteros.}

No se podr  acceder los datos apuntados hasta que no se haya establecido el
{OFFSET del puntero}. No se puede asignar este {OFFSET} en la declaraci¢n del
puntero, se debe hacer en una sentencia del programa, hasta llegar dicha sentencia el
puntero valdr  0 ({puntero nulo}). El acceso a datos con un puntero nulo provocar  un
error de ejecuci¢n (ver las {#1400,opciones de compilaci¢n}).

Es posible {limitar el rango de acceso de un puntero}, indicando en su declaraci¢n el
valor m ximo del ¡ndice permitido para el mismo. Para ello s¡mplemente debe
indicarse este entre corchetes, tras el nombre del puntero. Por ejemplo, la siguiente
declaraci¢n:

{STRING POINTER s[32];}

Definir  un puntero a una cadena de texto, pero £nicamente dejar  acceder
directamente a los 33 (de 0 a 32) primeros car cteres de la misma. Si se intentara
acceder fuera de estos l¡mites, el programa advertir¡a de ello indicando un acceso
fuera de rango.

{/}Ver: {#1401,Tipos de datos} - {#1009,Declaraci¢n de un dato} - {#1085,OFFSET}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1406,Datos de tipo STRING}

Las tablas {STRING} son una excepci¢n, reciben un tratamiento especial como {cadenas
de texto}, y £nicamente pueden tener {1 dimensi¢n}. Si no se le asigna un literal, la
cadena quedar  inicializada a {""} ({cadena vac¡a}).

Si se define una cadena como {STRING s="abc";}, cuando se acceda a ella por su
nombre ({s}) se estar  refiriendo a la cadena contenida ({"abc"}). Adem s se podr 
acceder a cualquier caracter de la cadena como si fuese un elemento de una tabla
(por ejemplo, la sentencia {s[3]="d";} a¤adir¡a una {"d"} a la cadena).

{Nota:} No es necesario declarar entre corchetes la longitud de las cadenas de
texto (se reservar  espacio para guardar hasta 256 caracteres).

{/}

{Operaciones con cadenas de texto.}

Dentro de un programa, suponiendo los datos {s} y {r} de tipo {STRING}, se podr¡an
realizar operaciones como las siguientes.

{1.} Se pueden utilizar los datos de tipo {STRING} en todas las funciones que requieren
un texto (como {#171,write}(0,0,0,0,s), {#132,load_fpg}(r), ...).

{2.} Tambi‚n es posible asignar literales a una cadena simplemente poniendo
{s="cualquier texto...";} o asignar una cadena a otra, como con {s=r;}.

{3.} Pueden sumarse cadenas con sentencias como {s+="texto a a¤adir";} o
{s=r+"ho"+"la";}.

{4.} Adem s puede a¤adirse un car cter a una cadena con sentencias como {s+=ascii;}
o {r+="a";}.

{5.} Se puede quitar un car cter de la cadena (del final) con {s--;}, {s-=1;} o {r=s-1;}.

{6.} Pueden compararse cadenas con condiciones como {(s=="hola")}, {(s>=r)},
{(s<"0"+r)}, etc.

{7.} Y, al margen de todas estas operaciones, existe un gran n£mero de funciones de
manejo de texto (ver la {#1032,lista de funciones del lenguaje}).

{/}

{Literales de varias l¡neas.}

Es posible definir literales en varias l¡neas, para ello s¡mplemente deber  dividirse el
texto en varios, y ponerse estos seguidos (sin separarse por ning£n s¡mbolo). Por
ejemplo, se podr¡a definir una constante como:

{saludo="­Ho"}ú
{       "la!";}

Esto podr¡a utilizarse tambi‚n para inicializar los datos de tipo {STRING}. No hay l¡mite
en el n£mero de l¡neas. Entre dos literales seguidos £nicamente podr¡an aparecer
{#1002,comentarios}.

{/}Ver: {#1401,Tipos de datos} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1407,Alineaci¢n de datos en memoria}

Es importante resaltar que todos los datos ser n, en este lenguaje, alineados a {4
bytes} (tama¤o de los datos de tipo {INT}. Esto quiere decir que el {OFFSET} de todos los datos se situar  siempre en una
direcci¢n de memoria absoluta {m£ltiplo de cuatro}.

Esto tiene implicaciones directas en los datos de los tipos {WORD} y {BYTE}. Ya que
estos ocupan respectivamente {2 bytes} y {1 byte}. Por ello, si se define una variable de
tipo {WORD} se desaprovechar n 2 bytes de memoria, y se define una variable de tipo
{BYTE} se desaprovechar n 3 bytes (ya que el siguiente dato estar  tambi‚n alineado a
4).

Por ello, para aprovechar mejor la memoria del ordenador, es recomendable utilizar
estos dos tipos de datos como tablas (ver la {#1011,declaraci¢n de una tabla}), ya que los diferentes elementos de una tabla
siempre se guardan consecutivos, y no se alinean en memoria.

{/}

{Ejemplos de ocupaci¢n de memoria:}

{BYTE b1;} - Memoria requerida 1, Memoria ocupada 4.

{WORD w1;} - Memoria requerida 2, Memoria ocupada 4.

{INT i1;} - Memoria requerida 4, Memoria ocupada 4.

{BYTE b2[7];} - Memoria requerida 8, Memoria ocupada 8.

{WORD w2[2];} - Memoria requerida 6, Memoria ocupada 8.

{BYTE b3[2];} - Memoria requerida 3, Memoria ocupada 4.

{WORD w3[3]} - Memoria requerida 8, Memoria ocupada 8.

{/}

Como se puede observar, la memoria ocupada (en bytes) por un dato siempre
ser  un valor m£ltiplo de 4.

Esto se debe tener en cuenta tambi‚n en los campos de las {#1012,estructuras de datos} ya
que, por ejemplo; dos variables de tipo {WORD} consecutivas ocupar n {8 bytes},
mientras que una tabla {WORD} con dos elementos ocupar  s¢lo {4 bytes}.

{/}Ver: {#1401,Tipos de datos} - {#1009,Declaraci¢n de un dato}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1408,Los bloques FUNCTION}

Los nuevos bloques {FUNCTION} se comportan de forma an loga a las funciones de
otros lenguajes de programaci¢n, se ejecutan de forma secuencial (y no en paralelo
como los bloques {#1016,PROCESS}), no retornando hasta que no han terminado.

{FUNCTION} {#1001,<nombre>} {(} {#1018,<par metros>} {)}ú
{#1008,<Declaraci¢n de datos privados>}ú
{#1086,BEGIN}ú
    {#1017,<sentencia>} {;}ú
    ...ú
{#1091,END}

Estos bloques seguir n funcionando de forma muy similar a los procesos normales,
pero con una importante diferencia: detendr n al proceso llamador hasta finalizar,
es decir, que estas funciones dormir n al proceso que las ha llamado, hasta que estas
funciones retornen o su proceso finalice.

Si la funci¢n no utiliza sentencias {#1029,FRAME}, se comportar  igual que un
proceso normal, pero si una funci¢n ejecuta la sentencia {#1029,FRAME}, no volver  al
bloque que la llam¢ (como lo har¡a un proceso normal).

Por lo tanto, una funci¢n siempre puede devolver un valor con {#1028,RETURN}{(}<expresi¢n>{)},
incluso despu‚s de haber dado uno o varios {#1029,FRAME}.

{/}

{Programaci¢n secuencial.}

No se recomienda programar s¢lo con funciones y de forma secuencial, pero el
conocer c¢mo se puede hacer facilitar  el entendimiento de la programaci¢n DIV a
programadores de otros lenguajes.

Es posible hacer un programa al estilo de la programaci¢n tradicional utilizando
exclusivamente los bloques {FUNCTION}, de esta forma £nicamente habr  un proceso
en ejecuci¢n en cada momento.

Al programar de esta forma, la sentencia {#1029,FRAME} se convierte en la orden expl¡cita de
{volcado a v¡deo}. Logicamente, si s¢lo hay un proceso ejecut ndose, cuando este
ejecute esta orden el sistema mostrar  la siguiente imagen del programa.

Pero, programando asi, ¨se podr¡an mostrar varios gr ficos en pantalla?.

La respuesta es s¡, ya que se podr¡an crear una especie de mini-procesos que funcionaran como
una instrucci¢n del estilo "pinta un gr fico para la siguiente imagen" (a diferencia de
las funciones como {#146,put()}, que pintan un gr fico para siempre).

Para mostrar un gr fico en la siguiente imagen se debe construir un proceso que
reciba los par metros visuales necesarios y simplemente ejecute una £nica sentencia
{#1029,FRAME}, por ejemplo:

{PROCESS pinta_gr fico(x,y,graph)}ú
{BEGIN}ú
{    FRAME;}ú
{END}ú

Al llamar a este proceso {se crear¡a un proceso temporal que se pintar¡a en la
siguiente imagen} y entonces desaparecer¡a. Podr¡an contemplarse otros par metros
(adem s de {#1123,x}, {#1124,y}, {#1125,z}), como {#1131,file}, {#1128,size},
{#1129,angle}, {#1125,z}, ... (ver los {#1201,datos locales predefinidos}).

Claro que, al programar de esta forma, se deber¡a crear (normalmente en una
{#1012,estructura} global) una tabla de sprites de forma que el programa pudiera gestionar
todos los gr ficos. Esto, que puede parecer complicado, es la forma natural de
programar los juegos en cualquier otro lenguaje que no sea DIV.

{/}

{Aplicaciones en el programa principal.}

Las sentencias que aparecen entre las palabras {#1086,BEGIN} y {#1091,END} del programa principal
(tras las declaraciones de datos), controlan el {#1015,proceso principal del programa}. Este
es el encargado de inicializar el programa, realizar las presentaciones, controlar los
bucles de men£, los bucles de juego (creando los procesos necesarios), y finalizar el
programa.

En el programa principal, puede ser muy £til llamar a bloques {FUNCTION}. Ya que de
esta forma ser  detenido el programa principal mientras se ejecuta la parte que
controla dicha funci¢n.

Por ejemplo, la secuencia de presentaci¢n podr¡a hacerse en una funci¢n, el men£ de
opciones en otra, etc. Adem s, se recuerda que las funciones pueden al finalizar,
devolver siempre un valor con {#1028,RETURN}{(}<expresi¢n>{)}, lo cual puede ser tambi‚n £til para
que, por ejemplo el men£, devuelva el n£mero de opci¢n que ha sido seleccionada.

{Nota:} Que finalice la ejecuci¢n del c¢digo principal no implica que finalice la ejecuci¢n del
programa, pues ‚sta continuar  si quedan procesos vivos; si se quiere forzar la
terminaci¢n del programa cuando finalice este c¢digo, se puede utilizar, por ejemplo, la
funci¢n {#129,let_me_alone()} justo antes del {#1091,END} del {#1015,c¢digo principal}, o bien la funci¢n
{#109,exit()} (en cualquier punto del programa).

{/}Ver: {#1016,Los bloques PROCESS} - {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1409,GLOBAL argv[], GLOBAL argc}

{argv[];} // Argumentos del programaú
{argc;}   // N£mero de argumentos{/}

Pueden accederse a los par metros pasados a un programa (normalmente al
ejecutarlo desde modo MSDOS), al estilo del lenguaje C, en los datos
globales predefinidos {argc} y {argv[]}.

La variable {argc} contendr , al ejecutarse el programa, el n£mero de par metros.
Siendo {1} el n£mero m¡nimo, ya que se cuenta siempre como un par metro el nombre
del propio ejecutable del juego.

La tabla {argv[]} es una tabla de {cadenas de texto}, y tendr  definidas tantas posiciones
como indique la variable {argc}, y en {argv[0]} estar  siempre el nombre del programa.

{/}

{Nota:} Cuando se ejecuta un programa desde el entorno ventanas de DIV, este no recibir 
m s par metros que el propio nombre del ejecutable. Por lo que estas variables ser n
£tiles £nicamente en las versiones ya instaladas de los programas.

{/}Ver: {#1200,Datos globales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1410,GLOBAL STRUCT net}

{STRUCT net;}ú
    {device;}      // Dispositivo de conexi¢nú
    {com;}         // Puerto de comunicacionesú
    {speed;}       // Velocidad de conexi¢nú
    {number;}      // N£mero de tel‚fonoú
    {init;}        // Cadena de inicio del m¢demú
    {mode;}        // Modo (pulsos o tonos)ú
    {server;}      // Indica si es servidorú
    {max_players;} // Numero m ximo de jugadoresú
    {num_players;} // Numero actual de jugadoresú
{END}

Esta estructura de datos es de nivel muy avanzado y se requiere bastante
experiencia en programaci¢n para poder crear un juego orientado a una
conexi¢n de red (se puede encontrar m s informaci¢n en el {manual de usuario}).

Contiene los datos sobre el hardware de red, se debe utilizar en conjunto
con las funciones {#180,net_join_game()} y {#181,net_get_games()}.

La estructura {net} tiene un £nico registro. En los diferentes campos del mismo
se se establecen los par metros que definen el tipo de conexi¢n.

{/}

{device} - Dispositivo a trav‚s del cual se va a establecer la conexi¢n,
este puede contener uno de estos tres valores:

 {1} - Conexi¢n en una {red local}, con protocolo IPX.

 {2} - Conexi¢n a trav‚s de un cable serie (s¢lo dos equipos).

 {3} - Conexi¢n por m¢dem (s¢lo dos equipos).

En funci¢n del dispositivo se deber n inicializar unos u otros campos de la
estructura {net}, ya que muchos de estos par metros son espec¡ficos para
un dispositivo concreto.

{/}

{com} - Puerto de comunicaciones a emplear para la conexi¢n, es decir, el
n£mero de dispositivo COM (de COM1 a COM4), indic ndolo como un valor num‚rico
entre {1} y {4}.

Este campo £nicamente se debe definir para conexiones por cable serie o a trav‚s
de un m¢dem.

{/}

{speed} - Velocidad en baudios (n£mero de bits por segundo), hasta 115000.
Esta velocidad debe ajustarse a las posibilidades del cable o m¢dem empleado,
y del volumen de datos que requiera la comunicaci¢n del programa.

Este campo £nicamente se debe definir para conexiones por cable serie o a trav‚s
de un m¢dem.

{/}

{number} - N£mero de tel‚fono, por supuesto este campo es necesario £nicamente
en conexiones a trav‚s de m¢dem.

Por ejemplo, se debe asignar el n£mero de tel‚fono a marcar con una sentencia
como la siguiente: {net.number="912345678";}.

{/}

{init} - Cadena de inicio, tambi‚n es un campo exclusivo para las conexiones
por m¢dem; por ejemplo una sentencia como: {net.init="ATZ";}.

{/}

{mode} - Modo en el que se debe establecer la conexi¢n por m¢dem (tambi‚n s¢lo
para este dispositivo), los valores pueden ser los siguientes:

 {0} - Pulsos.

 {1} - Tonos.

{/}

{server} - Indica si un equipo es el servidor. Se trata de un dato informativo
(es un campo de s¢lo lectura, no se debe modificar).

En una conexi¢n, £nicamente un equipo tendr  el campo {net.server} a {1}, este
equipo ser  el servidor de la partida, y es el que debe centralizar las acciones
m s importantes del programa.

{/}

{max_players} - N£mero m ximo de jugadores que se permiten en una partida,
de {2} a {16}. Este es un campo £til £nicamente en conexiones por red local,
ya que en conexiones de cable serie o m¢dem el n£mero m ximo de jugadores
siempre ser  {2}.

Este n£mero debe coincidir con el n£mero m ximo de registros que tenga la
estructura global utilizada como paquetes de comunicaci¢n entre los diversos
equipos.

{/}

{num_players} - N£mero actual de jugadores conectados a la partida,
de {1} a {net.max_players}. Este es un valor din mico, que va variando
segun se vayan produciendo las conexiones (se pueden ir conectando y
desconectando jugadores en cualquier momento).

La programaci¢n del juego es la que debe determinar si los jugadores
pueden entrar y salir din micamente de la partida, o bien si deben estar
todos conectados antes de que esta de comienzo.

{/}Ver: {#1200,Datos globales} - {#180,net_join_game()} - {#181,net_get_games()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1411,GLOBAL STRUCT m8}

{STRUCT m8[9];}ú
    {z;}      // Prioridad de impresi¢nú
    {camera;} // Identificador de la c maraú
    {height;} // Altura de la c maraú
    {angle;}  // Angulo verticalú
{END}ú

Esta estructura de {10} registros contiene ciertos campos relacionados
con par metros modificables de las {ventanas de modo 8}. Los diez
registros tienen los mismos nombres de campos, pero cada uno de
ellos modifica los par metros de una ventana de modo 8 diferente
(ya que pueden activarse hasta 10 ventanas de este tipo).

Una {ventana de modo 8} se podr¡a definir como una regi¢n de pantalla que
muestra un mapa de sectores tridimensional.

Para que un registro (del {0} al {9}) de la {estructura m8} tenga sentido,
primero debe activarse dicha {ventana de modo 8} (del {0} al {9}) con la
funci¢n {#190,start_mode8()} (ver esta funci¢n para m s informaci¢n sobre
las ventanas de modo 8}.

Se entiende que los campos de esta estructura son complementarios a los
par metros de llamada de esta £ltima funci¢n. Para poder observar un ejemplo
pr ctico de un modo 8, se puede acceder a la ayuda sobre la funci¢n
{#189,load_wld()} o de {#190,start_mode8()}.

{/}

{Forma de uso de la estructura m8:}

Para acceder a estos campos se debe preceder el nombre del campo
por la palabra {m8}, el n£mero de registro entre corchetes y el s¡mbolo
{#1063,. (punto)}.

Por ejemplo, si se inicializaran dos ventanas de modo 8, la n£mero 0 y la
n£mero 1, se podr¡a acceder a la variable {camera} de ambas ventanas como
{m8[0].camera} y {m8[1].camera}, respectivamente. Cuando se acceda a la
ventana n£mero 0 de modo 8 se puede, adem s, omitir el n£mero de
ventanas entre corchetes, es decir, que la variable {m8.camera} y la variable
{m8[0].camera} son, a todos los efectos, la misma para el lenguaje.

{/}

{Se muestra a continuaci¢n una descripci¢n detallada de cada campo}

{z} - Prioridad de impresi¢n del modo 8, aqu¡ se indica en qu‚ plano de profundidad
se debe pintar esta ventana, respecto al resto de procesos. Por defecto, esta
variable valdr  {256} lo cual quiere decir que, como los procesos por defecto
tienen su variable {#1125,local z} a {0}, la ventana de modo 8 se pintar  en un plano
de profundidad mayor, m s al fondo, visualiz ndose los gr ficos de los procesos
por encima de la ventana. Para variar esta situaci¢n se puede modificar la
variable {z} de la ventana (por ejemplo ponerla a{ -1}) o la variable {z} de
los procesos (por ejemplo ponerla a {257}).

{/}

{camera} - {#1039,C¢digo identificador del proceso} en el que se sit£a la c mara. Para mover
la c mara que controla la visi¢n del modo 8, £nicamente se debe crear un proceso
de modo 8, un proceso que tenga su variable local {#1122,ctype} {=} {#1412,c_m8}, y poner
su {#1039,c¢digo identificador} en la variable {camera} de esta estructura.
Tras esto, s¡mplemente se deben modificar las variables locales {#1123,x}, {#1124,y}, {#1125,z} y {#1129,angle} de
este proceso y, por ejemplo, utilizar la funci¢n {#101,advance()} para mover hacia
delante la c mara.

{/}

{height} - Altura de la c mara respecto al proceso, por defecto este campo
est  inicializado a {32}. El proceso de modo 8 se situar  verticalmente en
su coordenada {z}, su variable local {height} determina la altura del propio
proceso, y este campo ({m8.height}) determina la altura de la c mara (de los
{ojos} del proceso respecto a su base).

{/}

{angle} - Angulo vertical de la c mara, este  ngulo es un valor entre{ -128} y {128}.
Define si la c mara mira hacia arriba o hacia abajo. Cuando {m8.angle} valga {0},
que es el valor por defecto, la c mara mirar  hacia el centro.

El  ngulo horizontal ser  la variable local {angle} del propio proceso
que est  siendo utilizado como c mara de la ventana (cuyo identificador
est  en {m8.camera}).

{/}

V‚ase tambi‚n las {variables locales} relacionadas con el {modo 8}.

  {#1421,LOCAL radius}ú
  {#1422,LOCAL m8_wall}ú
  {#1423,LOCAL m8_sector}ú
  {#1424,LOCAL m8_nextsector}ú
  {#1425,LOCAL m8_step}ú

{/}Ver: {#1200,Datos globales} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1412,c_m8}

Constante: {c_m8}
{/}

Esta constante se utiliza para asignarla a la variable local predefinida
{#1122,ctype} que sirve para definir el tipo de coordenadas que
tendr  un proceso. Su valor es {3}.

ste es el valor asignado a {#1122,ctype} para que
las coordenadas del gr fico del proceso se interpreten como referidas
a una ventana de modo 8, a coordenadas sobre el mapa de sectores
tridimensional que se muestra en la misma.

Para m s informaci¢n sobre las {ventanas de modo 8}, se puede acceder
a la funci¢n {#190,start_mode8()}, utilizada para activarlas.

Existen otras constantes utilizadas para otros sistemas de coordenadas,
la lista completa es la siguiente:

    {#1167,c_screen} - Coordenadas de pantallaú
    {#1168,c_scroll} - Coordenadas de scrollú
    {#1169,c_m7}     - Coordenadas de modo 7ú
    {c_m8}     - Coordenadas de modo 8ú

{/}Ver: {#1202,Constantes} - {#1122,ctype} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1413,GLOBAL STRUCT dirinfo}

{STRUCT dirinfo;}ú
    {files;}      // Numero de archivos en listaú
    {name[1024];} // Nombres de los archivosú
{END}ú

Esta estructura global predefinida se utiliza como retorno de la funci¢n
{#231,get_dirinfo()}, para contener la lista de archivos de un directorio
(o carpeta).

Se trata de una estructura de un £nico registro, que agrupa una variable
{files} y una tabla de punteros a {cadenas de texto} ({name[]}).

{/}

{Se muestra a continuaci¢n una descripci¢n detallada de cada campo}

{name[]} - La funci¢n {#231,get_dirinfo()} simplemente retorna el {n£mero total} de archivos listados;
los nombres de estos archivos se guardan en esta estructura global,
en la tabla {name[]} de la misma (el primer nombre de archivo se guarda en
{dirinfo.name[0]}, el segundo en {dirinfo.name[1]}, etc.).

{/}

{files} - El {n£mero total} de archivos listados que retorna esta funci¢n se guarda
adem s este campo (es decir, en {dirinfo.files}).

{/}

La lista de nombres de archivos se guarda siempre en orden alfab‚tico, no
obstante se puede utilizar la funci¢n {#213,qsort()} para ordenar la
estructura por otro criterio.

{/}Ver: {#1200,Datos globales} - {#231,get_dirinfo()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1414,GLOBAL STRUCT fileinfo}

{STRUCT fileinfo;}ú
    {string fullpath[254];} // Nombre completoú
    {drive;}                // Unidad de discoú
    {string dir[254];}      // Directorioú
    {string name[7];}       // Nombreú
    {string ext[3];}        // Extensi¢nú
    {size;}                 // Tama¤o (en bytes)ú
    {day;}                  // D¡aú
    {month;}                // Mesú
    {year;}                 // A¤oú
    {hour;}                 // Horaú
    {min;}                  // Minutoú
    {sec;}                  // Segundoú
    {attrib;}               // Atributosú
{END}ú

Esta estructura global predefinida se utiliza como retorno de la funci¢n
{#232,get_fileinfo()}, para contener los atributos de un archivo (o
subdirectorio).

Se trata de una estructura de un £nico registro, que agrupa varias
cadenas de texto (datos de tipo {#1406,STRING}) y variables num‚ricas (datos
de tipo {#1402,INT}).

{/}

{Se muestra a continuaci¢n una descripci¢n detallada de cada campo}

{fullpath} - Nombre completo (incluyendo la ruta). La ruta de acceso al archivo se puede especificar completa (a partir del
directorio raiz de la unidad, como "C:\WINDOWS\...") o relativa al directorio
actual (a partir de donde se ejecute el juego, como "MAP\MIOS\...").
En cualquier caso, en {fileinfo.fullpath} siempre se devolver  la ruta
completa a partir del directorio raiz, incluyendo la letra de la unidad.

{/}

{drive} - Unidad de disco en la que se encuentra el archivo sobre el
que se ha solicitado informaci¢n. La unidad no se devuelve como la letra
correspondiente, sino como un n£mero, estableci‚ndose la siguiente
correspondencia: {1} para {A:}, {2} para {B}:, {3} para {C:}, etc.

{/}

{dir} - Directorio donde se encuentra el archivo. En esta cadena no se
devuelve £nicamente el nombre de la carpeta que contiene al archivo, sino
que se especifica la ruta completa, a partir del directorio raiz pasando
por todos los directorios (por ejemplo "\DIV\MAP\"). Siempre se devolver 
con una barra invertida (\) al inicio y otra al final.

{/}

{name} - Nombre del archivo, este campo ({fileinfo.name}), retorna el
nombre del archivo, sin extensi¢n, de un m ximo de {8 car cteres}.

{/}

{ext} - Extensi¢n del archivo. Como £ltima parte del nombre se retorna
en este campo la extensi¢n del archivo, en una cadena que incluye el punto
que separa el nombre de la misma.

{/}

{size} - Tama¤o del archivo, este valor ser  {0} si se solicita informaci¢n
sobre un directorio. El tama¤o se retorna como el n£mero de datos simples, es
decir, como el n£mero de datos de tipo {#1402,INT} que caben en el archivo
(n£mero de bytes entre cuatro). Es posible variar esta relaci¢n modificando
la variable global {#1420,unit_size}).

{/}

{day} - D¡a del mes de la £ltima actualizaci¢n del archivo.

{month} - Mes de la £ltima actualizaci¢n del archivo.

{year} - A¤o de la £ltima actualizaci¢n del archivo.

{hour} - Hora de la £ltima actualizaci¢n (de {0} a {23}).

{min} - Minuto dentro de la hora.

{sec} - Segundo dentro del minuto.

{/}

{attrib} - Atributos del archivo, estos indican las caracter¡sticas del
archivo, tales como si es un archivo de sistema, s¢lo de lectura, oculto,
etc. Este valor es la suma de las siguientes constantes:

  {0} - Archivo normal.ú
  {1} - Archivo de s¢lo lectura.ú
  {2} - Archivo oculto.ú
  {4} - Archivo de sistema.ú
  {8} - Etiqueta de volumen.ú
 {16} - Subdirectorio.ú
 {32} - Marcha de archivo.ú

Por ejemplo, para un archivo de sistema y oculto, el valor de {fileinfo.attrib}
ser¡a {6} (2 Oculto + 4 Sistema).

{/}Ver: {#1200,Datos globales} - {#232,get_fileinfo()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1415,GLOBAL STRUCT video_modes}

{STRUCT video_modes[31];}ú
    {wide;}   // Ancho del modoú
    {height;} // Alto del modoú
    {mode;}   // N£mero del modoú
{END}ú

En la estructura global predefinida {video_modes} se encuentra, al inicio
de todos los programas, la {lista de modos vesa} soportados por
el adaptador de v¡deo del ordenador (todos ellos de {256 colores}),
hasta {un m ximo de 32} (del [0] al [31]).

El n£mero de modos encontrados se guarda en la variable global
{#1419,num_video_modes}.

Esta informaci¢n la genera el sistema de forma autom tica, sin que se
requiera llamar a ninguna funci¢n. Para todos los modos encontrados se
registra la siguiente informaci¢n:

{wide} - N£mero de pixels en horizontal del modo de v¡deo.

{height} - N£mero de pixels en vertical del modo de v¡deo.

{mode} - N£mero de modo. Este valor se puede usar directamente como par metro para
la funci¢n {#157,set_mode()}.

Una vez seleccionado el {ancho} y {alto} del modo de v¡deo que se desea activar,
y por tanto se tiene el {n£mero de registro} de la estructura del mismo, se
se debe activar este llamando a la funci¢n como:

  {set_mode(video_modes[}<n£mero de registro>{].mode);}

{/}

{Nota:} Adem s de los modos registrados en esta estructura, existe una lista
de modos de v¡deo est ndar, cuyos n£meros se encuentran en las constantes
{#1150,m320x200 ... m1024x768}.

{/}Ver: {#1200,Datos globales} - {#1419,num_video_modes} - {#157,set_mode()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1416,GLOBAL channel[]}

{channel[31];} // Utilizaci¢n de los canales de sonido{/}

La tabla globlal {channel} mantiene informaci¢n sobre la utilizaci¢n
de los diferentes canales de sonido (hasta 32) del sistema de audio.

Cada vez que se toca un sonido con la funci¢n {#159,sound()}, se env¡a
el mismo a uno de estos canales. Y cuando se inicia la reproducci¢n de
un m¢dulo musical con la funci¢n {#216,song()}, se reservan un determinado
n£mero de canales para el mismo (hasta 24).

En esta tabla, cada posici¢n representa a uno de estos canales de sonido,
y el sistema pondr  a {1} cada posici¢n cuando se utilice su respectivo
canal.

La funci¢n {#256,change_channel()} permite modificar los par metros de
cada uno de estos canales.

{/}

{Nota:} El sistema nunca pondr  a {0} las posiciones de la tabla {channel},
debe ser el programa el que borre la tabla, para de esta forma poder determinar
cuando se utiliza nuevamente un canal.

{/}Ver: {#1200,Datos globales} - {#256,change_channel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1417,GLOBAL vsync}

{vsync=0;} // Esperar al retrazo vertical{/}

La variable global predefinida {vsync} define un valor l¢gico (0 o 1) que
indica si debe esperarse al {retrazo vertical} antes de volcar la siguiente
imagen a v¡deo (cuando todos los procesos ejecuten la sentencia {#1029,FRAME}).

Por defecto esta variable estar  siempre a {0}, es decir, que no se espera
al retrazo vertical antes de volcar cada imagen a v¡deo.

Para indicar al sistema que debe esperar al retrazo vertical se debe poner
esta variable a {1} (con la sentencia {vsync=1;}).

{/}

{Nota:} Esperar el retrazo vertical puede proporcionar una suavidad de
movimientos mucho mayor en los programas (el efecto es sobre todo m s notable
en los efectos de panor mica, ver {#163,start_scroll()}), pero esperar al
retrazo tambi‚n enlentecer  los programas en la gran mayor¡a de ocasiones.

{/}Ver: {#1200,Datos globales}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1418,GLOBAL draw_z}

{draw_z=-255;} // Plano de profundidad de las primitivas gr ficas{/}

Las {primitivas gr ficas} son las l¡neas rectas, rect ngulos, c¡rculos,
etc., que se imprimen con la funci¢n {#249,draw()}.

En esta variable global se indica el plano de profundidad en el que deben
aparecer las primitivas gr ficas en pantalla, esto es, qu‚ debe aparecer por encima
y qu‚ por debajo.

Los planos de profundidad pueden ser cualquier n£mero entero dentro
del rango ({#1177,min_int} ... {#1178,max_int}) y, cuanto mayor sea el
n£mero, m s al fondo se situar  la imagen.

Los gr ficos de los procesos tienen su variable {#1125,local z} a {0} por
defecto, los textos {#1106,text_z} a{ -256} y el puntero del rat¢n tiene
{#1100,mouse.z} a{ -512} por defecto.

Esto quiere decir que, por defecto, si no se no modifican estos valores,
aparecer n las primitivas gr ficas sobre los procesos, pero por debajo
de los textos y del puntero del rat¢n.

{/}

{Nota 1:} La variable {draw_z} es {#1006,GLOBAL} para todas las primitivas gr ficas, es decir, que no
se pueden representar estas en diferentes planos.

{/}Ver: {#1200,Datos globales} - {#249,draw()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1419,GLOBAL num_video_modes}

{num_video_modes;} // N£mero de modos de v¡deo detectados{/}

La variable global {num_video_modes} contiene el n£mero de modos de v¡deo
VESA que se han detectado en el adaptador gr fico del sistema.

Los par metros de cada uno de estos modos se registran en la estructura
global {#1415,video_modes}, por lo tanto la variable {num_video_modes}
define el n£mero de registros definidos en dicha estructura.

{/}

{Nota:} Adem s de los modos registrados en dicha estructura, existe una lista
de {10 modos de v¡deo est ndar}, cuyos n£meros se encuentran en las constantes
{#1150,m320x200 ... m1024x768}.

{/}Ver: {#1200,Datos globales} - {#1415,STRUCT video_modes} - {#157,set_mode()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1420,GLOBAL unit_size}

{unit_size=4;} // Unidad m¡nima de lectura/escritura{/}

La variable global predefinida {unit_size} indica cual es el tama¤o de la
unidad m¡nima de lectura y escritura de las funciones de archivos basadas
en {handles}.

Por defecto valdr  siempre {4}, ya que 4 bytes es el tama¤o
de los datos est ndar {#1402,INT} (enteros de 32 bit), y todos los datos
se alinean en memoria cada 4 bytes (ver la {#1407,alineaci¢n de datos en
memoria}).

Las funciones que tienen en cuenta el tama¤o de unidad indicado en {unit_size}
son las siguientes:

  {#225,fread()}ú
  {#226,fwrite()}ú
  {#227,fseek()}ú
  {#228,ftell()}ú
  {#229,filelength()}ú

Y adem s el campo {size} de la estructura global {#1414,fileinfo}.

{/}

Que el tama¤o m¡nimo sea 4 implica que no se pueden leer ni escribir archivos
cuya longitud no sea m£ltiplo de dicho n£mero.

Se puede cambiar este tama¤o; por ejemplo asignando {1} a {unit_size} (con la
sentencia {unit_size=1;}). De este modo, todas las {longitudes} de las
funciones anteriores se indicar n ahora en bytes (y no en datos).

No obstante, al cambiar el tama¤o de la unidad, se debe tener en cuenta lo
siguiente:

- {#1094,SIZEOF()} continuar  devolviendo la longitud en datos (de 4 bytes).
Por ejemplo, para grabar una tabla en disco no bastar  con indicar {sizeof(}<tabla>{)}
como longitud, sino que se deber  multiplicar la misma por 4 (en caso de haber
definido {unit_size} como {1}).

- Las funciones de archivos {#155,save()} y {#130,load()} (que no son funciones
basadas en {handles}) continuar n indicando la longitud en datos.

- Las funciones de memoria din mica {#257,malloc()} y {#258,free()} tambi‚n
continuar n trabajando con longitudes en datos, por lo que se deber n hacer
los ajustes oportunos en caso de trabajar con ambos conjutos de funciones.

{/}Ver: {#1200,Datos globales} - {#1407,Alineaci¢n de datos en memoria}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1421,LOCAL radius}

{radius;} // Radio (ancho) de los procesos de modo 8{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {radius}.

Esta variable local se utiliza exclusivamente en los procesos de un
modo 8 (aquellos que tienen asignado {#1412,c_m8} a {#1122,ctype}).

En {radius} se indica el radio, o tama¤o en horizontal, del proceso.
El sistema requiere este valor para calcular las colisiones con los
l¡mites de los sectores del mapa tridimensional.

Cuanto menor sea el valor de {radius} para un proceso, m s se podr 
acercar este a las paredes del mismo y, por lo tanto, mayores se ver n
los puntos (o texel) de las texturas de las mismas.

{/}

{Nota:} Para m s informaci¢n sobre el modo 8, v‚ase la estructura
global {#1411,m8} y la funci¢n {#190,start_mode8()}, que es la empleada
para inicializar regiones de este tipo.

{/}Ver: {#1201,Datos locales} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1422,LOCAL m8_wall}

{m8_wall;} // N£mero de pared del mapa de sectores{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {m8_wall}.

Esta variable local se utiliza exclusivamente en los procesos de un
modo 8 (aquellos que tienen asignado {#1412,c_m8} a {#1122,ctype}).

En {m8_wall} el sistema guardar , de forma autom tica, el n£mero de
pared contra la que ha colisionado el proceso.

Esta informaci¢n puede ser £til para detectar distintas zonas
activas dentro de un mapa de sectores (como puertas, interruptores, etc.).

{/}

{Nota:} Para m s informaci¢n sobre el modo 8, v‚ase la estructura
global {#1411,m8} y la funci¢n {#190,start_mode8()}, que es la empleada
para inicializar regiones de este tipo.

{/}Ver: {#1201,Datos locales} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1423,LOCAL m8_sector}

{m8_sector;} // N£mero de sector en el que se encuentra el proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {m8_sector}.

Esta variable local se utiliza exclusivamente en los procesos de un
modo 8 (aquellos que tienen asignado {#1412,c_m8} a {#1122,ctype}).

En {m8_sector} el sistema guardar , de forma autom tica, el n£mero de
sector sobre el que se encuentra el proceso, dentro del mapa.

La informaci¢n del n£mero sector puede ser £til para programar eventos
en funci¢n del sector en el que entre un proceso.

{/}

{Nota:} Para m s informaci¢n sobre el modo 8, v‚ase la estructura
global {#1411,m8} y la funci¢n {#190,start_mode8()}, que es la empleada
para inicializar regiones de este tipo.

{/}Ver: {#1201,Datos locales} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1424,LOCAL m8_nextsector}

{m8_nextsector;} // Sector hacia el que se dirige el proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {m8_nextsector}.

Esta variable local se utiliza exclusivamente en los procesos de un
modo 8 (aquellos que tienen asignado {#1412,c_m8} a {#1122,ctype}).

En {m8_nextsector} el sistema guardar , de forma autom tica, cual es
el sector hacia el que se dirige un proceso. Es decir, cuando el
proceso colisione con una pared de mapa, el sistema comprobar  si
tras la misma existe alg£n otro sector y, en ese caso, indicar 
en esta variable su n£mero.

Esta informaci¢n puede ser £til, por ejemplo, para obtener las
alturas a las que se encuentra dicho sector (ver {#193,get_sector_height()})
y, de esta forma, averiguar si el proceso debe subir o bajar, y cuanto,
para acceder a dicho sector.

{/}

{Nota:} Para m s informaci¢n sobre el modo 8, v‚ase la estructura
global {#1411,m8} y la funci¢n {#190,start_mode8()}, que es la empleada
para inicializar regiones de este tipo.

{/}Ver: {#1201,Datos locales} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1425,LOCAL m8_step}

{m8_step;} // Altura que puede subir el proceso{/}

Esta variable predefinida es {#1007,LOCAL}, lo que significa que cada
proceso tendr  su propio valor en su variable {m8_step}.

Esta variable local se utiliza exclusivamente en los procesos de un
modo 8 (aquellos que tienen asignado {#1412,c_m8} a {#1122,ctype}).

En {m8_step} se indica cual es la altura m xima que el proceso puede
subir para alcanzar un sector contiguo, algo as¡ como "la altura de
escal¢n" que puede subir este proceso.

Cuando un proceso avance hacia otro sector m s elevado, el sistema
comprobar  mediante esta variable si el proceso puede acceder directamente
al mismo, en caso afirmativo se ajustar  la nueva altura del proceso de
forma autom tica y, en caso contrario, el proceso se detendr  (pues
colisionar  con la pared que separa ambos sectores).

{/}

{Nota:} Para m s informaci¢n sobre el modo 8, v‚ase la estructura
global {#1411,m8} y la funci¢n {#190,start_mode8()}, que es la empleada
para inicializar regiones de este tipo.

{/}Ver: {#1201,Datos locales} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1426,GLOBAL fps}

{fps;} // N£mero de im genes por segundo{/}

La variable global predefinida {fps} (frames per second) mantiene el
n£mero de im genes por segundo que est  mostrando un programa.

Esta variable es actualizada por el gestor de procesos de DIV Games
Studio autom ticamente. No se mantiene el valor instant neo, sino
una media de los £ltimos segundos, por ello se necesita cierto tiempo
de ejecuci¢n para que el valor de {fps} se estabilice.

La funci¢n {#156,set_fps()} permite establecer el n£mero de im genes
por segundo del programa, pero de esta forma se establece el n£mero
de im genes ideal, y no el real (que es el que contabiliza {fps}).

Es decir, que esta variable sirve de cuenta para saber cuantas im genes
se est n volcando a v¡deo por cada segundo, como media.

{/}

{Nota:} La variable {fps} mantiene un dato de s¢lo lectura, no se conseguir 
ning£n efecto modificando su contenido desde un programa.

{/}Ver: {#1200,Datos globales} - {#156,set_fps()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2000,­Bienvenido a DIV 2!}{+1,1}{-}

Este texto muestra los conceptos b sicos para introducirle en el manejo
de este entorno de desarrollo.

Utilizando esta ayuda electr¢nica se podr  acceder a mucha informaci¢n sobre
este entorno, aun as¡, el aprendizaje del lenguaje de programaci¢n y las
opciones del programa se describen £nicamente en el {Manual de usuario}.

{/}

{Nota:} Si esta es la primera vez que Vd. utiliza este entorno de programaci¢n
de videojuegos, debe saber que, para salir de todos los programas
ejecutados desde DIV, podr  siempre utilizar la combinaci¢n de teclas {ALT}+{X}.

{/}

  {Novedades respecto a la versi¢n anterior}

  - {#2001,Novedades en el lenguaje}ú
  - {#2002,Novedades en el entorno}ú

  {Relaci¢n de los temas de introducci¢n}

  - {#1,C¢mo usar el sistema de ayuda}ú
  - {#1300,Respuestas a preguntas comunes (FAQ)}ú
  - {#2003,Resoluci¢n de problemas de configuraci¢n}ú

  - {#2004,¨Que es DIV Games Studio?}ú
  - {#2005,Trabajando con las ventanas}ú
  - {#2006,Tipos de ventanas}ú
  - {#2010,Fijando un modo de video}ú
  - {#2011,La ventana de configuraci¢n}ú
  - {#2012,Toma de contacto con el lenguaje}ú
  - {#2013,Trazando los programas}ú

{/}

DIV Games Studio apareci¢ en el mercado en Diciembre de 1998 como el primer
entorno de desarrollo con un lenguaje de programaci¢n dise¤ado exclusivamente
para la programaci¢n de juegos.

En un principio, nuestra pretensi¢n como desarrolladores no fu‚ la creaci¢n de
un entorno profesional, sino m s bien de crear un entorno simple y ameno que
pudiera servir como introducci¢n al apasionante mundo del desarrollo de juegos;
algo as¡ como un "juego para hacer juegos" en el que cualquier persona pudiera
aprender a programar.

La muy buena aceptaci¢n del mismo ha conducido a la aparici¢n de esta segunda
versi¢n del entorno, en la que se mantiene la misma filosof¡a.

Las muchas opiniones, cr¡ticas y sugerencias recibidas han permitido crear un
DIV un poco mejor en todos sus aspectos. Se ha intentado mejorar, aunque s¢lo
fuera un poco, todas las facetas del entorno. De esta forma no hay grandes
diferencias con la versi¢n anterior, pero si muchas (y muy pr cticas).

Tenemos que dar las gracias a todas las personas que han apoyado nuestra idea
y a este producto, de cualquier forma. A fecha de presentaci¢n de esta segunda
versi¢n seguimos sin conocer de la existencia de una alternativa a este
entorno lo cual, a pesar de que a nosotros se supone que deber¡a alegrarnos,
nos parece tan increible como triste.

Somos conscientes de que quedan muchos pasos por dar, y Vd. vuelve a tener
ahora la oportunidad de sugerirnos hacia donde.

{El equipo de DIV Games Studio.}

{/}Ver: {#2014,Acerca de...}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2001,Novedades del lenguaje en la versi¢n 2.0}{+6,1}{-}

{M s lenguaje.} Se ha ampliado el lenguaje de programaci¢n, incluyendo
m£ltiples caracter¡sticas nuevas y funciones internas, a continuaci¢n se detallan
las principales novedades del {lenguaje DIV} en su {versi¢n 2.0}.

{/}

{+150,0}Las {opciones de compilaci¢n} son una nueva caracter¡stica de esta versi¢n, de
esta forma se permite adaptar el proceso de compilaci¢n a las necesidades de
cada proyecto (ver {#1400,Compiler_options}).{-}

{+150,0}Al margen de los datos ya conocidos de la primera versi¢n (que ahora se conocen
como {#1402,INT}), existen datos de los tipos {#1406,STRING} (cadenas de texto), {#1403,WORD} (enteros
positivos de 16 bit), {#1404,BYTE} (enteros positivos de 8 bit) y {#1405,POINTER} (punteros, de todos
estos tipos).{-}

{+150,0}Adem s se pueden definir {tablas} y {estructuras} (tambi‚n de cualquiera de
estos tipos) de {2} o {3 dimensiones} (ver la {#1011,declaraci¢n de una tabla}), y
las estructuras se pueden inicializar globalmente (ver la {#1012,declaraci¢n de una estructura}).{-}

{+150,0}Los nuevos {#1408,bloques FUNCTION} se comportan de forma an loga a las funciones de
otros lenguajes de programaci¢n, se ejecutan de forma secuencial (y no en paralelo como los procesos),
no retornando hasta que no han terminado.{-}

{+171,0}Se ha mejorado varios aspectos del {trazador de programas}, con nuevas funciones y
soporte para los nuevos tipos de datos. Destacan entre estas novedades los {perfiles de tiempo},
que pueden accederse con {F11} desde el trazador, donde se puede observar el tiempo
consumido por la ejecuci¢n y pintado de cada proceso.{-}

{+152,0}Se ha mejorado el {sistema de control de errores} de los programas, con
lo que se crean ejecutables m s s¢lidos y estables, existiendo ahora adem s
la posibilidad de anular ciertos errores de ejecuci¢n (ver la funci¢n {#240,ignore_error()}.{-}

{+157,0}Se han a¤adido una gran cantidad de {nuevas funciones de gesti¢n de archivos},
mucho m s flexibles y potentes; v‚ase por ejemplo {#223,fopen()}, {#227,fseek()},
{#231,get_dirinfo()}, {#235,chdir()}, {#237,remove()}) o {#238,disk_free()}.{-}

{+158,0}Al margen del soporte de m£sica CD-Audio y los efectos digitales, existen
ahora varias funciones para la reproducci¢n de m¢dulos musicales {MOD}, {S3M} y {XM}
(ver {#214,load_song()}, {#216,song()} o {#218,set_song_pos()}).{-}

{+163,0}{Generador de c¢digo optimizado.} El c¢digo generado para los programas es mejor y m s
r pido (un m¡nimo de un 60%) respecto a la versi¢n anterior. Adem s los programas {EXE}
creados son mucho m s peque¤os.{-}

{+164,0}{Funciones para juegos en red.} Ahora es posible crear con DIV Games Studio
juegos para jugar por {cable serie}, {m¢dem} y {red local IPX}. Con un sistema muy
simple controlado por las funciones {#180,net_join_game()} y {#181,net_get_games()}.{-}

{+165,0}Otra de las novedades es la integraci¢n en el lenguaje de un potente
manejo de cadenas de texto, con los datos de tipo {#1406,STRING}, m£ltiples
funciones (como por ejemplo {#203,strcat()}, {#206,strchr()}, {#209,upper()}
o {#211,strdel()}) y una sintaxis adaptada para trabajar con expresiones de
cadenas directamente en el lenguaje.{-}

{+166,0}{Soporte para memoria din mica}. Es posible pedir y liberar memoria
din micamente en los programas, gracias a las funciones {#257,malloc()} y
{#258,free()} (lo que se ve complementado con los nuevos datos de tipo {#1405,POINTER}).
Adem s la funci¢n {#239,memory_free()} permite determinar la memoria libre disponible en el sistema.{-}

{+167,0}Tambi‚n se ha a¤adido la posibilidad de {ordenaci¢n} y {desordenaci¢n},
con una simple pero potente funci¢n denominada {#213,qsort()} que permite ordenar
y desordenar estructuras de datos, tomando cualquier campo como ¡ndice de la misma.{-}

{+168,0}Otra de las novedades muy solicitada es la {b£squeda de caminos}. Se trata
de varias funciones (ver {#185,path_find()}) que permiten localizar rutas libres (llamadas
por algunos "rutinas de inteligencia artificial").{-}

{+169,0}{Compresi¢n de datos.} Todo es m s compacto; los
ejecutables y los datos instalados (se pueden crear {instalaciones
compactadas y protegidas}). Adem s se incluyen funciones de compresi¢n en el
lenguaje (ver {#262,compress_file()}).{-}

{+170,0}{Nuevo modo 8.} Un nuevo modo con hasta 10 regiones
de pantalla, que permite visualizar mapas de sectores tridimensionales. Con
un editor integrado en el entorno y m£ltiples funciones (ver por ejemplo
{#190,start_mode8()}, {#192,set_sector_height()}, o {#196,set_fog()}).{-}

{/}

{+176,0}{Y un largo etc‚tera.} Las novedades del lenguaje no acaban aqu¡,
existen muchas otras mejoras y funciones (adem s de los errores de la primera
versi¢n que se han corregido). A continuaci¢n se detallan brevemente otras
novedades del lenguaje DIV.{-}

- Una nueva funci¢n, denominada {#266,force_pal()}, permite que todos {los
gr ficos cargados en un programa se adapten autom ticamente a una paleta}
en tiempo de ejecuci¢n.

- Existen funciones de encriptaci¢n de datos, tanto en memoria como de
archivos, estas son {#259,encode()}, {#260,encode_file()} y {#261,decode_file()}.

- La {declaraci¢n de librer¡as} se realiza ahora en la cabecera del programa,
tras la sentencia {PROGRAM} (ver {#1014,IMPORT}).

- Ahora es posible crear programas en {muchos m s modos de v¡deo}, ya que se
pueden detectar los modos vesa disponibles (ver {#1415,video_modes}).

- En esta nueva versi¢n se prohiben inicialmente las {asignaciones dentro de
una condici¢n}, para facilitar la programaci¢n a usuarios no experimentados.
No obstante esto puede cambiarse (ver {#1400,_extended_conditions y
_simple_conditions}).

- Ahora es posible definir el {n£mero m ximo de procesos} que pueden haber en el
programa en tiempo de ejecuci¢n (ver {#1400,_max_process}).

- Es posible definir {literales en varias l¡neas}, para ello s¡mplemente deber  dividirse el
texto en varios, y ponerse estos seguidos (ver los {#1047,s¡mbolos delimitadores de literales}).

- El {sistema de sonido} es totalmente nuevo, y ahora se permite la reproducci¢n
de {archivos WAV de mucha m s calidad} en los programas (ver {#134,load_wav()} y
los nuevos campos de la estructura {#1104,setup}). Tambi‚n se han a¤adido funciones
de sonido como {#256,change_channel()} o {#221,is_playing_sound()}.

- Tambi‚n se permite ahora utilizar directamente {im genes en formato PCX} en los
programas (ver {#174,load_pcx()}), as¡ como grabar estos archivos (ver {#241,save_map/pcx()}).

- Existen funciones para fijar {un color de la paleta} ({#179,set_color()}) y tambi‚n
para localizar colores ({#264,find_color()}).

- Varias {funciones matem ticas} como {#242,sin()}, {#243,cos()}, {#244,tan()},
{#245,asin()}, ...

- Tambi‚n se han incluido {primitivas para dibujar} distintas gr ficas en pantalla:
l¡neas, rect ngulos y cajas, c¡rculos, ... (ver {#249,draw()}).

- Se han a¤adido {otras funciones} diversas que amplian las posibilidades existentes
en la creaci¢n de programas, como {#212,screen_copy()}, {#253,write_in_map()},
{#254,calculate()}, {#265,load_screen()}, {#183,xadvance()}, {#188,new_map()}, ...

- Tambi‚n se puede contar l s {im genes por segundo} (ver {#1426,fps}), obtener los {par metros del programa} (ver
{#1409,argv[]}), esperar el {retrazo vertical} (ver {#1417,vsync}), controlar mejor el
rat¢n en los programas (ver {#1100,mouse.cursor} y {#1100,mouse.speed}), etc.

{/}

Y adem s, todas las funciones, datos y posibilidades que ya brindaba la primera
versi¢n de DIV Games Studio, ­que siguen aqu¡! {:)}

{/}{Ver tambi‚n:} {#2002,Novedades del entorno gr fico}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2002,Novedades del entorno en la versi¢n 2.0}{+6,1}{-}

{M s flexibilidad y sencillez de uso.} El entorno de desarrollo de DIV Games
Studio ha evolucionado en m£ltiples peque¤os aspectos, y entre todos conforman
un interfaz a£n m s intuitivo que el de la versi¢n anterior.

{/}

{+151,0}{Una nueva ayuda.} La ayuda se ha actualizado, se ha estructurado
mejor, y por supuesto contempla todas las novedades del lenguaje DIV. El
formato de la ventana incluye una nueva barra de navegaci¢n.{-}

{+154,0}{Multiples tama¤os de pincel.} En el editor gr fico se pueden
seleccionar ahora pinceles de m£ltiples tama¤os y formas, monocromos o
en escala de grises. Con la tecla {T} se accede al nuevo di logo; se pueden
a¤adir nuevos pinceles, a¤adi‚ndolos al fichero {BRUSH.FPG} del directorio
{SYSTEM}.{-}

{+155,0}{Dibujo con capas o texturas.} En el editor gr fico se accede con la
tecla {U} a un nuevo di logo en el que se puede seleccionar cualquiera de los
mapas del escritorio como textura para pintar (con la tecla {X} se puede ver
y desplazar esta textura). Se ha mejorado la herramienta
del {aerosol}, la barra de {puntos de control}, y adem s se han a¤adido {nuevos
comandos de teclado} (como {K} para copiar un gr fico a ventana, o{ +/-} para
cambiar de punto de control).{-}

{+156,0}{Visualizadores gr ficos.} Casi todas las ventanas para abrir archivos
disponen de una casilla denominada {Im genes} que permite visualizar el contenido
de estos archivos antes de que sean cargados. Adem s es posible {cargar varios
archivos de una s¢la} vez marcando estos con el rat¢n mientras se mantiene la tecla
{Control} pulsada (la tecla {May£sculas} permite marcar varios consecutivos).{-}

{+157,0}{Sistema mejorado de ficheros.} En esta versi¢n se ha mejorado la gesti¢n interna
de los FPG; se han eliminado errores, se pueden visualizar reducciones de los mapas contenidos,
imprimir las listas, transferir un FPG completo a un mapa y viceversa.{-}

{+159,0}{Editor de efectos de sonido.} El sistema de audio es completamente nuevo,
permiti‚ndose muchas m s operaciones, formatos e incluy‚ndose un {mezclador} y un
{editor de efectos} de sonido. Se puede acceder a este editor a partir del men£
de sonidos.{-}

{+160,0}{Evaluaci¢n de expresiones.} Ahora se puede acceder a las nuevas ventanas
{calculadoras} (desde el men£ de sistema) para evaluar expresiones num‚ricas
mientras se est  programando, sin salir del entorno.{-}

{+161,0}{Generador de sprites.} El generador de personajes es tambi‚n una nueva caracter¡stica de esta versi¢n. Se
ha dise¤ado para ofrecer una base sobre la que realizar dibujos de seres humanos y
animaciones realistas. Pudiendo ser posteriormente utilizados estos fotogramas en el
editor gr fico para realizar sobre los mismos cualquier tipo de modificaci¢n.{-}

{+162,0}{Editor de mapas tridimensionales.} El men£ de mapas 3D, as¡ como el editor
de estos y todas las funciones relacionadas con los mismos del lenguaje de programaci¢n
son una nueva caracter¡stica de esta versi¢n de DIV Games Studio.{-}

{+171,0}{Perfiles de tiempo.} Desde el trazador de programas se puede acceder, pulsando F11, a los perfiles de
tiempo del programa. Estas estad¡sticas indican que est  consumiendo tiempo de
proceso durante la ejecuci¢n de un programa, y permiten la optimizaci¢n de la
velocidad de los programas manualmente.{-}

{+153,0}{Nuevos ejemplos.} Se incluyen m£ltiples juegos y programas
desarrollados por los usuarios con la versi¢n anterior de DIV Games Studio.
Adem s, en el CD-ROM se podr n encontrar m£ltiples utilidades shareware
o de libre uso que complementan a este entorno de desarrollo.{-}

{+172,0}{Facilidad de impresi¢n.} Esta versi¢n de DIV Games Studio permite imprimir,
adem s de los listados de los programas, las listas de gr ficos contenidas en un FPG
y las p ginas de ayuda electr¢nica.{-}

{+173,0}{Controles de volumen.} Dentro de las mejoras incluidas en el sistema
de audio, ahora existe un mejor control de los niveles de volumen, tanto en
el entorno como en los progrmas. En el reproductor de CD aparece un peque¤o
bot¢n que da acceso al mezclador.{-}

{+174,0}{Librer¡a de gr ficos.} Se ha ampliado y estructurado mejor la librer¡a
de gr ficos incluida con el programa. Adem s ahora se pueden importar mapas de
cualquier n£mero de colores en formatos BMP, PCX o JPG.{-}

{+175,0}{Nuevo sistema de instalaci¢n.} El sistema de instalaci¢n de los programas
ha sido completamente redise¤ado, gener ndose instalaciones protegidas contra
modificaciones y m s compactas, utilizando un {interface gr fico adaptable y m s intuitivo}.{-}

{/}

{+176,0}{Y un largo etc‚tera.} Existen muchas otras peque¤as mejoras en el entorno,
muchas que pasar n desapercibidas, pero que estan ah¡ haci‚ndolo m s
potente y f cil de utilizar. A continuaci¢n se detallan algunas que pueden
ser m s relevantes.{-}

- Se ha {optimizado el proceso de entrada y salida} del entorno, as¡ como la
ejecuci¢n de los programas desde el m¡smo, ahora las cargas son m s r pidas y
los tiempos de espera m s cortos.

- El editor de programas muestra ahora los {listados coloreados}, resaltando
las palabras clave del lenguaje, adem s se puede configurar mejor definiendo,
por ejemplo, el tama¤o de las tabulaciones.

- Ahora, al entrar en el entorno, se podr  seleccionar si desea {continuar con
la sesi¢n anterior} o {comenzar una nueva}.

- Es posible seleccionar {m s modos de visualizaci¢n} para el entorno, dependiendo de los modos
soportados por su tarjeta de v¡deo y el adaptador VESA instalado.

- Un {editor de gamas de colores} facilita la generaci¢n de explosiones (que
ahora puede ser abortada) y la preparaci¢n del tapiz de fondo (ahora se
muestra una previsualizaci¢n del mismo).

- Se puede configurar la {velocidad del puntero del rat¢n} con una peque¤a barra
presente en la ventana de configuraci¢n del men£ de sistema.

- En las ventanas de las fuentes {aparece una muestra de letras}, adem s de
indicarse que conjuntos de caracteres tienen definidos.

- Es posible generar fuentes de {letras con antidentado}, simplemente creando las
mismas con un reborde de 1 punto del color de fondo.

{/}{Ver tambi‚n:} {#2001,Novedades del lenguaje de programaci¢n}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2003,Resoluci¢n de problemas de configuraci¢n}

{Soluci¢n gen‚rica a los problemas de audio.}

Si el sistema de audio de no pudo ser inicializado, es debido a un
conflicto con su tarjeta de sonido. Este problema suele producirse por uno de
estos motivos:

- Que su tarjeta est‚ siendo utilizada por {otro programa} simult neamente. No se
podr  inicializar el dispositivo si existe alg£n otro programa leyendo o
escribiendo datos en la tarjeta (como un reproductor de MP3 o un capturador de
sonido).

- Puede haberse producido un problema con la {autodetecci¢n} de los par metros de
su tarjeta. Debe ejecutar el programa de configuraci¢n de sonido o bien definir
estos valores en la variable BLASTER o ULTRASND del entorno de su sistema (puede
encontrar m s informaci¢n en el manual de usuario de DIV Games Studio 2).

- Debido a una {incompatibilidad} de su tarjeta. Si esta no es una tarjeta
de las marcas GRAVIS (tm) o SOUND BLASTER (tm), puede que sea incompatible
con DIV Games Studio. La mayor¡a de tarjetas cl¢nicas suelen ser compatibles
con las tarjetas SOUND BLASTER, pero pueden no ser compatibles al 100% y
presentar alg£n problema.

Si no reconoce en ninguno de estos tres casos su problema particular debe,
en primer lugar, ejecutar el programa de configuraci¢n del sonido. Esto puede
hacerlo desde DIV pulsando {F4}, cargando el programa {SETUP.PRG} del
directorio {SETUP}, y ejecut ndolo con {F10}.

En este programa deber  introducir los par metros de su tarjeta de sonido.
Para obtener estos par metros a trav‚s de Windows es probable que deba consultar
el manual del mismo, aunque normalmente podr  acceder a ellos de la siguiente
forma: pulsando con el bot¢n derecho en "Mi Pc", activando Propiedades \
Administrador de dispositivos \ Dispositivos de sonido, video y juegos,
seleccionando su tarjeta de de Audio (normalmente una compatible con "Sound
Blaster" o "SB") y pulsando en Propiedades. Entonces aparecer  el di logo con las
caracteristicas de su tarjeta de sonido donde, en el apartado Recursos podr 
encontrar:

{1.} El n£mero de IRQ de su tarjeta como "petici¢n de interrupci¢n".

{2.} El n£mero de DMA y el de DMA2 (tambi‚n denominado como HDMA o DMA16)
como los dos "accesos directos a memoria".

{3.} El n£mero de Puerto como el valor inicial del primer "intervalo de entrada/salida".

Tambi‚n puede probar a configurar el sistema de sonido indicando en el programa
de configuraci¢n una tarjeta menor (anterior a la suya). Por ejemplo, si vd.
tuviera una tarjeta compatible con una {Sound Blaster AWE 64} o {128} y no pudiera
inicializar el sistema de sonido; pruebe a configurar el sistema como si tuviera
una {Sound Blaster 16}, o una {Sound Blaster Pro}.

Como £ltimo recurso, si no fuese posible configurar el sonido en su sistema,
deber  desactivarlo. Para ello deber  ejecutar igualmente el programa de configuraci¢n
y seleccionar {<Sin Sonido>} en el campo que define el tipo de tarjeta.
Entonces pulse el bot¢n {<Guardar>} para establecer esta configuraci¢n y desactivar
el sonido en DIV Games Studio 2.

Si a£n as¡ no consigue que se escuchen en su ordenador los efectos de sonido del
programa, probablemente se deba a que no dispone de una tarjeta de sonido 100%
compatible con la familia Sound Blaster o Gravis Ultrasound. Consulte, para ello, al
proveedor de su equipo.

{Nota:} La reproducci¢n de CD-Audio es independiente al sistema de sonido
digital cuya configuraci¢n se ha descrito aqu¡; por ello podr  seguir reproduciendo
m£sica de CD aunque el sistema de sonido no se encuentre debidamente inicializado.

{/}

{Problemas de v¡deo.}

Si en alg£n momento se entra en DIV en una resoluci¢n no visible, lo primero que debe hacerse
es salir del entorno pulsando la combinaci¢n {ESC+Control} (o {ALT+X} y {Enter} a
continuaci¢n) y, despu‚s, volver a entrar en el modo a prueba de fallos. Para ello se
debe, desde la l¡nea de comandos de {MSDOS} y en el directorio (carpeta) en la que se
haya instalado el programa, ejecutar el siguiente comando:

{  D /SAFE}ú

De esta forma se entrar  en el entorno en baja resoluci¢n (en 320x200, el modo m s
compatible de todos), a partir de este modo podr   intentar poner otros que sean
compatibles tanto con su tarjeta como con su monitor.

En aquellos equipos en los que el sistema de v¡deo no sea compatible con el est ndar
VESA debe utilizarse un driver vesa. Para esto, debe contactar con el proveedor o
servicio t‚cnico de su equipo hardware (un driver es un peque¤o programa que debe
instalarse en el ordenador para dar soporte a algunos dispositivos como, en este caso,
su tarjeta de v¡deo).

{/}

{Problemas con el rat¢n.}

Si el rat¢n se desplaza a saltos por la pantalla, en lugar de punto a punto, es debido a
que est  utilizando un dispositivo de rat¢n obsoleto o incorrecto (un driver de rat¢n no
actualizado). Puede solucionar este problema de una de estas formas:

{1.} Contacte con el proveedor de su equipo para conseguir un dispositivo de rat¢n
actualizado.

{2.} Cambie la resoluci¢n del programa (con la opci¢n {Sistema\Modo de v¡deo})
por otra en la que no se produzca este problema.

{3.} (MS-DOS, s¢lo para usuarios avanzados). Comente la l¡nea de su fichero
autoexec.bat en la que carga el dispositivo de rat¢n. Puede hacer ‚sto desde el
propio DIV, cargue con F4 este fichero (situado en el directorio raiz de su disco
duro de arranque) y a¤ada la palabra REM al inicio la l¡nea que carga el dispositivo
de rat¢n (una l¡nea que normalmente acaba con ...mouse.com). Entonces pulse
F2 para grabar el fichero nuevamente, ci‚rrelo (pulsando sobre el icono superior
izquierdo de la ventana de texto), salga de DIV (ALT+X) y reinicie su equipo. Si
despu‚s tuviese problemas con alg£n otro programa que requiriera ese dispositivo,
vuelva a editar el mismo fichero y quite la palabra REM que a¤adi¢ en el mismo.

{/}

{Soluci¢n a posibles problemas en la instalaci¢n.}

En caso de encontrar alg£n problema, revise los requerimientos m¡nimos del
programa indicados en el programa. Si tiene alguna duda sobre alguno de los
elementos consulte al servicio t‚cnico de su ordenador o al proveedor de su equipo.

Lo m s probable es que se presente alg£n problema de lectura del CD-
ROM con su unidad lectora; para ello, limpie la superficie del CD de DIV Games Studio
cuidadosamente con un pa¤o limpio y seco, y vuelva a intentar la instalaci¢n del
programa.

{Instalaci¢n manual}

Si no ha podido instalar correctamente el programa y dispone de mucho espacio
libre en el disco duro de su ordenador (suficiente para realizar una instalaci¢n
m xima del mismo), entonces puede probar a realizar una instalaci¢n manual del
programa, para ello siga los siguientes pasos:

{Usuarios de MS-DOS} - Suponiendo que su unidad de CD-ROM sea la D:, sit£ese en
la unidad de CD-ROM con el siguiente comando:

{  D:}

Y pulse Enter. Despu‚s introduzca los siguientes comandos (suponiendo que su
unidad de disco duro es la C):

{  XCOPY DATA\*.* C:\DIV\*.* /S}ú
{  C:}ú
{  CD \DIV}ú
{  DEL INSTALL*.*}ú

Pulsando Enter tras cada uno de estos comandos. Si tiene suficiente espacio el
programa se instalar  sin ning£n problema, introduzca el siguiente comando para
ejecutarlo posteriormente:

{  D /SAFE}ú

Para las proximas ejecuciones del programa, siga las instrucciones convencionales.

{Usuarios de Windows 95/98} - Abra una sesi¢n de MS-DOS (pulsando dos veces sobre su icono, o bien desde el
men£ inicio \ programas \ ms-dos) y siga las instrucciones para usuarios de MS-
DOS. Para las siguientes ejecuciones del programa podr  utilizar las instrucciones de
su sistema operativo, teniendo en cuenta que el programa se habr  instalado en la
carpeta DIV de su disco duro.

{/}

Si no consigue que el programa funcione correctamente con ninguno de estos consejos, entonces contacte
con el servicio t‚cnico de Hammer, cuyo tel‚fono es (91) 304 06 22, y su horario de
atenci¢n los Martes y Jueves de 16:00  a 18:00.

Se recuerda que, debido a que DIV Games Studio es un producto de venta masiva y
con un soporte t‚cnico limitado, debe procurar seguir cuidadosamente las
instrucciones antes de contactar con este servicio.

{Importante:} No se podr  realizar en dicho servicio t‚cnico ninguna consulta acerca
del lenguaje de programaci¢n, ya que no se ofrece m s soporte del mismo que este
{hipertexto de ayuda} y el {manual de usuario} del programa. Con ellos puede solucionar
cualquier duda que se le plantee.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2004,¨Que es DIV Games Studio?}{+1,1}{-}

Se podr¡a decir que es un entorno gr fico que integra un nuevo lenguaje de
programaci¢n para videojuegos junto a otras utilidades como un programa de
dibujo, herramientas para crear fuentes de letras, paletas, etc.

El lenguaje de programaci¢n ha sido dise¤ado en exclusiva para la creaci¢n
de juegos y, como podr  observar, permite obtener muy buenos resultados con
programas muy cortos y sencillos.

No es necesario que usted sepa programar para poder utilizarlo, DIV se ha
dise¤ado para que se pueda aprender a programar con ‚l. Es simplemente
cuesti¢n de perderle el miedo a la palabra "programar" ...

{/}Ver: {#2005,Trabajando con las ventanas} - {#2000,Introducci¢n a 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2005,Trabajando con las ventanas}

Las ventanas, pueden desplazarse hacia cualquier posici¢n de pantalla si se pulsa
sobre la barra de t¡tulo con el rat¢n y se arrastra hasta la nueva posici¢n.

{Barra de t¡tulo.} - Es la zona superior de las ventanas, donde se muestra su nombre en
color blanco sobre fondo azul. Cuando el nombre de la ventana aparece en colores
grises, es porque la ventana no est  seleccionada (debido a que habr  alguna de su
misma categor¡a que lo est‚), para seleccionarla bastar  con pulsar sobre ella.

{Arrastrar.} - Este t‚rmino se aplica dentro del entorno gr fico a la acci¢n de pulsar con
el rat¢n sobre un objeto, desplazarlo a una nueva posici¢n, y finalmente soltar el bot¢n
del rat¢n.

Para pedir al sistema que coloque una ventana autom ticamente, se debe realizar
una doble pulsaci¢n con el rat¢n sobre la barra de t¡tulo de la ventana. Si el sistema
encuentra una posici¢n mejor para la ventana, la desplazar  hasta ella.

Las ventanas pueden estar en {diferentes modos}, y en funci¢n del mismo su operatividad
sera distinta. A continuaci¢n se describen estos modos:

{1. Ventanas activas:} Son las que tienen, normalmente, si no se cambia la
configuraci¢n de colores, la barra de t¡tulo iluminada, en letras blancas sobre fondo
azul y est n sobre las dem s en el escritorio.

{2. Ventanas inactivas:} Este tipo de ventanas tienen la barra de t¡tulo oscurecida, en
letras negras sobre fondo gris oscuro. Para activar una de estas ventanas bastar 
con pulsar sobre ellas.

{3. Ventanas en segundo plano:} Son ventanas que est n oscurecidas; esto es
debido a que est n, al menos parcialmente, tapadas por otras ventanas. Con estas
ventanas no se podr  interaccionar hasta que no se pasen a primer plano
pulsando con el rat¢n sobre ellas.

{4. Iconos:} Los iconos son las ventanas que se ha minimizado, es decir, que se han
reducido temporalmente. Los iconos no muestran ning£n dibujo, £nicamente un
bot¢n con un signo "+" seguido del t¡tulo de la ventana.

{Nota:} Para arrastrar los gr ficos (a un fichero, al escritorio, etc.) no se debe
pulsar sobre la barra de t¡tulo de la ventana (con lo que se arrastrar¡a la misma),
si no sobre el contenido de la ventana. Es decir, que hay que pulsar m s o menos en
el centro de la ventana y, sin soltar el bot¢n del rat¢n, desplazarlo a la nueva
posici¢n.

{/}Ver: {#2006,Tipos de ventanas} - {#2000,Introducci¢n a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2006,Tipos de ventanas}

Las ventanas se pueden clasificar seg£n su funci¢n, realiz ndose las
siguientes agrupaciones:

{1. Di logos interactivos:} stos son los cuadros que se utilizan para solicitar
informaci¢n al usuario; existe una gran variedad de ellos, por lo que ya se ir n
viendo en las respectivas opciones

{2. Cuadros de error:} Son di logos en los que la barra de t¡tulo aparece en blanco
sobre rojo e informan de alg£n problema que se haya producido.

{3. Men£s de opciones:} Los men£s son una lista de opciones que llaman a otros
men£s, ventanas o di logos al pulsar sobre ellas. Todos los men£s parten del
men£ principal. Algunos men£s tienen ciertas opciones desactivadas (se
muestra un puntero con un s¡mbolo prohibido al situar el rat¢n sobre ellas); esto es
debido a que dichas opciones interact£an con un tipo de ventanas en concreto, y
no hay ninguna ventana de dicho tipo activa (se debe antes crear o cargar una).

{4. Programas:} En estas ventanas es donde se crean los programas y son ventanas
de edici¢n de texto. Para editar un programa debe estar su ventana activada (s¢lo
uno de los programas cargados puede estar activado). La edici¢n de texto es muy
similar a otros editores de texto (soporta el est ndar EDIT entre ellos).

Para pedir ayuda en un programa sobre una palabra del lenguaje hay que situar el
cursor parpadeante de edici¢n (no el puntero del rat¢n) sobre la misma y, despu‚s,
pulsar la tecla {F1}. Estas ventanas pueden cambiarse de tama¤o pulsando en el
bot¢n inferior derecho de las mismas y arrastrando con el rat¢n o pulsando {Control}+{Z}.

{5. Mapas o gr ficos:} Estas ventanas son las que contienen un mapa (bitmap) o
gr fico (un dibujo de los empleados en un juego) y se controlan por medio del
men£ de mapas. Pueden cargarse de un archivo MAP (formato propio), importarse
de un archivo PCX, BMP o JPG. Para editar los gr ficos se debe realizar una
doble pulsaci¢n del bot¢n del rat¢n en el centro de estas ventanas entrando, de
este modo, en el editor gr fico (descrito en el {manual de usuario}). Estos gr ficos pueden
arrastrarse hasta el tapiz (para hacer una copia), hasta otro gr fico (para
insertarlos), hasta un fichero de gr ficos (para incluirlos) o hasta la papelera (para
borrarlos), para ello se debe arrastrar desde el centro de las ventanas, en lugar
de la barra de t¡tulo.

{6. Mapas 3D:} Estos son los mapas vectoriales creados en el editor de mapas 3D,
en su ventana se muestran como un conjunto de pol¡gonos cerrados
representando el alzado de un plano. Su creaci¢n no es trivial, y se describe en el
{manual de usuario}. Estos mapas se guardan en disco en los archivos con extensi¢n WLD.

{7. FPG o Ficheros para gr ficos:} Estas ventanas muestran el contenido de un
fichero del disco. Son librer¡as o colecciones de gr ficos utilizadas en los
juegos; su utilidad reside en no tener que cargar en un juego una gran cantidad de
mapas por separado. Tienen dos modos b sicos de funcionamiento, activados
mediante una casilla denominada "Info" en su parte inferior. Cuando esta casilla
no est  activada (por defecto) se pueden marcar y desmarcar una serie de gr ficos
sobre la que pretende realizar una operaci¢n, o bien arrastrar gr ficos hacia
fuera del fichero (hacia el tapiz, otros ficheros, mapas o la papelera). Cuando
dicha casilla est  activada se pueden editar los c¢digos de los gr ficos y sus
descripciones. Estos FPG se controlan siempre mediante el men£ de ficheros.

Las ventanas de los FPG son siempre un reflejo directo del "fichero para gr ficos"
contenido en el disco duro del ordenador, por ello pueden cerrarse en cualquier
momento, sin tener que guardarlas previamente. No se perder  nunca su contenido.
La opci¢n {Ficheros \ Guardar} como permite hacer una copia del FPG con otro
nombre distinto (como copia temporal o de seguridad).

{8. Fuentes de letras:} Las fuentes o tipos de letra son unas ventanas peque¤as que
representan una tipograf¡a concreta. Se debe pulsar sobre ellas para ver una
muestra del fuente a tama¤o real. Se corresponden con archivos FNT (formato
propio) y son controladas por el men£ de fuentes, desde el cual se puede acceder
al generador de fuentes que es la herramienta utilizada para crear nuevas fuentes
de letras. Las fuentes de letras se utilizan dentro del programa de dibujo y en los
programas para escribir textos.

{9. Efectos de sonido:} Representan en pantalla un archivo PCM (pulse code
modulation) o WAV con un efecto de sonido. Se controlan mediante el men£ de
sonidos, pudiendo crearse efectos nuevos (con la grabadora de sonidos) o
editarse. Se puede encontrar una librer¡a de efectos de sonido ya preparados para
su utilizaci¢n en los juegos. Para escuchar un efecto de sonido se debe tener una
tarjeta de sonido compatible con las familias Sound Blaster o Gravis Ultrasound
correctamente configurada y pulsar sobre una de estas ventanas.

{10. M¢dulos musicales:} Se pueden cargar canciones en los formatos MOD, S3M y
XM. Estas se representan en una peque¤a ventana que permite activar o parar su
reproducci¢n. No siendo posible componer estos m¢dulos desde el propio entorno.

{11. Ventana de ayuda:} Se controla principalmente con el rat¢n, pudiendo utilizar
tambi‚n los cursores, las teclas de avance y retroceso p gina y la tecla Borrar
para volver a la p gina anterior (es la tecla que est  sobre Enter). En
las ventanas de ayuda se muestran en blanco los textos que hacen referencia a
otras p ginas de ayuda. Se debe pulsar sobre estas referencias para acceder a
dichas p ginas. En las ventanas de ayuda tambi‚n se muestran programas de
ejemplo que se pueden extraer pulsando sobre su t¡tulo, ejecutar con la tecla
F10 y abortar pulsando ALT+X.

{12. Calculadoras:} Las ventanas de las calculadoras funcionan como evaluadores de
expresiones matem ticas, al estilo de las expresiones presentes en los programas.
Su funcionamiento es muy simple, ya que basta con introducir una expresi¢n y
pulsar Enter para ver el resultado. Pudi‚ndose utilizar par‚ntesis para indicar
subexpresiones.

{Nota:} La ventana de la papelera se debe activar primero a partir del men£
de sistema, con la opci¢n correspondiente ({Sistema \ Papelera}) del mismo.

{/}Ver: {#2010,Fijando un modo de video} - {#2000,Introducci¢n a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2007,Versi¢n de demostraci¢n}{+1,1}{-}

Esta es una copia de DIV Games Studio 2 exclusiva para su evaluaci¢n, y est 
limitada a 31 ejecuciones del programa.

Esta versi¢n de demostraci¢n es completamente funcional, y se ha creado con el
prop¢sito de que vd. pueda evaluar las posibilidades del programa y la
compatibilidad del mismo con su sistema, antes de adquirir una copia registrada
del mismo.

Tan s¢lo existen dos funciones restringidas en esta versi¢n:

- El {tama¤o de los programas} que pueden ser compilados est  limitado por un
n£mero de objetos m ximo.

- Los programas instalables (al crear un EXE independiente de DIV con la opci¢n
{Programas} \ {Crear instalacion}) quedar n marcados por un mensaje informativo.

Estas restricciones no existen en la versi¢n comercial del programa, pero adem s
se recuerda que esta viene acompa¤ada de un {Manual de Usuario} imprescindible
para acceder a todas las funciones del programa y para el aprendizaje del
lenguaje de programaci¢n de DIV 2.

{/}

{Nota:} La informaci¢n contenida en el Manual de Usuario de DIV Games Studio 2
(sobre las novedades del entorno, las opciones del programa, el tutorial del nuevo
lenguaje, ...) no se podr  encontrar en esta ayuda electr¢nica.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2008,Conflicto con el dispositivo de sonido}

El sistema de audio de DIV Games Studio no pudo ser inicializado debido a un
conflicto con su tarjeta de sonido. Este problema suele producirse por uno de
estos motivos:

- Que su tarjeta est‚ siendo utilizada por {otro programa} simult neamente. No se
podr  inicializar el dispositivo si existe alg£n otro programa leyendo o
escribiendo datos en la tarjeta (como un reproductor de MP3 o un capturador de
sonido).

- Puede haberse producido un problema con la {autodetecci¢n} de los par metros de
su tarjeta. Debe ejecutar el programa de configuraci¢n de sonido o bien definir
estos valores en la variable BLASTER o ULTRASND del entorno de su sistema (puede
encontrar m s informaci¢n en el manual de usuario de DIV Games Studio 2).

- Debido a una {incompatibilidad} de su tarjeta. Si esta no es una tarjeta
de las marcas GRAVIS (tm) o SOUND BLASTER (tm), puede que sea incompatible
con DIV Games Studio. La mayor¡a de tarjetas cl¢nicas suelen ser compatibles
con las tarjetas SOUND BLASTER, pero pueden no ser compatibles al 100% y
presentar alg£n problema.

{/}

{Soluci¢n gen‚rica a los problemas de audio.}

Si no reconoce en ninguno de estos tres casos su problema particular debe,
en primer lugar, ejecutar el programa de configuraci¢n del sonido. Esto puede
hacerlo desde DIV pulsando {F4}, cargando el programa {SETUP.PRG} del
directorio {SETUP}, y ejecut ndolo con {F10}.

En el primer cap¡tulo del {manual de usuario} encontrar  informaci¢n sobre
como obtener los par metros de su tarjeta de sonido.

Tambi‚n puede probar a configurar el sistema de sonido indicando en el programa
de configuraci¢n una tarjeta menor (anterior a la suya). Por ejemplo, si vd.
tuviera una tarjeta compatible con una {Sound Blaster AWE 64} o {128} y no pudiera
inicializar el sistema de sonido; pruebe a configurar el sistema como si tuviera
una {Sound Blaster 16}, o una {Sound Blaster Pro}.

Como £ltimo recurso, si no fuese posible configurar el sonido en su sistema,
deber  desactivarlo. Para ello deber  ejecutar igualmente el programa de configuraci¢n
y seleccionar {<Sin Sonido>} en el campo que define el tipo de tarjeta.
Entonces pulse el bot¢n {<Guardar>} para establecer esta configuraci¢n y desactivar
el sonido en DIV Games Studio 2.

{/}

{Nota:} La reproducci¢n de CD-Audio es independiente al sistema de sonido
digital cuya configuraci¢n se ha descrito aqu¡; por ello podr  seguir reproduciendo
m£sica de CD aunque el sistema de sonido no se encuentre debidamente inicializado.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2009,El dispositivo de sonido no est  inicializado}

No se podr n reproducir sonidos digitales dentro de DIV Games Studio 2 si el
dispositivo de sonido est  desactivado.

Probablemente se haya seleccionado en el programa de configuraci¢n {<Sin
Sonido>}, en lugar de indicar el tipo de tarjeta de audio instalada en su
equipo (o una compatible con la misma).

{/}Ver: {#2008,Conflictos con el dispositivo de sonido}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2010,Fijando un modo de video}

La opci¢n {Sistema \ Modo de v¡deo} da acceso a un cuadro de di logo que permite
modificar la resoluci¢n utilizada por el entorno gr fico de DIV Games Studio 2.

Las resoluciones de v¡deo se indican como el n£mero de puntos en horizontal y
vertical existentes en la pantalla en dicho modo y var¡an entre 320x200 (baja
resoluci¢n) y la resoluci¢n m xima que permita su tarjeta de v¡deo. Para seleccionar
una nueva resoluci¢n se debe pulsar sobre la lista que aparece en el cuadro y
despu‚s en el bot¢n de {Aceptar}.

{Nota:} Algunos de estos modos de v¡deo pueden visualizarse incorrectamente
(por ejemplo, una resoluci¢n que est‚ permitida por su tarjeta de v¡deo pero no por su
monitor); en estos casos se deber  esperar unos {15 segundos} para que el entorno
recupere la resoluci¢n anterior. No debe pulsar ninguna tecla, ni realizar ninguna
acci¢n, simplemente espere.

{Selecci¢n de la fuente del sistema.}

Dos casillas permiten seleccionar la fuente utilizada por el sistema, existiendo dos
posibilidades que no s¢lo difieren en el tama¤o de las letras sino, en general, en el
tama¤o de todas las ventanas del entorno.

{1. Fuente peque¤a (y ventanas peque¤as).} En este modo todas las ventanas,
men£s y cuadros se ver n en un tama¤o menor, siendo el apropiado para modos
de baja resoluci¢n o equipos con un monitor lo suficientemente grande.

{2. Fuente grande (y ventanas grandes).} Este modo podr  ser activado
£nicamente en resoluciones a partir de 640x480 y es el apropiado para estas
resoluciones en monitores peque¤os.

{Nota:} La fuente de letras utilizada en los programas y en la ventana de ayuda es
independiente de la seleccionada para el sistema, y se define en la ventana de
configuraci¢n, accesible tambi‚n desde este mismo men£ de sistema.

{/}Ver: {#2011,La ventana de configuraci¢n} - {#2000,Introducci¢n a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2011,La ventana de configuraci¢n}

Mediante la opci¢n {Sistema\Configuraci¢n} se acceder  a un cuadro de di logo
dividido en varias secciones, que se muestran a continuaci¢n.

{Colores de ventanas}

Esta primera secci¢n establece los colores utilizados por el entorno; se pueden indicar
los colores para el fondo de las ventanas, la tinta para las letras y el color de la barra
de t¡tulo. Para cambiar estos colores se debe pulsar sobre las cajas. El sistema no
s¢lo utiliza estos tres colores sino que, a partir de ellos, genera una gama de colores
intermedios para los textos, cursores, botones, etc.

{Editor de programas}

Establece la apariencia de las ventanas de edici¢n de programas. Se pueden
seleccionar colores variados para los diferentes objetos (palabras o s¡mbolos)
presentes en los programas.

{1.} Fondo de la ventana de edici¢n.ú
{2.} Tinta general para las letras.ú
{3.} Cursor de edici¢n.ú
{4.} Comentarios explicativos de los programas.ú
{5.} S¡mbolos y operadores de expresiones.ú
{6.} Palabras reservadas del lenguaje.ú
{7.} N£meros dentro del programa.ú
{8.} Literales, o textos entre comillas.ú

Los bloques de texto marcados dentro del editor se ver n con los colores de tinta y
fondo intercambiados.

Una caja de texto permite definir el tama¤o (en n£mero de espacios) del tabulador en
el editor de programas, como un n£mero entre 1 y 16. Afectando a este al indentado
de las sentencias en el lenguaje. Por defecto se tabula cada 4 columnas.

Tambi‚n es posible seleccionar aqu¡ el tama¤o de las letras de los programas y la
ayuda, desde 6x8 hasta 9x16 puntos. Todas las fuentes de letras para edici¢n son de
espaciado fijo.

{Programa de dibujo}

Se define la cantidad de memoria reservada para deshacer opciones en el editor
gr fico, la velocidad del puntero de rat¢n y su representaci¢n.

La cantidad de "memoria de deshacer" se especifica en Kbytes, por defecto es
1088Kb (algo m s de un mega), y no es necesario modificar este valor a no ser que
no se pueda realizar una operaci¢n en el editor gr fico por falta de memoria de
deshacer (en cuyo caso el programa advertir  de ello). Cuanta m s memoria de
deshacer se reserve, menos memoria quedar  disponible en el sistema para el resto
de acciones.

La velocidad del puntero del rat¢n se define con una peque¤a barra horizontal (m s
r pido a la izquierda y mas lento a la derecha), y afecta a todo el entorno de ventanas,
no s¢lo al programa de dibujo.

{Opciones globales del entorno}

{1. Ventanas emergentes.} Indica que todos los movimientos de ventanas deben ser
visualizados, cuando se abren, se cierren, se minimicen, etc. Si se desactiva esta
opci¢n, el entorno perder  efectismo pero ganar  velocidad de respuesta.

{2. Mover ventanas completas.} Indica que al arrastrarse las ventanas a una nueva
posici¢n se debe ver en todo momento el resultado final. Puede ser conveniente
desactivar esta opci¢n en los equipos m s lentos.

{3. Guardar sesi¢n siempre.} Indica que al salir de DIV Games Studio se debe
guardar el estado del escritorio y todos sus objetos (programas, mapas, sonidos,
etc.). Si se desactiva esta opci¢n la entrada y salida del entorno ser  m s r pida,
pero se puede correr el riesgo de perder trabajos que no hayan sido guardados.

{4. Colorear los listados.} Indica que, cuando se est‚ editando un archivo con
extensi¢n PRG, se deben aplicar todos los colores anteriormente seleccionados
para el editor. En caso contrario se aplicar n £nicamente los colores de fondo,
tinta y cursor. Al igual que cuando se edite un archivo que no sea un PRG.

{Nota:} Si se cierra la ventana de configuraci¢n o se pulsa la tecla ESC se perder n todos los
cambios realizados en la misma, restableci‚ndose los valores de la configuraci¢n
anterior.

{/}Ver: {#2012,Toma de contacto con el lenguaje} - {#2000,Introducci¢n a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2012,Toma de contacto con el lenguaje}

En esta secci¢n se explicar  c¢mo ejecutar los juegos ejemplo de DIV Games Studio y
unas instrucciones r pidas para que vd. pueda comenzar a investigar sobre ellos,
adquiriendo de esta forma las primeras nociones de este lenguaje de programaci¢n.

{Instrucciones generales}

Todos los juegos incluidos son simples ejemplos, cuya complejidad no pretende
competir con los juegos comerciales que pueden ser creados con esta herramienta.
Aunque se trate de juegos completos, la mayor¡a son muy sencillos o muy cortos.

El motivo es que se ha pretendido mostrar las t‚cnicas que emplean y c¢mo se
realizan los programas, ofreciendo con ellos un bot¢n de muestra, en lugar de
enormes listados en los que el lector se pierda.

{Nota:} Estos juegos no pueden nunca mostrar las posibilidades reales de este entorno de
desarrollo, ya que pr cticamente ning£n juego las utiliza. La gran mayor¡a de las
nuevas y potentes capacidades de esta versi¢n de DIV Games Studio no han sido
utilizadas en ning£n ejemplo, d ndole a vd. la posibilidad de ser de los primeros que
intenten, o quiz  logren, exprimirlas al m ximo.

Para ejecutar cualquiera de los ejemplos se debe, primero, cargar el programa con la
opci¢n {Programas\Abrir programa}, con lo que aparecer  una ventana con el listado
del programa cargado.

{El sistema de ayuda}

Una de las mejores opciones es investigar, examinando los programas e intentando
realizar alg£n cambio en ellos; al situarse sobre cualquier palabra reservada, constante, variable, funci¢n,
etc., del lenguaje se puede pulsar la tecla F1 para ver una p gina de ayuda sobre
dicho objeto.

Si, al pulsar F1, no apareciera la ayuda sobre el objeto (sino que aparece el ¡ndice
general), es porque ‚ste no es un nombre propio del lenguaje DIV, sino que se trata de
alg£n dato o proceso exclusivo del juego (los procesos son una especie de funciones
que rigen el comportamiento de los gr ficos, o 'sprites', en los juegos).

{Nota:} Se recomienda comenzar a examinar juegos sencillos, como los tutoriales o, sobre
todo, los ejemplos incluidos en la ayuda electr¢nica; para acceder a ellos debe pulsar
el bot¢n denominado Funciones de la ventana de ayuda y, desde esa p gina, ir
accediendo a las diferentes explicaciones de las funciones del lenguaje de
programaci¢n, de donde se pueden extraer peque¤os ejemplos pulsando sobre su
cabecera o titular.

Los textos que comienzan con el s¡mbolo // (doble barra) son comentarios
explicativos, no forman parte del programa, sino que £nicamente consisten en "notas
aclaratorias" sobre el funcionamiento interno del programa. Estos comentarios suelen
ser de gran ayuda para comprender el funcionamiento de los programas. Tambi‚n
pueden aparecer comentarios entre los s¡mbolos /* y */ (a lo largo de varias l¡neas del
programa).

Para irse a uno de los procesos del programa (uno de los bloques que tienen los
programas para controlar un gr fico o sprite del juego) se debe pulsar la tecla F5 y
seleccionar el nombre del proceso en cuesti¢n con el rat¢n.

{Ejecuci¢n de los ejemplos}

Para ejecutar uno de los programas cargados, se debe pulsar con el rat¢n sobre su
ventana y despu‚s la tecla F10 (esta acci¢n tambi‚n se puede realizar con la opci¢n
Programas \ Ejecutar).

Las instrucciones de los juegos var¡an de unos a otros, pero la mayor¡a permiten salir
pulsando la tecla ESC y se manejan mayoritariamente con las teclas de los cursores y
la tecla Control (ver los {#1292,comandos comunes en los juegos}).

La tecla de Pausa se podr  utilizar en todos los juegos para detener su ejecuci¢n
moment neamente. Todos los programas pueden abortarse en cualquier punto,
independientemente de su programaci¢n, si se pulsa la combinaci¢n de teclas ALT+X.

{/}Ver: {#2013,Trazando los programas} - {#2000,Introducci¢n a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2013,Trazando los programas}

Las mentes m s inquietas pueden curiosear en los juegos pulsando la tecla F12
(desde el propio juego, estando ‚ste en ejecuci¢n), que permite acceder al trazador
de programas, que es una utilidad dise¤ada para ejecutar paso a paso los juegos.
Pudiendo observar todos los procesos y modificar sus datos (si se da con el dato
apropiado, se pueden cambiar todos los par metros del juego, el n£mero de fase, las
vidas, ...).

En la parte superior de esta ventana aparece una lista con los procesos activos en
cada momento (algo as¡ como los mu¤ecos o gr ficos que est  empleando el
programa). Estos se pueden seleccionar con el rat¢n y, pulsando el bot¢n {Ver datos},
se ver n todas las variables, contadores, etc. que el proceso est  utilizando.

En la parte inferior de la pantalla aparece el listado del programa, que b sicamente
son las ¢rdenes que el ordenador debe ir cumpliendo para que el juego funcione. Este
aparece dividido normalmente en peque¤os bloques que comienzan con palabra
{PROCESS} (una de las palabras reservadas del lenguaje de programaci¢n). En cada
uno de estos bloques vienen especificadas las ordenes para elemento concreto del
juego (por ejemplo, para un disparo, un enemigo o una explosi¢n).

{Funcionamiento general de los programas}

A grandes rasgos, los juegos siempre son una secuencia de im genes. Para
componer cada imagen intervienen varios elementos (o procesos) en funci¢n del tipo
de juego. Todos estos elementos deben realizar una serie de operaciones o c lculos
(normalmente muy simples) para determinar cual debe ser su apariencia en la
siguiente imagen (que dibujo o gr fico se debe mostrar, en que posici¢n, a que
tama¤o, etc.)

El ordenador va cumpliendo las ¢rdenes especificadas para cada proceso hasta
encontrarse con la orden {FRAME} (imagen o fotograma). Esta orden indica que un
proceso ya est  listo para mostrarse en la siguiente imagen, es decir, que ya ha
definido todos los par metros que definir n su apariencia en la siguiente imagen.

{Nota:} A las ¢rdenes especificadas en un programa se les denomina sentencias. Cada una
de estas sentencia indica una operaci¢n o c lculo que el ordenador debe realizar.

De esta forma, el ordenador ir  relizando todas estas operaciones y c lculos que
le vayan indicando las ordenes de cada proceso, hasta que todos los procesos
activos hayan dado la orden {FRAME}. En ese momento, el ordenador dejar  de
ejecutar ¢rdenes y se dedicar  en exclusiva a componer la siguiente imagen que debe
aparecer en el monitor.

Luego en los juegos van alternando siempre estas dos tareas, primero se ejecutan las
¢rdenes, y despu‚s se compone y muestra la imagen.

{Controles b sicos del trazador}

Esto puede ser visualizado desde el trazador de programas, por medio de varios
botones que permiten que las acciones de un programa o juego se vayan realizando
poco a poco, de forma visible. Los principales botones son los siguientes:

{1. Paso.} Indica al ordenador que ejecute la siguiente orden del siguiente proceso. El
siguiente proceso aparece resaltado en color blanco en la lista superior del
trazador, y la siguiente orden a realizar (por este proceso) aparece en el listado del
programa resaltada en el mismo color.

{2. Ejec.Proceso.} Este bot¢n se utiliza para que el ordenador ejecute todas las
instrucciones del siguiente proceso hasta llegar a una orden FRAME, es decir, que
realice todas las operaciones necesarias para que el siguiente proceso pueda ser
visualizado en la siguiente imagen.

{3. Sgte.Frame.} Este bot¢n es el utilizado para avanzar el juego imagen a imagen.
Cada vez que sea pulsado se ejecutar n todas las ¢rdenes pendientes de todos
los procesos activos, se compondr  la nueva imagen, y finalmente se volcar  a
v¡deo (se denomina "volcar a v¡deo" a la acci¢n de transferir una imagen que se
acaba de componer a la tarjeta de v¡deo, de forma que esta se visualice en el
monitor del ordenador).

Cuando se realiza un programa, todos los aspectos imaginables pueden ser
controlados: el ¢rden en el que se ejecutan las ¢rdenes de los diferentes procesos, el
¢rden en el que los gr ficos se superponen en pantalla, las reacciones varios procesos
al superponerse (al "tocarse" uno con el otro), cuando deben emitirse los efectos de
sonido, las reacciones de cada proceso al teclado, rat¢n, ...

{/}Ver: {#2000,Introducci¢n a DIV 2}
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2014,Acerca de ...}

Idea original y programa por: Daniel Navarro

Programaci¢n auxiliar: Juanjo Garrido

Programaci¢n modo 8 y red: Luis Fernando Fern ndez

Apoyo en programaci¢n: Fernando P‚rez

Ejemplos y pruebas: Antonio Marchal, Luis Sureda,
Manuel Caba¤as, Daniel Mu¤oz

Gr ficos: Santiago Garc¡a, Miguel Angel Carrillo,
Carlos Caba¤as, Rafael Barraso, Julio C‚sar L¢pez,
Jos‚ Fern ndez, Eva Astorga, J.Ricardo Abell ,
Pablo de la Sierra

Efectos de sonido: Carlos Illana

Apoyo moral: C‚sar Valencia

Producci¢n: Mario de Luis, Carlos Doral

Beta-tester: Ferm¡n Vicente Rosas,Iv n Garc¡a Cortijo,
Pedro Tomas Matilla, Roberto Selva Gomis,
Daniel Bustos Fern ndes, Enrique Gonz lez Mart¡nez,
Juan Alcaraz S nchez, Juan Gomar Vidal,
Gin‚s Garc¡a Mateos, Ismael Fern ndez Bustos
(Nota: Lamentamos no haber podido enviar una
copia a todos los Betatester con los que se
contact¢, por falta de tiempo.)

Gracias a: Bel‚n P‚rez, Wonder, Pete, Rubo, DDI,
Tizo, Sobakus, Juangake, Christian, Tom s Cuadra,
Javier Carri¢n, David Pic¢n, Pedro P. Aull¢, JB,
Zeen, Jens Grobecker, J.C. Ar‚valo, Carlos Doral,
Rafa S. Gago, Antonio Ruiz y Gonzalo Mart¡n

DOS/4GW (c) Rational Systems, Inc. 1990,94

DIV Games Studio (c) 1998,99 Hammer Technologies.

(c) 98,99 Hammer Technologies.

DIV Games Studio - v2.01

Daniel Navarro Medrano.

{/}Ver: {#2000,Introducci¢n a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2047,Ultimo t‚rmino posible dentro de este hipertexto}
